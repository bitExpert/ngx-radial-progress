/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("tsickle/src/googmodule", ["require", "exports", "path", "typescript", "tsickle/src/transformer_util"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var path = require("path");
    var ts = require("typescript");
    var transformer_util_1 = require("tsickle/src/transformer_util");
    /**
     * Returns true if node is a property access of `child` on the identifier `parent`.
     */
    function isPropertyAccess(node, parent, child) {
        if (!ts.isPropertyAccessExpression(node))
            return false;
        return ts.isIdentifier(node.expression) && node.expression.escapedText === parent &&
            node.name.escapedText === child;
    }
    /** Returns true if expr is "module.exports = ...;". */
    function isModuleExportsAssignment(expr) {
        if (!ts.isBinaryExpression(expr.expression))
            return false;
        if (expr.expression.operatorToken.kind !== ts.SyntaxKind.EqualsToken)
            return false;
        return isPropertyAccess(expr.expression.left, 'module', 'exports');
    }
    /** Returns true if expr is "exports = ...;". */
    function isExportsAssignment(expr) {
        if (!ts.isBinaryExpression(expr.expression))
            return false;
        if (expr.expression.operatorToken.kind !== ts.SyntaxKind.EqualsToken)
            return false;
        return ts.isIdentifier(expr.expression.left) && expr.expression.left.text === 'exports';
    }
    /** isUseStrict returns true if node is a "use strict"; statement. */
    function isUseStrict(node) {
        if (node.kind !== ts.SyntaxKind.ExpressionStatement)
            return false;
        var exprStmt = node;
        var expr = exprStmt.expression;
        if (expr.kind !== ts.SyntaxKind.StringLiteral)
            return false;
        var literal = expr;
        return literal.text === 'use strict';
    }
    /**
     * TypeScript inserts the following code to mark ES moduels in CommonJS:
     *   Object.defineProperty(exports, "__esModule", { value: true });
     * This matches that code snippet.
     */
    function isEsModuleProperty(stmt) {
        // We're matching the explicit source text generated by the TS compiler.
        // Object.defineProperty(exports, "__esModule", { value: true });
        var expr = stmt.expression;
        if (!ts.isCallExpression(expr))
            return false;
        if (!isPropertyAccess(expr.expression, 'Object', 'defineProperty'))
            return false;
        if (expr.arguments.length !== 3)
            return false;
        var _a = __read(expr.arguments, 3), exp = _a[0], esM = _a[1], val = _a[2];
        if (!ts.isIdentifier(exp) || exp.escapedText !== 'exports')
            return false;
        if (!ts.isStringLiteral(esM) || esM.text !== '__esModule')
            return false;
        if (!ts.isObjectLiteralExpression(val) || val.properties.length !== 1)
            return false;
        var prop = val.properties[0];
        if (!ts.isPropertyAssignment(prop))
            return false;
        var ident = prop.name;
        if (!ident || !ts.isIdentifier(ident) || ident.text !== 'value')
            return false;
        return prop.initializer.kind === ts.SyntaxKind.TrueKeyword;
    }
    /**
     * Returns the string argument if call is of the form
     *   require('foo')
     */
    function extractRequire(call) {
        // Verify that the call is a call to require(...).
        if (call.expression.kind !== ts.SyntaxKind.Identifier)
            return null;
        var ident = call.expression;
        if (ident.escapedText !== 'require')
            return null;
        // Verify the call takes a single string argument and grab it.
        if (call.arguments.length !== 1)
            return null;
        var arg = call.arguments[0];
        if (arg.kind !== ts.SyntaxKind.StringLiteral)
            return null;
        return arg.text;
    }
    /** Creates a call expression corresponding to `goog.${methodName}(${literal})`. */
    function createGoogCall(methodName, literal) {
        return ts.createCall(ts.createPropertyAccess(ts.createIdentifier('goog'), methodName), undefined, [literal]);
    }
    /**
     * Extracts the namespace part of a goog: import URL, or returns null if the given import URL is not
     * a goog: import.
     *
     * For example, for `import 'goog:foo.Bar';`, returns `foo.Bar`.
     */
    function extractGoogNamespaceImport(tsImport) {
        if (tsImport.match(/^goog:/))
            return tsImport.substring('goog:'.length);
        return null;
    }
    exports.extractGoogNamespaceImport = extractGoogNamespaceImport;
    // Matches common extensions of TypeScript input filenames
    var TS_EXTENSIONS = /(\.ts|\.d\.ts|\.js|\.jsx|\.tsx)$/;
    /**
     * Convert from implicit `import {} from 'pkg'` to a full resolved file name, including any `/index`
     * suffix and also resolving path mappings. TypeScript and many module loaders support the
     * shorthand, but `goog.module` does not, so tsickle needs to resolve the module name shorthand
     * before generating `goog.module` names.
     */
    function resolveModuleName(_a, pathOfImportingFile, imported) {
        var options = _a.options, moduleResolutionHost = _a.moduleResolutionHost;
        // The strategy taken here is to use ts.resolveModuleName() to resolve the import to
        // a specific path, which resolves any /index and path mappings.
        var resolved = ts.resolveModuleName(imported, pathOfImportingFile, options, moduleResolutionHost);
        if (!resolved || !resolved.resolvedModule)
            return imported;
        var resolvedModule = resolved.resolvedModule.resolvedFileName;
        // Check if the resolution went into node_modules.
        // Note that the ResolvedModule returned by resolveModuleName() has an
        // attribute isExternalLibraryImport that is documented with
        // "True if resolvedFileName comes from node_modules", but actually it is just
        // true if the absolute path includes node_modules, and is always true when
        // tsickle itself is under a directory named node_modules.
        var relativeResolved = path.relative(options.rootDir || '', resolvedModule);
        if (relativeResolved.indexOf('node_modules') !== -1) {
            // Imports into node_modules resolve through package.json and must be
            // specially handled by the loader anyway.  Return the input.
            return imported;
        }
        // Otherwise return the full resolved file name. This path will be turned into a module name using
        // AnnotatorHost#pathToModuleName, which also takes care of baseUrl and rootDirs.
        return resolved.resolvedModule.resolvedFileName;
    }
    exports.resolveModuleName = resolveModuleName;
    /**
     * importPathToGoogNamespace converts a TS/ES module './import/path' into a goog.module compatible
     * namespace, handling regular imports and `goog:` namespace imports.
     */
    function importPathToGoogNamespace(host, file, tsImport) {
        var modName;
        var nsImport = extractGoogNamespaceImport(tsImport);
        if (nsImport !== null) {
            // This is a namespace import, of the form "goog:foo.bar".
            // Fix it to just "foo.bar".
            modName = nsImport;
        }
        else {
            if (host.convertIndexImportShorthand) {
                tsImport = resolveModuleName(host, file.fileName, tsImport);
            }
            modName = host.pathToModuleName(file.fileName, tsImport);
        }
        return transformer_util_1.createSingleQuoteStringLiteral(modName);
    }
    /**
     * Replace "module.exports = ..." with just "exports = ...". Returns null if `expr` is not an
     * exports assignment.
     */
    function rewriteModuleExportsAssignment(expr) {
        if (!ts.isBinaryExpression(expr.expression))
            return null;
        if (expr.expression.operatorToken.kind !== ts.SyntaxKind.EqualsToken)
            return null;
        if (!isPropertyAccess(expr.expression.left, 'module', 'exports'))
            return null;
        return ts.setOriginalNode(ts.setTextRange(ts.createStatement(ts.createAssignment(ts.createIdentifier('exports'), expr.expression.right)), expr), expr);
    }
    /**
     * commonJsToGoogmoduleTransformer returns a transformer factory that converts TypeScript's CommonJS
     * module emit to Closure Compiler compatible goog.module and goog.require statements.
     */
    function commonJsToGoogmoduleTransformer(host, modulesManifest, typeChecker, diagnostics) {
        return function (context) {
            // TS' CommonJS processing uses onSubstituteNode to, at the very end of processing, substitute
            // "modulename.default" for default imports. We intercept the substitution here, check if it's a
            // .default access, then check if the original node (and thus original import) was from a goog:
            // module, and if so, replace with just the module name.
            var previousOnSubstituteNode = context.onSubstituteNode;
            context.enableSubstitution(ts.SyntaxKind.PropertyAccessExpression);
            context.onSubstituteNode = function (hint, node) {
                node = previousOnSubstituteNode(hint, node);
                if (!ts.isPropertyAccessExpression(node))
                    return node;
                if (node.name.text !== 'default')
                    return node;
                if (!ts.isIdentifier(node.expression))
                    return node;
                // Find the import declaration this node comes from.
                // This may be the original node, if the identifier was transformed from it.
                var orig = ts.getOriginalNode(node.expression);
                var importExportDecl;
                if (ts.isImportDeclaration(orig) || ts.isExportDeclaration(orig)) {
                    importExportDecl = orig;
                }
                else {
                    // Alternatively, we can try to find the declaration of the symbol. This only works for
                    // user-written .default accesses, the generated ones do not have a symbol associated as
                    // they are only produced in the CommonJS transformation, after type checking.
                    var sym = typeChecker.getSymbolAtLocation(node.expression);
                    if (!sym)
                        return node;
                    var decls = sym.getDeclarations();
                    if (!decls || !decls.length)
                        return node;
                    var decl = decls[0];
                    if (decl.parent && decl.parent.parent && ts.isImportDeclaration(decl.parent.parent)) {
                        importExportDecl = decl.parent.parent;
                    }
                    else {
                        return node;
                    }
                }
                // If the import declaration's URL is a "goog:..." style namespace, then all ".default"
                // accesses on it should be replaced with the symbol itself.
                // This allows referring to the module-level export of a "goog.module" or "goog.provide" as if
                // it was an ES6 default export.
                if (extractGoogNamespaceImport(importExportDecl.moduleSpecifier.text)) {
                    // Substitute "foo.default" with just "foo".
                    return node.expression;
                }
                return node;
            };
            return function (sf) {
                var e_1, _a, e_2, _b;
                // In TS2.9, transformers can receive Bundle objects, which this code cannot handle (given
                // that a bundle by definition cannot be a goog.module()). The cast through any is necessary
                // to remain compatible with earlier TS versions.
                // tslint:disable-next-line:no-any
                if (sf.kind !== ts.SyntaxKind.SourceFile)
                    return sf;
                var moduleVarCounter = 1;
                /**
                 * Creates a new unique variable to assign side effect imports into. This allows us to re-use
                 * the variable later on for other imports of the same namespace.
                 */
                function nextModuleVar() {
                    return "tsickle_module_" + moduleVarCounter++ + "_";
                }
                /**
                 * Maps goog.require namespaces to the variable name they are assigned into. E.g.:
                 *     var $varName = goog.require('$namespace'));
                 */
                var namespaceToModuleVarName = new Map();
                /**
                 * maybeCreateGoogRequire returns a `goog.require()` call for the given CommonJS `require`
                 * call. Returns null if `call` is not a CommonJS require.
                 */
                function maybeCreateGoogRequire(original, call, newIdent) {
                    var importedUrl = extractRequire(call);
                    if (!importedUrl)
                        return null;
                    var imp = importPathToGoogNamespace(host, sf, importedUrl);
                    modulesManifest.addReferencedModule(sf.fileName, imp.text);
                    var ident = namespaceToModuleVarName.get(imp.text);
                    var initializer;
                    if (!ident) {
                        namespaceToModuleVarName.set(imp.text, newIdent);
                        initializer = createGoogCall('require', imp);
                    }
                    else {
                        initializer = ident;
                    }
                    var varDecl = ts.createVariableDeclaration(newIdent, /* type */ undefined, initializer);
                    var newStmt = ts.createVariableStatement(
                    /* modifiers */ undefined, ts.createVariableDeclarationList([varDecl], 
                    // Use 'const' in ES6 mode so Closure properly forwards type aliases.
                    host.es5Mode ? undefined : ts.NodeFlags.Const));
                    return ts.setOriginalNode(ts.setTextRange(newStmt, original), original);
                }
                /**
                 * maybeRewriteRequireTslib rewrites a require('tslib') calls to goog.require('tslib'). It
                 * returns the input statement untouched if it does not match.
                 */
                function maybeRewriteRequireTslib(stmt) {
                    if (!ts.isExpressionStatement(stmt))
                        return stmt;
                    if (!ts.isCallExpression(stmt.expression))
                        return stmt;
                    var callExpr = stmt.expression;
                    if (!ts.isIdentifier(callExpr.expression) || callExpr.expression.text !== 'require') {
                        return stmt;
                    }
                    if (callExpr.arguments.length !== 1)
                        return stmt;
                    var arg = callExpr.arguments[0];
                    if (!ts.isStringLiteral(arg) || arg.text !== 'tslib')
                        return stmt;
                    return ts.setOriginalNode(ts.setTextRange(ts.createStatement(createGoogCall('require', arg)), stmt), stmt);
                }
                /**
                 * visitTopLevelStatement implements the main CommonJS to goog.module conversion. It visits a
                 * SourceFile level statement and adds a (possibly) transformed representation of it into
                 * statements. It adds at least one node per statement to statements.
                 *
                 * visitTopLevelStatement:
                 * - converts require() calls to goog.require() calls, with or w/o var assignment
                 * - removes "use strict"; and "Object.defineProperty(__esModule)" statements
                 * - converts module.exports assignments to just exports assignments
                 * - splits __exportStar() calls into require and export (this needs two statements)
                 * - makes sure to only import each namespace exactly once, and use variables later on
                 */
                function visitTopLevelStatement(statements, sf, node) {
                    // Handle each particular case by adding node to statements, then return.
                    // For unhandled cases, break to jump to the default handling below.
                    switch (node.kind) {
                        case ts.SyntaxKind.ExpressionStatement: {
                            var exprStmt = node;
                            // Check for "use strict" and certain Object.defineProperty and skip it if necessary.
                            if (isUseStrict(exprStmt) || isEsModuleProperty(exprStmt)) {
                                stmts.push(transformer_util_1.createNotEmittedStatementWithComments(sf, exprStmt));
                                return;
                            }
                            // Check for:
                            //   module.exports = ...;
                            var modExports = rewriteModuleExportsAssignment(exprStmt);
                            if (modExports) {
                                stmts.push(modExports);
                                return;
                            }
                            // Check for:
                            //   "require('foo');" (a require for its side effects)
                            var expr = exprStmt.expression;
                            if (!ts.isCallExpression(expr))
                                break;
                            var callExpr = expr;
                            // Handle export * in ES5 mode (in ES6 mode, export * is dereferenced already).
                            // export * creates either a pure top-level '__export(require(...))' or the imported
                            // version, 'tslib.__exportStar(require(...))'. The imported version is only substituted
                            // later on though, so appears as a plain "__exportStar" on the top level here.
                            var isExportStar = (ts.isIdentifier(expr.expression) && expr.expression.text === '__exportStar') ||
                                (ts.isIdentifier(expr.expression) && expr.expression.text === '__export');
                            if (isExportStar)
                                callExpr = expr.arguments[0];
                            var ident = ts.createIdentifier(nextModuleVar());
                            var require_1 = maybeCreateGoogRequire(exprStmt, callExpr, ident);
                            if (!require_1)
                                break;
                            statements.push(require_1);
                            // If this is an export star, split it up into the import (created by the maybe call
                            // above), and the export operation. This avoids a Closure complaint about non-top-level
                            // requires.
                            if (isExportStar) {
                                var args = [ident];
                                if (expr.arguments.length > 1)
                                    args.push(expr.arguments[1]);
                                statements.push(ts.createStatement(ts.createCall(expr.expression, undefined, args)));
                            }
                            return;
                        }
                        case ts.SyntaxKind.VariableStatement: {
                            // It's possibly of the form "var x = require(...);".
                            var varStmt = node;
                            // Verify it's a single decl (and not "var x = ..., y = ...;").
                            if (varStmt.declarationList.declarations.length !== 1)
                                break;
                            var decl = varStmt.declarationList.declarations[0];
                            // Grab the variable name (avoiding things like destructuring binds).
                            if (decl.name.kind !== ts.SyntaxKind.Identifier)
                                break;
                            if (!decl.initializer || !ts.isCallExpression(decl.initializer)) {
                                break;
                            }
                            var require_2 = maybeCreateGoogRequire(varStmt, decl.initializer, decl.name);
                            if (!require_2)
                                break;
                            statements.push(require_2);
                            return;
                        }
                        default:
                            break;
                    }
                    statements.push(node);
                }
                var moduleName = host.pathToModuleName('', sf.fileName);
                // Register the namespace this file provides.
                modulesManifest.addModule(sf.fileName, moduleName);
                // In JS transpilation mode, keep all CommonJS code, and only rewrite `require('tslib')` to
                // a goog.require().
                if (host.isJsTranspilation) {
                    var stmts_1 = [];
                    try {
                        for (var _c = __values(sf.statements), _d = _c.next(); !_d.done; _d = _c.next()) {
                            var stmt = _d.value;
                            stmts_1.push(maybeRewriteRequireTslib(stmt));
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                    return ts.updateSourceFileNode(sf, stmts_1);
                }
                // Convert each top level statement to goog.module.
                var stmts = [];
                try {
                    for (var _e = __values(sf.statements), _f = _e.next(); !_f.done; _f = _e.next()) {
                        var stmt = _f.value;
                        visitTopLevelStatement(stmts, sf, stmt);
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
                // Additional statements that will be prepended (goog.module call etc).
                var headerStmts = [];
                // Emit: goog.module('moduleName');
                var googModule = ts.createStatement(createGoogCall('module', transformer_util_1.createSingleQuoteStringLiteral(moduleName)));
                headerStmts.push(googModule);
                // Allow code to use `module.id` to discover its module URL, e.g. to resolve a template URL
                // against. Uses 'var', as this code is inserted in ES6 and ES5 modes. The following pattern
                // ensures closure doesn't throw an error in advanced optimizations mode.
                // var module = module || {id: 'path/to/module.ts'};
                var moduleId = host.fileNameToModuleId(sf.fileName);
                var moduleVarInitializer = ts.createBinary(ts.createIdentifier('module'), ts.SyntaxKind.BarBarToken, ts.createObjectLiteral([ts.createPropertyAssignment('id', transformer_util_1.createSingleQuoteStringLiteral(moduleId))]));
                var modAssign = ts.createVariableStatement(
                /* modifiers */ undefined, ts.createVariableDeclarationList([ts.createVariableDeclaration('module', /* type */ undefined, moduleVarInitializer)]));
                headerStmts.push(modAssign);
                if (!host.es5Mode) {
                    // The module=module assignment suppresses an unused variable warning which may trigger
                    // depending on the project's compilation flags.
                    headerStmts.push(ts.createStatement(ts.createAssignment(ts.createIdentifier('module'), ts.createIdentifier('module'))));
                    // The `exports = {}` serves as a default export to disable Closure Compiler's error
                    // checking
                    // for mutable exports. That's OK because TS compiler makes sure that consuming code always
                    // accesses exports through the module object, so mutable exports work.
                    // It is only inserted in ES6 because we strip `.default` accesses in ES5 mode, which breaks
                    // when assigning an `exports = {}` object and then later accessing it.
                    // However Closure bails if code later on assigns into exports directly, as we do if we have
                    // an "exports = " block, so skip emit if that's the case.
                    if (!sf.statements.find(function (s) { return ts.isExpressionStatement(s) &&
                        (isModuleExportsAssignment(s) || isExportsAssignment(s)); })) {
                        headerStmts.push(ts.createStatement(ts.createAssignment(ts.createIdentifier('exports'), ts.createObjectLiteral())));
                    }
                }
                // Insert goog.module() etc after any leading comments in the source file. The comments have
                // been converted to NotEmittedStatements by transformer_util, which this depends on.
                var insertionIdx = stmts.findIndex(function (s) { return s.kind !== ts.SyntaxKind.NotEmittedStatement; });
                if (insertionIdx === -1) {
                    stmts.push.apply(stmts, __spread(headerStmts));
                }
                else {
                    stmts.splice.apply(stmts, __spread([insertionIdx, 0], headerStmts));
                }
                return ts.updateSourceFileNode(sf, ts.setTextRange(ts.createNodeArray(stmts), sf.statements));
            };
        };
    }
    exports.commonJsToGoogmoduleTransformer = commonJsToGoogmoduleTransformer;
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ29vZ21vZHVsZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9nb29nbW9kdWxlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7R0FNRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBRUgsMkJBQTZCO0lBQzdCLCtCQUFpQztJQUdqQyxpRUFBMEc7SUF5QjFHOztPQUVHO0lBQ0gsU0FBUyxnQkFBZ0IsQ0FBQyxJQUFhLEVBQUUsTUFBYyxFQUFFLEtBQWE7UUFDcEUsSUFBSSxDQUFDLEVBQUUsQ0FBQywwQkFBMEIsQ0FBQyxJQUFJLENBQUM7WUFBRSxPQUFPLEtBQUssQ0FBQztRQUN2RCxPQUFPLEVBQUUsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsV0FBVyxLQUFLLE1BQU07WUFDN0UsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLEtBQUssS0FBSyxDQUFDO0lBQ3RDLENBQUM7SUFFRCx1REFBdUQ7SUFDdkQsU0FBUyx5QkFBeUIsQ0FBQyxJQUE0QjtRQUM3RCxJQUFJLENBQUMsRUFBRSxDQUFDLGtCQUFrQixDQUFDLElBQUksQ0FBQyxVQUFVLENBQUM7WUFBRSxPQUFPLEtBQUssQ0FBQztRQUMxRCxJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsYUFBYSxDQUFDLElBQUksS0FBSyxFQUFFLENBQUMsVUFBVSxDQUFDLFdBQVc7WUFBRSxPQUFPLEtBQUssQ0FBQztRQUNuRixPQUFPLGdCQUFnQixDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxFQUFFLFFBQVEsRUFBRSxTQUFTLENBQUMsQ0FBQztJQUNyRSxDQUFDO0lBRUQsZ0RBQWdEO0lBQ2hELFNBQVMsbUJBQW1CLENBQUMsSUFBNEI7UUFDdkQsSUFBSSxDQUFDLEVBQUUsQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDO1lBQUUsT0FB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QkFDL0M7Z0JBRUQsT0FBTyxFQUFFLENBQUMsb0JBQW9CLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxZQUFZLENBQUMsRUFBRSxDQUFDLGVBQWUsQ0FBQyxLQUFLLENBQUMsRUFBRSxFQUFFLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQztZQUNoRyxDQUFDLENBQUM7UUFDSixDQUFDLENBQUM7SUFDSixDQUFDO0lBalJELDBFQWlSQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCAqIGFzIHRzIGZyb20gJ3R5cGVzY3JpcHQnO1xuXG5pbXBvcnQge01vZHVsZXNNYW5pZmVzdH0gZnJvbSAnLi9tb2R1bGVzX21hbmlmZXN0JztcbmltcG9ydCB7Y3JlYXRlTm90RW1pdHRlZFN0YXRlbWVudFdpdGhDb21tZW50cywgY3JlYXRlU2luZ2xlUXVvdGVTdHJpbmdMaXRlcmFsLH0gZnJvbSAnLi90cmFuc2Zvcm1lcl91dGlsJztcblxuZXhwb3J0IGludGVyZmFjZSBHb29nTW9kdWxlUHJvY2Vzc29ySG9zdCB7XG4gIC8qKlxuICAgKiBUYWtlcyBhIGNvbnRleHQgKHRzLlNvdXJjZUZpbGUuZmlsZU5hbWUgb2YgdGhlIGN1cnJlbnQgZmlsZSkgYW5kIHRoZSBpbXBvcnQgVVJMIG9mIGFuIEVTNlxuICAgKiBpbXBvcnQgYW5kIGdlbmVyYXRlcyBhIGdvb2dtb2R1bGUgbW9kdWxlIG5hbWUgZm9yIHRoZSBpbXBvcnRlZCBtb2R1bGUuXG4gICAqL1xuICBwYXRoVG9Nb2R1bGVOYW1lKGNvbnRleHQ6IHN0cmluZywgaW1wb3J0UGF0aDogc3RyaW5nKTogc3RyaW5nO1xuICAvKipcbiAgICogSWYgd2UgZG8gZ29vZ21vZHVsZSBwcm9jZXNzaW5nLCB3ZSBwb2x5ZmlsbCBtb2R1bGUuaWQsIHNpbmNlIHRoYXQnc1xuICAgKiBwYXJ0IG9mIEVTNiBtb2R1bGVzLiAgVGhpcyBmdW5jdGlvbiBkZXRlcm1pbmVzIHdoYXQgdGhlIG1vZHVsZS5pZCB3aWxsIGJlXG4gICAqIGZvciBlYWNoIGZpbGUuXG4gICAqL1xuICBmaWxlTmFtZVRvTW9kdWxlSWQoZmlsZU5hbWU6IHN0cmluZyk6IHN0cmluZztcbiAgLyoqIElkZW50aWZpZXMgd2hldGhlciB0aGlzIGZpbGUgaXMgdGhlIHJlc3VsdCBvZiBhIEpTIHRyYW5zcGlsYXRpb24uICovXG4gIGlzSnNUcmFuc3BpbGF0aW9uPzogYm9vbGVhbjtcbiAgLyoqIFdoZXRoZXIgdGhlIGVtaXQgdGFyZ2V0cyBFUzUgb3IgRVM2Ky4gKi9cbiAgZXM1TW9kZT86IGJvb2xlYW47XG4gIC8qKiBleHBhbmQgXCJpbXBvcnQgJ2Zvbyc7XCIgdG8gXCJpbXBvcnQgJ2Zvby9pbmRleCc7XCIgaWYgaXQgcG9pbnRzIHRvIGFuIGluZGV4IGZpbGUuICovXG4gIGNvbnZlcnRJbmRleEltcG9ydFNob3J0aGFuZD86IGJvb2xlYW47XG5cbiAgb3B0aW9uczogdHMuQ29tcGlsZXJPcHRpb25zO1xuICBtb2R1bGVSZXNvbHV0aW9uSG9zdDogdHMuTW9kdWxlUmVzb2x1dGlvbkhvc3Q7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIG5vZGUgaXMgYSBwcm9wZXJ0eSBhY2Nlc3Mgb2YgYGNoaWxkYCBvbiB0aGUgaWRlbnRpZmllciBgcGFyZW50YC5cbiAqL1xuZnVuY3Rpb24gaXNQcm9wZXJ0eUFjY2Vzcyhub2RlOiB0cy5Ob2RlLCBwYXJlbnQ6IHN0cmluZywgY2hpbGQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICBpZiAoIXRzLmlzUHJvcGVydHlBY2Nlc3NFeHByZXNzaW9uKG5vZGUpKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB0cy5pc0lkZW50aWZpZXIobm9kZS5leHByZXNzaW9uKSAmJiBub2RlLmV4cHJlc3Npb24uZXNjYXBlZFRleHQgPT09IHBhcmVudCAmJlxuICAgICAgbm9kZS5uYW1lLmVzY2FwZWRUZXh0ID09PSBjaGlsZDtcbn1cblxuLyoqIFJldHVybnMgdHJ1ZSBpZiBleHByIGlzIFwibW9kdWxlLmV4cG9ydHMgPSAuLi47XCIuICovXG5mdW5jdGlvbiBpc01vZHVsZUV4cG9ydHNBc3NpZ25tZW50KGV4cHI6IHRzLkV4cHJlc3Npb25TdGF0ZW1lbnQpOiBib29sZWFuIHtcbiAgaWYgKCF0cy5pc0JpbmFyeUV4cHJlc3Npb24oZXhwci5leHByZXNzaW9uKSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoZXhwci5leHByZXNzaW9uLm9wZXJhdG9yVG9rZW4ua2luZCAhPT0gdHMuU3ludGF4S2luZC5FcXVhbHNUb2tlbikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gaXNQcm9wZXJ0eUFjY2VzcyhleHByLmV4cHJlc3Npb24ubGVmdCwgJ21vZHVsZScsICdleHBvcnRzJyk7XG59XG5cbi8qKiBSZXR1cm5zIHRydWUgaWYgZXhwciBpcyBcImV4cG9ydHMgPSAuLi47XCIuICovXG5mdW5jdGlvbiBpc0V4cG9ydHNBc3NpZ25tZW50KGV4cHI6IHRzLkV4cHJlc3Npb25TdGF0ZW1lbnQpOiBib29sZWFuIHtcbiAgaWYgKCF0cy5pc0JpbmFyeUV4cHJlc3Npb24oZXhwci5leHByZXNzaW9uKSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoZXhwci5leHByZXNzaW9uLm9wZXJhdG9yVG9rZW4ua2luZCAhPT0gdHMuU3ludGF4S2luZC5FcXVhbHNUb2tlbikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gdHMuaXNJZGVudGlmaWVyKGV4cHIuZXhwcmVzc2lvbi5sZWZ0KSAmJiBleHByLmV4cHJlc3Npb24ubGVmdC50ZXh0ID09PSAnZXhwb3J0cyc7XG59XG5cbi8qKiBpc1VzZVN0cmljdCByZXR1cm5zIHRydWUgaWYgbm9kZSBpcyBhIFwidXNlIHN0cmljdFwiOyBzdGF0ZW1lbnQuICovXG5mdW5jdGlvbiBpc1VzZVN0cmljdChub2RlOiB0cy5Ob2RlKTogYm9vbGVhbiB7XG4gIGlmIChub2RlLmtpbmQgIT09IHRzLlN5bnRheEtpbmQuRXhwcmVzc2lvblN0YXRlbWVudCkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBleHByU3RtdCA9IG5vZGUgYXMgdHMuRXhwcmVzc2lvblN0YXRlbWVudDtcbiAgY29uc3QgZXhwciA9IGV4cHJTdG10LmV4cHJlc3Npb247XG4gIGlmIChleHByLmtpbmQgIT09IHRzLlN5bnRheEtpbmQuU3RyaW5nTGl0ZXJhbCkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBsaXRlcmFsID0gZXhwciBhcyB0cy5TdHJpbmdMaXRlcmFsO1xuICByZXR1cm4gbGl0ZXJhbC50ZXh0ID09PSAndXNlIHN0cmljdCc7XG59XG5cbi8qKlxuICogVHlwZVNjcmlwdCBpbnNlcnRzIHRoZSBmb2xsb3dpbmcgY29kZSB0byBtYXJrIEVTIG1vZHVlbHMgaW4gQ29tbW9uSlM6XG4gKiAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAqIFRoaXMgbWF0Y2hlcyB0aGF0IGNvZGUgc25pcHBldC5cbiAqL1xuZnVuY3Rpb24gaXNFc01vZHVsZVByb3BlcnR5KHN0bXQ6IHRzLkV4cHJlc3Npb25TdGF0ZW1lbnQpOiBib29sZWFuIHtcbiAgLy8gV2UncmUgbWF0Y2hpbmcgdGhlIGV4cGxpY2l0IHNvdXJjZSB0ZXh0IGdlbmVyYXRlZCBieSB0aGUgVFMgY29tcGlsZXIuXG4gIC8vIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgY29uc3QgZXhwciA9IHN0bXQuZXhwcmVzc2lvbjtcbiAgaWYgKCF0cy5pc0NhbGxFeHByZXNzaW9uKGV4cHIpKSByZXR1cm4gZmFsc2U7XG4gIGlmICghaXNQcm9wZXJ0eUFjY2VzcyhleHByLmV4cHJlc3Npb24sICdPYmplY3QnLCAnZGVmaW5lUHJvcGVydHknKSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoZXhwci5hcmd1bWVudHMubGVuZ3RoICE9PSAzKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IFtleHAsIGVzTSwgdmFsXSA9IGV4cHIuYXJndW1lbnRzO1xuICBpZiAoIXRzLmlzSWRlbnRpZmllcihleHApIHx8IGV4cC5lc2NhcGVkVGV4dCAhPT0gJ2V4cG9ydHMnKSByZXR1cm4gZmFsc2U7XG4gIGlmICghdHMuaXNTdHJpbmdMaXRlcmFsKGVzTSkgfHwgZXNNLnRleHQgIT09ICdfX2VzTW9kdWxlJykgcmV0dXJuIGZhbHNlO1xuICBpZiAoIXRzLmlzT2JqZWN0TGl0ZXJhbEV4cHJlc3Npb24odmFsKSB8fCB2YWwucHJvcGVydGllcy5sZW5ndGggIT09IDEpIHJldHVybiBmYWxzZTtcbiAgY29uc3QgcHJvcCA9IHZhbC5wcm9wZXJ0aWVzWzBdO1xuICBpZiAoIXRzLmlzUHJvcGVydHlBc3NpZ25tZW50KHByb3ApKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IGlkZW50ID0gcHJvcC5uYW1lO1xuICBpZiAoIWlkZW50IHx8ICF0cy5pc0lkZW50aWZpZXIoaWRlbnQpIHx8IGlkZW50LnRleHQgIT09ICd2YWx1ZScpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHByb3AuaW5pdGlhbGl6ZXIua2luZCA9PT0gdHMuU3ludGF4S2luZC5UcnVlS2V5d29yZDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzdHJpbmcgYXJndW1lbnQgaWYgY2FsbCBpcyBvZiB0aGUgZm9ybVxuICogICByZXF1aXJlKCdmb28nKVxuICovXG5mdW5jdGlvbiBleHRyYWN0UmVxdWlyZShjYWxsOiB0cy5DYWxsRXhwcmVzc2lvbik6IHN0cmluZ3xudWxsIHtcbiAgLy8gVmVyaWZ5IHRoYXQgdGhlIGNhbGwgaXMgYSBjYWxsIHRvIHJlcXVpcmUoLi4uKS5cbiAgaWYgKGNhbGwuZXhwcmVzc2lvbi5raW5kICE9PSB0cy5TeW50YXhLaW5kLklkZW50aWZpZXIpIHJldHVybiBudWxsO1xuICBjb25zdCBpZGVudCA9IGNhbGwuZXhwcmVzc2lvbiBhcyB0cy5JZGVudGlmaWVyO1xuICBpZiAoaWRlbnQuZXNjYXBlZFRleHQgIT09ICdyZXF1aXJlJykgcmV0dXJuIG51bGw7XG5cbiAgLy8gVmVyaWZ5IHRoZSBjYWxsIHRha2VzIGEgc2luZ2xlIHN0cmluZyBhcmd1bWVudCBhbmQgZ3JhYiBpdC5cbiAgaWYgKGNhbGwuYXJndW1lbnRzLmxlbmd0aCAhPT0gMSkgcmV0dXJuIG51bGw7XG4gIGNvbnN0IGFyZyA9IGNhbGwuYXJndW1lbnRzWzBdO1xuICBpZiAoYXJnLmtpbmQgIT09IHRzLlN5bnRheEtpbmQuU3RyaW5nTGl0ZXJhbCkgcmV0dXJuIG51bGw7XG4gIHJldHVybiAoYXJnIGFzIHRzLlN0cmluZ0xpdGVyYWwpLnRleHQ7XG59XG5cbi8qKiBDcmVhdGVzIGEgY2FsbCBleHByZXNzaW9uIGNvcnJlc3BvbmRpbmcgdG8gYGdvb2cuJHttZXRob2ROYW1lfSgke2xpdGVyYWx9KWAuICovXG5mdW5jdGlvbiBjcmVhdGVHb29nQ2FsbChtZXRob2ROYW1lOiBzdHJpbmcsIGxpdGVyYWw6IHRzLlN0cmluZ0xpdGVyYWwpOiB0cy5DYWxsRXhwcmVzc2lvbiB7XG4gIHJldHVybiB0cy5jcmVhdGVDYWxsKFxuICAgICAgdHMuY3JlYXRlUHJvcGVydHlBY2Nlc3ModHMuY3JlYXRlSWRlbnRpZmllcignZ29vZycpLCBtZXRob2ROYW1lKSwgdW5kZWZpbmVkLCBbbGl0ZXJhbF0pO1xufVxuXG4vKipcbiAqIEV4dHJhY3RzIHRoZSBuYW1lc3BhY2UgcGFydCBvZiBhIGdvb2c6IGltcG9ydCBVUkwsIG9yIHJldHVybnMgbnVsbCBpZiB0aGUgZ2l2ZW4gaW1wb3J0IFVSTCBpcyBub3RcbiAqIGEgZ29vZzogaW1wb3J0LlxuICpcbiAqIEZvciBleGFtcGxlLCBmb3IgYGltcG9ydCAnZ29vZzpmb28uQmFyJztgLCByZXR1cm5zIGBmb28uQmFyYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RHb29nTmFtZXNwYWNlSW1wb3J0KHRzSW1wb3J0OiBzdHJpbmcpOiBzdHJpbmd8bnVsbCB7XG4gIGlmICh0c0ltcG9ydC5tYXRjaCgvXmdvb2c6LykpIHJldHVybiB0c0ltcG9ydC5zdWJzdHJpbmcoJ2dvb2c6Jy5sZW5ndGgpO1xuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gTWF0Y2hlcyBjb21tb24gZXh0ZW5zaW9ucyBvZiBUeXBlU2NyaXB0IGlucHV0IGZpbGVuYW1lc1xuY29uc3QgVFNfRVhURU5TSU9OUyA9IC8oXFwudHN8XFwuZFxcLnRzfFxcLmpzfFxcLmpzeHxcXC50c3gpJC87XG5cbi8qKlxuICogQ29udmVydCBmcm9tIGltcGxpY2l0IGBpbXBvcnQge30gZnJvbSAncGtnJ2AgdG8gYSBmdWxsIHJlc29sdmVkIGZpbGUgbmFtZSwgaW5jbHVkaW5nIGFueSBgL2luZGV4YFxuICogc3VmZml4IGFuZCBhbHNvIHJlc29sdmluZyBwYXRoIG1hcHBpbmdzLiBUeXBlU2NyaXB0IGFuZCBtYW55IG1vZHVsZSBsb2FkZXJzIHN1cHBvcnQgdGhlXG4gKiBzaG9ydGhhbmQsIGJ1dCBgZ29vZy5tb2R1bGVgIGRvZXMgbm90LCBzbyB0c2lja2xlIG5lZWRzIHRvIHJlc29sdmUgdGhlIG1vZHVsZSBuYW1lIHNob3J0aGFuZFxuICogYmVmb3JlIGdlbmVyYXRpbmcgYGdvb2cubW9kdWxlYCBuYW1lcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVNb2R1bGVOYW1lKFxuICAgIHtvcHRpb25zLCBtb2R1bGVSZXNvbHV0aW9uSG9zdH06XG4gICAgICAgIHtvcHRpb25zOiB0cy5Db21waWxlck9wdGlvbnMsIG1vZHVsZVJlc29sdXRpb25Ib3N0OiB0cy5Nb2R1bGVSZXNvbHV0aW9uSG9zdH0sXG4gICAgcGF0aE9mSW1wb3J0aW5nRmlsZTogc3RyaW5nLCBpbXBvcnRlZDogc3RyaW5nKTogc3RyaW5nIHtcbiAgLy8gVGhlIHN0cmF0ZWd5IHRha2VuIGhlcmUgaXMgdG8gdXNlIHRzLnJlc29sdmVNb2R1bGVOYW1lKCkgdG8gcmVzb2x2ZSB0aGUgaW1wb3J0IHRvXG4gIC8vIGEgc3BlY2lmaWMgcGF0aCwgd2hpY2ggcmVzb2x2ZXMgYW55IC9pbmRleCBhbmQgcGF0aCBtYXBwaW5ncy5cbiAgY29uc3QgcmVzb2x2ZWQgPVxuICAgICAgdHMucmVzb2x2ZU1vZHVsZU5hbWUoaW1wb3J0ZWQsIHBhdGhPZkltcG9ydGluZ0ZpbGUsIG9wdGlvbnMsIG1vZHVsZVJlc29sdXRpb25Ib3N0KTtcbiAgaWYgKCFyZXNvbHZlZCB8fCAhcmVzb2x2ZWQucmVzb2x2ZWRNb2R1bGUpIHJldHVybiBpbXBvcnRlZDtcbiAgY29uc3QgcmVzb2x2ZWRNb2R1bGUgPSByZXNvbHZlZC5yZXNvbHZlZE1vZHVsZS5yZXNvbHZlZEZpbGVOYW1lO1xuXG4gIC8vIENoZWNrIGlmIHRoZSByZXNvbHV0aW9uIHdlbnQgaW50byBub2RlX21vZHVsZXMuXG4gIC8vIE5vdGUgdGhhdCB0aGUgUmVzb2x2ZWRNb2R1bGUgcmV0dXJuZWQgYnkgcmVzb2x2ZU1vZHVsZU5hbWUoKSBoYXMgYW5cbiAgLy8gYXR0cmlidXRlIGlzRXh0ZXJuYWxMaWJyYXJ5SW1wb3J0IHRoYXQgaXMgZG9jdW1lbnRlZCB3aXRoXG4gIC8vIFwiVHJ1ZSBpZiByZXNvbHZlZEZpbGVOYW1lIGNvbWVzIGZyb20gbm9kZV9tb2R1bGVzXCIsIGJ1dCBhY3R1YWxseSBpdCBpcyBqdXN0XG4gIC8vIHRydWUgaWYgdGhlIGFic29sdXRlIHBhdGggaW5jbHVkZXMgbm9kZV9tb2R1bGVzLCBhbmQgaXMgYWx3YXlzIHRydWUgd2hlblxuICAvLyB0c2lja2xlIGl0c2VsZiBpcyB1bmRlciBhIGRpcmVjdG9yeSBuYW1lZCBub2RlX21vZHVsZXMuXG4gIGNvbnN0IHJlbGF0aXZlUmVzb2x2ZWQgPSBwYXRoLnJlbGF0aXZlKG9wdGlvbnMucm9vdERpciB8fCAnJywgcmVzb2x2ZWRNb2R1bGUpO1xuICBpZiAocmVsYXRpdmVSZXNvbHZlZC5pbmRleE9mKCdub2RlX21vZHVsZXMnKSAhPT0gLTEpIHtcbiAgICAvLyBJbXBvcnRzIGludG8gbm9kZV9tb2R1bGVzIHJlc29sdmUgdGhyb3VnaCBwYWNrYWdlLmpzb24gYW5kIG11c3QgYmVcbiAgICAvLyBzcGVjaWFsbHkgaGFuZGxlZCBieSB0aGUgbG9hZGVyIGFueXdheS4gIFJldHVybiB0aGUgaW5wdXQuXG4gICAgcmV0dXJuIGltcG9ydGVkO1xuICB9XG5cbiAgLy8gT3RoZXJ3aXNlIHJldHVybiB0aGUgZnVsbCByZXNvbHZlZCBmaWxlIG5hbWUuIFRoaXMgcGF0aCB3aWxsIGJlIHR1cm5lZCBpbnRvIGEgbW9kdWxlIG5hbWUgdXNpbmdcbiAgLy8gQW5ub3RhdG9ySG9zdCNwYXRoVG9Nb2R1bGVOYW1lLCB3aGljaCBhbHNvIHRha2VzIGNhcmUgb2YgYmFzZVVybCBhbmQgcm9vdERpcnMuXG4gIHJldHVybiByZXNvbHZlZC5yZXNvbHZlZE1vZHVsZS5yZXNvbHZlZEZpbGVOYW1lO1xufVxuXG4vKipcbiAqIGltcG9ydFBhdGhUb0dvb2dOYW1lc3BhY2UgY29udmVydHMgYSBUUy9FUyBtb2R1bGUgJy4vaW1wb3J0L3BhdGgnIGludG8gYSBnb29nLm1vZHVsZSBjb21wYXRpYmxlXG4gKiBuYW1lc3BhY2UsIGhhbmRsaW5nIHJlZ3VsYXIgaW1wb3J0cyBhbmQgYGdvb2c6YCBuYW1lc3BhY2UgaW1wb3J0cy5cbiAqL1xuZnVuY3Rpb24gaW1wb3J0UGF0aFRvR29vZ05hbWVzcGFjZShcbiAgICBob3N0OiBHb29nTW9kdWxlUHJvY2Vzc29ySG9zdCwgZmlsZTogdHMuU291cmNlRmlsZSwgdHNJbXBvcnQ6IHN0cmluZyk6IHRzLlN0cmluZ0xpdGVyYWwge1xuICBsZXQgbW9kTmFtZTogc3RyaW5nO1xuICBjb25zdCBuc0ltcG9ydCA9IGV4dHJhY3RHb29nTmFtZXNwYWNlSW1wb3J0KHRzSW1wb3J0KTtcbiAgaWYgKG5zSW1wb3J0ICE9PSBudWxsKSB7XG4gICAgLy8gVGhpcyBpcyBhIG5hbWVzcGFjZSBpbXBvcnQsIG9mIHRoZSBmb3JtIFwiZ29vZzpmb28uYmFyXCIuXG4gICAgLy8gRml4IGl0IHRvIGp1c3QgXCJmb28uYmFyXCIuXG4gICAgbW9kTmFtZSA9IG5zSW1wb3J0O1xuICB9IGVsc2Uge1xuICAgIGlmIChob3N0LmNvbnZlcnRJbmRleEltcG9ydFNob3J0aGFuZCkge1xuICAgICAgdHNJbXBvcnQgPSByZXNvbHZlTW9kdWxlTmFtZShob3N0LCBmaWxlLmZpbGVOYW1lLCB0c0ltcG9ydCk7XG4gICAgfVxuICAgIG1vZE5hbWUgPSBob3N0LnBhdGhUb01vZHVsZU5hbWUoZmlsZS5maWxlTmFtZSwgdHNJbXBvcnQpO1xuICB9XG4gIHJldHVybiBjcmVhdGVTaW5nbGVRdW90ZVN0cmluZ0xpdGVyYWwobW9kTmFtZSk7XG59XG5cbi8qKlxuICogUmVwbGFjZSBcIm1vZHVsZS5leHBvcnRzID0gLi4uXCIgd2l0aCBqdXN0IFwiZXhwb3J0cyA9IC4uLlwiLiBSZXR1cm5zIG51bGwgaWYgYGV4cHJgIGlzIG5vdCBhblxuICogZXhwb3J0cyBhc3NpZ25tZW50LlxuICovXG5mdW5jdGlvbiByZXdyaXRlTW9kdWxlRXhwb3J0c0Fzc2lnbm1lbnQoZXhwcjogdHMuRXhwcmVzc2lvblN0YXRlbWVudCkge1xuICBpZiAoIXRzLmlzQmluYXJ5RXhwcmVzc2lvbihleHByLmV4cHJlc3Npb24pKSByZXR1cm4gbnVsbDtcbiAgaWYgKGV4cHIuZXhwcmVzc2lvbi5vcGVyYXRvclRva2VuLmtpbmQgIT09IHRzLlN5bnRheEtpbmQuRXF1YWxzVG9rZW4pIHJldHVybiBudWxsO1xuICBpZiAoIWlzUHJvcGVydHlBY2Nlc3MoZXhwci5leHByZXNzaW9uLmxlZnQsICdtb2R1bGUnLCAnZXhwb3J0cycpKSByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIHRzLnNldE9yaWdpbmFsTm9kZShcbiAgICAgIHRzLnNldFRleHRSYW5nZShcbiAgICAgICAgICB0cy5jcmVhdGVTdGF0ZW1lbnQoXG4gICAgICAgICAgICAgIHRzLmNyZWF0ZUFzc2lnbm1lbnQodHMuY3JlYXRlSWRlbnRpZmllcignZXhwb3J0cycpLCBleHByLmV4cHJlc3Npb24ucmlnaHQpKSxcbiAgICAgICAgICBleHByKSxcbiAgICAgIGV4cHIpO1xufVxuXG4vKipcbiAqIGNvbW1vbkpzVG9Hb29nbW9kdWxlVHJhbnNmb3JtZXIgcmV0dXJucyBhIHRyYW5zZm9ybWVyIGZhY3RvcnkgdGhhdCBjb252ZXJ0cyBUeXBlU2NyaXB0J3MgQ29tbW9uSlNcbiAqIG1vZHVsZSBlbWl0IHRvIENsb3N1cmUgQ29tcGlsZXIgY29tcGF0aWJsZSBnb29nLm1vZHVsZSBhbmQgZ29vZy5yZXF1aXJlIHN0YXRlbWVudHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21tb25Kc1RvR29vZ21vZHVsZVRyYW5zZm9ybWVyKFxuICAgIGhvc3Q6IEdvb2dNb2R1bGVQcm9jZXNzb3JIb3N0LCBtb2R1bGVzTWFuaWZlc3Q6IE1vZHVsZXNNYW5pZmVzdCwgdHlwZUNoZWNrZXI6IHRzLlR5cGVDaGVja2VyLFxuICAgIGRpYWdub3N0aWNzOiB0cy5EaWFnbm9zdGljW10pOiAoY29udGV4dDogdHMuVHJhbnNmb3JtYXRpb25Db250ZXh0KSA9PlxuICAgIHRzLlRyYW5zZm9ybWVyPHRzLlNvdXJjZUZpbGU+IHtcbiAgcmV0dXJuIChjb250ZXh0OiB0cy5UcmFuc2Zvcm1hdGlvbkNvbnRleHQpOiB0cy5UcmFuc2Zvcm1lcjx0cy5Tb3VyY2VGaWxlPiA9PiB7XG4gICAgLy8gVFMnIENvbW1vbkpTIHByb2Nlc3NpbmcgdXNlcyBvblN1YnN0aXR1dGVOb2RlIHRvLCBhdCB0aGUgdmVyeSBlbmQgb2YgcHJvY2Vzc2luZywgc3Vic3RpdHV0ZVxuICAgIC8vIFwibW9kdWxlbmFtZS5kZWZhdWx0XCIgZm9yIGRlZmF1bHQgaW1wb3J0cy4gV2UgaW50ZXJjZXB0IHRoZSBzdWJzdGl0dXRpb24gaGVyZSwgY2hlY2sgaWYgaXQncyBhXG4gICAgLy8gLmRlZmF1bHQgYWNjZXNzLCB0aGVuIGNoZWNrIGlmIHRoZSBvcmlnaW5hbCBub2RlIChhbmQgdGh1cyBvcmlnaW5hbCBpbXBvcnQpIHdhcyBmcm9tIGEgZ29vZzpcbiAgICAvLyBtb2R1bGUsIGFuZCBpZiBzbywgcmVwbGFjZSB3aXRoIGp1c3QgdGhlIG1vZHVsZSBuYW1lLlxuICAgIGNvbnN0IHByZXZpb3VzT25TdWJzdGl0dXRlTm9kZSA9IGNvbnRleHQub25TdWJzdGl0dXRlTm9kZTtcbiAgICBjb250ZXh0LmVuYWJsZVN1YnN0aXR1dGlvbih0cy5TeW50YXhLaW5kLlByb3BlcnR5QWNjZXNzRXhwcmVzc2lvbik7XG4gICAgY29udGV4dC5vblN1YnN0aXR1dGVOb2RlID0gKGhpbnQsIG5vZGU6IHRzLk5vZGUpOiB0cy5Ob2RlID0+IHtcbiAgICAgIG5vZGUgPSBwcmV2aW91c09uU3Vic3RpdHV0ZU5vZGUoaGludCwgbm9kZSk7XG4gICAgICBpZiAoIXRzLmlzUHJvcGVydHlBY2Nlc3NFeHByZXNzaW9uKG5vZGUpKSByZXR1cm4gbm9kZTtcbiAgICAgIGlmIChub2RlLm5hbWUudGV4dCAhPT0gJ2RlZmF1bHQnKSByZXR1cm4gbm9kZTtcbiAgICAgIGlmICghdHMuaXNJZGVudGlmaWVyKG5vZGUuZXhwcmVzc2lvbikpIHJldHVybiBub2RlO1xuICAgICAgLy8gRmluZCB0aGUgaW1wb3J0IGRlY2xhcmF0aW9uIHRoaXMgbm9kZSBjb21lcyBmcm9tLlxuICAgICAgLy8gVGhpcyBtYXkgYmUgdGhlIG9yaWdpbmFsIG5vZGUsIGlmIHRoZSBpZGVudGlmaWVyIHdhcyB0cmFuc2Zvcm1lZCBmcm9tIGl0LlxuICAgICAgY29uc3Qgb3JpZyA9IHRzLmdldE9yaWdpbmFsTm9kZShub2RlLmV4cHJlc3Npb24pO1xuICAgICAgbGV0IGltcG9ydEV4cG9ydERlY2w6IHRzLkltcG9ydERlY2xhcmF0aW9ufHRzLkV4cG9ydERlY2xhcmF0aW9uO1xuICAgICAgaWYgKHRzLmlzSW1wb3J0RGVjbGFyYXRpb24ob3JpZykgfHwgdHMuaXNFeHBvcnREZWNsYXJhdGlvbihvcmlnKSkge1xuICAgICAgICBpbXBvcnRFeHBvcnREZWNsID0gb3JpZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFsdGVybmF0aXZlbHksIHdlIGNhbiB0cnkgdG8gZmluZCB0aGUgZGVjbGFyYXRpb24gb2YgdGhlIHN5bWJvbC4gVGhpcyBvbmx5IHdvcmtzIGZvclxuICAgICAgICAvLyB1c2VyLXdyaXR0ZW4gLmRlZmF1bHQgYWNjZXNzZXMsIHRoZSBnZW5lcmF0ZWQgb25lcyBkbyBub3QgaGF2ZSBhIHN5bWJvbCBhc3NvY2lhdGVkIGFzXG4gICAgICAgIC8vIHRoZXkgYXJlIG9ubHkgcHJvZHVjZWQgaW4gdGhlIENvbW1vbkpTIHRyYW5zZm9ybWF0aW9uLCBhZnRlciB0eXBlIGNoZWNraW5nLlxuICAgICAgICBjb25zdCBzeW0gPSB0eXBlQ2hlY2tlci5nZXRTeW1ib2xBdExvY2F0aW9uKG5vZGUuZXhwcmVzc2lvbik7XG4gICAgICAgIGlmICghc3ltKSByZXR1cm4gbm9kZTtcbiAgICAgICAgY29uc3QgZGVjbHMgPSBzeW0uZ2V0RGVjbGFyYXRpb25zKCk7XG4gICAgICAgIGlmICghZGVjbHMgfHwgIWRlY2xzLmxlbmd0aCkgcmV0dXJuIG5vZGU7XG4gICAgICAgIGNvbnN0IGRlY2wgPSBkZWNsc1swXTtcbiAgICAgICAgaWYgKGRlY2wucGFyZW50ICYmIGRlY2wucGFyZW50LnBhcmVudCAmJiB0cy5pc0ltcG9ydERlY2xhcmF0aW9uKGRlY2wucGFyZW50LnBhcmVudCkpIHtcbiAgICAgICAgICBpbXBvcnRFeHBvcnREZWNsID0gZGVjbC5wYXJlbnQucGFyZW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBJZiB0aGUgaW1wb3J0IGRlY2xhcmF0aW9uJ3MgVVJMIGlzIGEgXCJnb29nOi4uLlwiIHN0eWxlIG5hbWVzcGFjZSwgdGhlbiBhbGwgXCIuZGVmYXVsdFwiXG4gICAgICAvLyBhY2Nlc3NlcyBvbiBpdCBzaG91bGQgYmUgcmVwbGFjZWQgd2l0aCB0aGUgc3ltYm9sIGl0c2VsZi5cbiAgICAgIC8vIFRoaXMgYWxsb3dzIHJlZmVycmluZyB0byB0aGUgbW9kdWxlLWxldmVsIGV4cG9ydCBvZiBhIFwiZ29vZy5tb2R1bGVcIiBvciBcImdvb2cucHJvdmlkZVwiIGFzIGlmXG4gICAgICAvLyBpdCB3YXMgYW4gRVM2IGRlZmF1bHQgZXhwb3J0LlxuICAgICAgaWYgKGV4dHJhY3RHb29nTmFtZXNwYWNlSW1wb3J0KChpbXBvcnRFeHBvcnREZWNsLm1vZHVsZVNwZWNpZmllciBhcyB0cy5TdHJpbmdMaXRlcmFsKS50ZXh0KSkge1xuICAgICAgICAvLyBTdWJzdGl0dXRlIFwiZm9vLmRlZmF1bHRcIiB3aXRoIGp1c3QgXCJmb29cIi5cbiAgICAgICAgcmV0dXJuIG5vZGUuZXhwcmVzc2lvbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG5cbiAgICByZXR1cm4gKHNmOiB0cy5Tb3VyY2VGaWxlKTogdHMuU291cmNlRmlsZSA9PiB7XG4gICAgICAvLyBJbiBUUzIuOSwgdHJhbnNmb3JtZXJzIGNhbiByZWNlaXZlIEJ1bmRsZSBvYmplY3RzLCB3aGljaCB0aGlzIGNvZGUgY2Fubm90IGhhbmRsZSAoZ2l2ZW5cbiAgICAgIC8vIHRoYXQgYSBidW5kbGUgYnkgZGVmaW5pdGlvbiBjYW5ub3QgYmUgYSBnb29nLm1vZHVsZSgpKS4gVGhlIGNhc3QgdGhyb3VnaCBhbnkgaXMgbmVjZXNzYXJ5XG4gICAgICAvLyB0byByZW1haW4gY29tcGF0aWJsZSB3aXRoIGVhcmxpZXIgVFMgdmVyc2lvbnMuXG4gICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XG4gICAgICBpZiAoKHNmIGFzIGFueSkua2luZCAhPT0gdHMuU3ludGF4S2luZC5Tb3VyY2VGaWxlKSByZXR1cm4gc2Y7XG4gICAgICBsZXQgbW9kdWxlVmFyQ291bnRlciA9IDE7XG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZXMgYSBuZXcgdW5pcXVlIHZhcmlhYmxlIHRvIGFzc2lnbiBzaWRlIGVmZmVjdCBpbXBvcnRzIGludG8uIFRoaXMgYWxsb3dzIHVzIHRvIHJlLXVzZVxuICAgICAgICogdGhlIHZhcmlhYmxlIGxhdGVyIG9uIGZvciBvdGhlciBpbXBvcnRzIG9mIHRoZSBzYW1lIG5hbWVzcGFjZS5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gbmV4dE1vZHVsZVZhcigpIHtcbiAgICAgICAgcmV0dXJuIGB0c2lja2xlX21vZHVsZV8ke21vZHVsZVZhckNvdW50ZXIrK31fYDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBNYXBzIGdvb2cucmVxdWlyZSBuYW1lc3BhY2VzIHRvIHRoZSB2YXJpYWJsZSBuYW1lIHRoZXkgYXJlIGFzc2lnbmVkIGludG8uIEUuZy46XG4gICAgICAgKiAgICAgdmFyICR2YXJOYW1lID0gZ29vZy5yZXF1aXJlKCckbmFtZXNwYWNlJykpO1xuICAgICAgICovXG4gICAgICBjb25zdCBuYW1lc3BhY2VUb01vZHVsZVZhck5hbWUgPSBuZXcgTWFwPHN0cmluZywgdHMuSWRlbnRpZmllcj4oKTtcblxuICAgICAgLyoqXG4gICAgICAgKiBtYXliZUNyZWF0ZUdvb2dSZXF1aXJlIHJldHVybnMgYSBgZ29vZy5yZXF1aXJlKClgIGNhbGwgZm9yIHRoZSBnaXZlbiBDb21tb25KUyBgcmVxdWlyZWBcbiAgICAgICAqIGNhbGwuIFJldHVybnMgbnVsbCBpZiBgY2FsbGAgaXMgbm90IGEgQ29tbW9uSlMgcmVxdWlyZS5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gbWF5YmVDcmVhdGVHb29nUmVxdWlyZShcbiAgICAgICAgICBvcmlnaW5hbDogdHMuU3RhdGVtZW50LCBjYWxsOiB0cy5DYWxsRXhwcmVzc2lvbiwgbmV3SWRlbnQ6IHRzLklkZW50aWZpZXIpOiB0cy5TdGF0ZW1lbnR8XG4gICAgICAgICAgbnVsbCB7XG4gICAgICAgIGNvbnN0IGltcG9ydGVkVXJsID0gZXh0cmFjdFJlcXVpcmUoY2FsbCk7XG4gICAgICAgIGlmICghaW1wb3J0ZWRVcmwpIHJldHVybiBudWxsO1xuICAgICAgICBjb25zdCBpbXAgPSBpbXBvcnRQYXRoVG9Hb29nTmFtZXNwYWNlKGhvc3QsIHNmLCBpbXBvcnRlZFVybCk7XG4gICAgICAgIG1vZHVsZXNNYW5pZmVzdC5hZGRSZWZlcmVuY2VkTW9kdWxlKHNmLmZpbGVOYW1lLCBpbXAudGV4dCk7XG4gICAgICAgIGNvbnN0IGlkZW50OiB0cy5JZGVudGlmaWVyfHVuZGVmaW5lZCA9IG5hbWVzcGFjZVRvTW9kdWxlVmFyTmFtZS5nZXQoaW1wLnRleHQpO1xuICAgICAgICBsZXQgaW5pdGlhbGl6ZXI6IHRzLkV4cHJlc3Npb247XG4gICAgICAgIGlmICghaWRlbnQpIHtcbiAgICAgICAgICBuYW1lc3BhY2VUb01vZHVsZVZhck5hbWUuc2V0KGltcC50ZXh0LCBuZXdJZGVudCk7XG4gICAgICAgICAgaW5pdGlhbGl6ZXIgPSBjcmVhdGVHb29nQ2FsbCgncmVxdWlyZScsIGltcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5pdGlhbGl6ZXIgPSBpZGVudDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YXJEZWNsID0gdHMuY3JlYXRlVmFyaWFibGVEZWNsYXJhdGlvbihuZXdJZGVudCwgLyogdHlwZSAqLyB1bmRlZmluZWQsIGluaXRpYWxpemVyKTtcbiAgICAgICAgY29uc3QgbmV3U3RtdCA9IHRzLmNyZWF0ZVZhcmlhYmxlU3RhdGVtZW50KFxuICAgICAgICAgICAgLyogbW9kaWZpZXJzICovIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHRzLmNyZWF0ZVZhcmlhYmxlRGVjbGFyYXRpb25MaXN0KFxuICAgICAgICAgICAgICAgIFt2YXJEZWNsXSxcbiAgICAgICAgICAgICAgICAvLyBVc2UgJ2NvbnN0JyBpbiBFUzYgbW9kZSBzbyBDbG9zdXJlIHByb3Blcmx5IGZvcndhcmRzIHR5cGUgYWxpYXNlcy5cbiAgICAgICAgICAgICAgICBob3N0LmVzNU1vZGUgPyB1bmRlZmluZWQgOiB0cy5Ob2RlRmxhZ3MuQ29uc3QpKTtcbiAgICAgICAgcmV0dXJuIHRzLnNldE9yaWdpbmFsTm9kZSh0cy5zZXRUZXh0UmFuZ2UobmV3U3RtdCwgb3JpZ2luYWwpLCBvcmlnaW5hbCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogbWF5YmVSZXdyaXRlUmVxdWlyZVRzbGliIHJld3JpdGVzIGEgcmVxdWlyZSgndHNsaWInKSBjYWxscyB0byBnb29nLnJlcXVpcmUoJ3RzbGliJykuIEl0XG4gICAgICAgKiByZXR1cm5zIHRoZSBpbnB1dCBzdGF0ZW1lbnQgdW50b3VjaGVkIGlmIGl0IGRvZXMgbm90IG1hdGNoLlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBtYXliZVJld3JpdGVSZXF1aXJlVHNsaWIoc3RtdDogdHMuU3RhdGVtZW50KTogdHMuU3RhdGVtZW50IHtcbiAgICAgICAgaWYgKCF0cy5pc0V4cHJlc3Npb25TdGF0ZW1lbnQoc3RtdCkpIHJldHVybiBzdG10O1xuICAgICAgICBpZiAoIXRzLmlzQ2FsbEV4cHJlc3Npb24oc3RtdC5leHByZXNzaW9uKSkgcmV0dXJuIHN0bXQ7XG4gICAgICAgIGNvbnN0IGNhbGxFeHByID0gc3RtdC5leHByZXNzaW9uO1xuICAgICAgICBpZiAoIXRzLmlzSWRlbnRpZmllcihjYWxsRXhwci5leHByZXNzaW9uKSB8fCBjYWxsRXhwci5leHByZXNzaW9uLnRleHQgIT09ICdyZXF1aXJlJykge1xuICAgICAgICAgIHJldHVybiBzdG10O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYWxsRXhwci5hcmd1bWVudHMubGVuZ3RoICE9PSAxKSByZXR1cm4gc3RtdDtcbiAgICAgICAgY29uc3QgYXJnID0gY2FsbEV4cHIuYXJndW1lbnRzWzBdO1xuICAgICAgICBpZiAoIXRzLmlzU3RyaW5nTGl0ZXJhbChhcmcpIHx8IGFyZy50ZXh0ICE9PSAndHNsaWInKSByZXR1cm4gc3RtdDtcbiAgICAgICAgcmV0dXJuIHRzLnNldE9yaWdpbmFsTm9kZShcbiAgICAgICAgICAgIHRzLnNldFRleHRSYW5nZSh0cy5jcmVhdGVTdGF0ZW1lbnQoY3JlYXRlR29vZ0NhbGwoJ3JlcXVpcmUnLCBhcmcpKSwgc3RtdCksIHN0bXQpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIHZpc2l0VG9wTGV2ZWxTdGF0ZW1lbnQgaW1wbGVtZW50cyB0aGUgbWFpbiBDb21tb25KUyB0byBnb29nLm1vZHVsZSBjb252ZXJzaW9uLiBJdCB2aXNpdHMgYVxuICAgICAgICogU291cmNlRmlsZSBsZXZlbCBzdGF0ZW1lbnQgYW5kIGFkZHMgYSAocG9zc2libHkpIHRyYW5zZm9ybWVkIHJlcHJlc2VudGF0aW9uIG9mIGl0IGludG9cbiAgICAgICAqIHN0YXRlbWVudHMuIEl0IGFkZHMgYXQgbGVhc3Qgb25lIG5vZGUgcGVyIHN0YXRlbWVudCB0byBzdGF0ZW1lbnRzLlxuICAgICAgICpcbiAgICAgICAqIHZpc2l0VG9wTGV2ZWxTdGF0ZW1lbnQ6XG4gICAgICAgKiAtIGNvbnZlcnRzIHJlcXVpcmUoKSBjYWxscyB0byBnb29nLnJlcXVpcmUoKSBjYWxscywgd2l0aCBvciB3L28gdmFyIGFzc2lnbm1lbnRcbiAgICAgICAqIC0gcmVtb3ZlcyBcInVzZSBzdHJpY3RcIjsgYW5kIFwiT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fZXNNb2R1bGUpXCIgc3RhdGVtZW50c1xuICAgICAgICogLSBjb252ZXJ0cyBtb2R1bGUuZXhwb3J0cyBhc3NpZ25tZW50cyB0byBqdXN0IGV4cG9ydHMgYXNzaWdubWVudHNcbiAgICAgICAqIC0gc3BsaXRzIF9fZXhwb3J0U3RhcigpIGNhbGxzIGludG8gcmVxdWlyZSBhbmQgZXhwb3J0ICh0aGlzIG5lZWRzIHR3byBzdGF0ZW1lbnRzKVxuICAgICAgICogLSBtYWtlcyBzdXJlIHRvIG9ubHkgaW1wb3J0IGVhY2ggbmFtZXNwYWNlIGV4YWN0bHkgb25jZSwgYW5kIHVzZSB2YXJpYWJsZXMgbGF0ZXIgb25cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gdmlzaXRUb3BMZXZlbFN0YXRlbWVudChcbiAgICAgICAgICBzdGF0ZW1lbnRzOiB0cy5TdGF0ZW1lbnRbXSwgc2Y6IHRzLlNvdXJjZUZpbGUsIG5vZGU6IHRzLlN0YXRlbWVudCk6IHZvaWQge1xuICAgICAgICAvLyBIYW5kbGUgZWFjaCBwYXJ0aWN1bGFyIGNhc2UgYnkgYWRkaW5nIG5vZGUgdG8gc3RhdGVtZW50cywgdGhlbiByZXR1cm4uXG4gICAgICAgIC8vIEZvciB1bmhhbmRsZWQgY2FzZXMsIGJyZWFrIHRvIGp1bXAgdG8gdGhlIGRlZmF1bHQgaGFuZGxpbmcgYmVsb3cuXG4gICAgICAgIHN3aXRjaCAobm9kZS5raW5kKSB7XG4gICAgICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLkV4cHJlc3Npb25TdGF0ZW1lbnQ6IHtcbiAgICAgICAgICAgIGNvbnN0IGV4cHJTdG10ID0gbm9kZSBhcyB0cy5FeHByZXNzaW9uU3RhdGVtZW50O1xuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIFwidXNlIHN0cmljdFwiIGFuZCBjZXJ0YWluIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBhbmQgc2tpcCBpdCBpZiBuZWNlc3NhcnkuXG4gICAgICAgICAgICBpZiAoaXNVc2VTdHJpY3QoZXhwclN0bXQpIHx8IGlzRXNNb2R1bGVQcm9wZXJ0eShleHByU3RtdCkpIHtcbiAgICAgICAgICAgICAgc3RtdHMucHVzaChjcmVhdGVOb3RFbWl0dGVkU3RhdGVtZW50V2l0aENvbW1lbnRzKHNmLCBleHByU3RtdCkpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGVjayBmb3I6XG4gICAgICAgICAgICAvLyAgIG1vZHVsZS5leHBvcnRzID0gLi4uO1xuICAgICAgICAgICAgY29uc3QgbW9kRXhwb3J0cyA9IHJld3JpdGVNb2R1bGVFeHBvcnRzQXNzaWdubWVudChleHByU3RtdCk7XG4gICAgICAgICAgICBpZiAobW9kRXhwb3J0cykge1xuICAgICAgICAgICAgICBzdG10cy5wdXNoKG1vZEV4cG9ydHMpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGVjayBmb3I6XG4gICAgICAgICAgICAvLyAgIFwicmVxdWlyZSgnZm9vJyk7XCIgKGEgcmVxdWlyZSBmb3IgaXRzIHNpZGUgZWZmZWN0cylcbiAgICAgICAgICAgIGNvbnN0IGV4cHIgPSBleHByU3RtdC5leHByZXNzaW9uO1xuICAgICAgICAgICAgaWYgKCF0cy5pc0NhbGxFeHByZXNzaW9uKGV4cHIpKSBicmVhaztcbiAgICAgICAgICAgIGxldCBjYWxsRXhwciA9IGV4cHI7XG4gICAgICAgICAgICAvLyBIYW5kbGUgZXhwb3J0ICogaW4gRVM1IG1vZGUgKGluIEVTNiBtb2RlLCBleHBvcnQgKiBpcyBkZXJlZmVyZW5jZWQgYWxyZWFkeSkuXG4gICAgICAgICAgICAvLyBleHBvcnQgKiBjcmVhdGVzIGVpdGhlciBhIHB1cmUgdG9wLWxldmVsICdfX2V4cG9ydChyZXF1aXJlKC4uLikpJyBvciB0aGUgaW1wb3J0ZWRcbiAgICAgICAgICAgIC8vIHZlcnNpb24sICd0c2xpYi5fX2V4cG9ydFN0YXIocmVxdWlyZSguLi4pKScuIFRoZSBpbXBvcnRlZCB2ZXJzaW9uIGlzIG9ubHkgc3Vic3RpdHV0ZWRcbiAgICAgICAgICAgIC8vIGxhdGVyIG9uIHRob3VnaCwgc28gYXBwZWFycyBhcyBhIHBsYWluIFwiX19leHBvcnRTdGFyXCIgb24gdGhlIHRvcCBsZXZlbCBoZXJlLlxuICAgICAgICAgICAgY29uc3QgaXNFeHBvcnRTdGFyID1cbiAgICAgICAgICAgICAgICAodHMuaXNJZGVudGlmaWVyKGV4cHIuZXhwcmVzc2lvbikgJiYgZXhwci5leHByZXNzaW9uLnRleHQgPT09ICdfX2V4cG9ydFN0YXInKSB8fFxuICAgICAgICAgICAgICAgICh0cy5pc0lkZW50aWZpZXIoZXhwci5leHByZXNzaW9uKSAmJiBleHByLmV4cHJlc3Npb24udGV4dCA9PT0gJ19fZXhwb3J0Jyk7XG4gICAgICAgICAgICBpZiAoaXNFeHBvcnRTdGFyKSBjYWxsRXhwciA9IGV4cHIuYXJndW1lbnRzWzBdIGFzIHRzLkNhbGxFeHByZXNzaW9uO1xuICAgICAgICAgICAgY29uc3QgaWRlbnQgPSB0cy5jcmVhdGVJZGVudGlmaWVyKG5leHRNb2R1bGVWYXIoKSk7XG4gICAgICAgICAgICBjb25zdCByZXF1aXJlID0gbWF5YmVDcmVhdGVHb29nUmVxdWlyZShleHByU3RtdCwgY2FsbEV4cHIsIGlkZW50KTtcbiAgICAgICAgICAgIGlmICghcmVxdWlyZSkgYnJlYWs7XG4gICAgICAgICAgICBzdGF0ZW1lbnRzLnB1c2gocmVxdWlyZSk7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIGlzIGFuIGV4cG9ydCBzdGFyLCBzcGxpdCBpdCB1cCBpbnRvIHRoZSBpbXBvcnQgKGNyZWF0ZWQgYnkgdGhlIG1heWJlIGNhbGxcbiAgICAgICAgICAgIC8vIGFib3ZlKSwgYW5kIHRoZSBleHBvcnQgb3BlcmF0aW9uLiBUaGlzIGF2b2lkcyBhIENsb3N1cmUgY29tcGxhaW50IGFib3V0IG5vbi10b3AtbGV2ZWxcbiAgICAgICAgICAgIC8vIHJlcXVpcmVzLlxuICAgICAgICAgICAgaWYgKGlzRXhwb3J0U3Rhcikge1xuICAgICAgICAgICAgICBjb25zdCBhcmdzOiB0cy5FeHByZXNzaW9uW10gPSBbaWRlbnRdO1xuICAgICAgICAgICAgICBpZiAoZXhwci5hcmd1bWVudHMubGVuZ3RoID4gMSkgYXJncy5wdXNoKGV4cHIuYXJndW1lbnRzWzFdKTtcbiAgICAgICAgICAgICAgc3RhdGVtZW50cy5wdXNoKHRzLmNyZWF0ZVN0YXRlbWVudCh0cy5jcmVhdGVDYWxsKGV4cHIuZXhwcmVzc2lvbiwgdW5kZWZpbmVkLCBhcmdzKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuVmFyaWFibGVTdGF0ZW1lbnQ6IHtcbiAgICAgICAgICAgIC8vIEl0J3MgcG9zc2libHkgb2YgdGhlIGZvcm0gXCJ2YXIgeCA9IHJlcXVpcmUoLi4uKTtcIi5cbiAgICAgICAgICAgIGNvbnN0IHZhclN0bXQgPSBub2RlIGFzIHRzLlZhcmlhYmxlU3RhdGVtZW50O1xuICAgICAgICAgICAgLy8gVmVyaWZ5IGl0J3MgYSBzaW5nbGUgZGVjbCAoYW5kIG5vdCBcInZhciB4ID0gLi4uLCB5ID0gLi4uO1wiKS5cbiAgICAgICAgICAgIGlmICh2YXJTdG10LmRlY2xhcmF0aW9uTGlzdC5kZWNsYXJhdGlvbnMubGVuZ3RoICE9PSAxKSBicmVhaztcbiAgICAgICAgICAgIGNvbnN0IGRlY2wgPSB2YXJTdG10LmRlY2xhcmF0aW9uTGlzdC5kZWNsYXJhdGlvbnNbMF07XG5cbiAgICAgICAgICAgIC8vIEdyYWIgdGhlIHZhcmlhYmxlIG5hbWUgKGF2b2lkaW5nIHRoaW5ncyBsaWtlIGRlc3RydWN0dXJpbmcgYmluZHMpLlxuICAgICAgICAgICAgaWYgKGRlY2wubmFtZS5raW5kICE9PSB0cy5TeW50YXhLaW5kLklkZW50aWZpZXIpIGJyZWFrO1xuICAgICAgICAgICAgaWYgKCFkZWNsLmluaXRpYWxpemVyIHx8ICF0cy5pc0NhbGxFeHByZXNzaW9uKGRlY2wuaW5pdGlhbGl6ZXIpKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVxdWlyZSA9IG1heWJlQ3JlYXRlR29vZ1JlcXVpcmUodmFyU3RtdCwgZGVjbC5pbml0aWFsaXplciwgZGVjbC5uYW1lKTtcbiAgICAgICAgICAgIGlmICghcmVxdWlyZSkgYnJlYWs7XG4gICAgICAgICAgICBzdGF0ZW1lbnRzLnB1c2gocmVxdWlyZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZW1lbnRzLnB1c2gobm9kZSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG1vZHVsZU5hbWUgPSBob3N0LnBhdGhUb01vZHVsZU5hbWUoJycsIHNmLmZpbGVOYW1lKTtcbiAgICAgIC8vIFJlZ2lzdGVyIHRoZSBuYW1lc3BhY2UgdGhpcyBmaWxlIHByb3ZpZGVzLlxuICAgICAgbW9kdWxlc01hbmlmZXN0LmFkZE1vZHVsZShzZi5maWxlTmFtZSwgbW9kdWxlTmFtZSk7XG5cbiAgICAgIC8vIEluIEpTIHRyYW5zcGlsYXRpb24gbW9kZSwga2VlcCBhbGwgQ29tbW9uSlMgY29kZSwgYW5kIG9ubHkgcmV3cml0ZSBgcmVxdWlyZSgndHNsaWInKWAgdG9cbiAgICAgIC8vIGEgZ29vZy5yZXF1aXJlKCkuXG4gICAgICBpZiAoaG9zdC5pc0pzVHJhbnNwaWxhdGlvbikge1xuICAgICAgICBjb25zdCBzdG10czogdHMuU3RhdGVtZW50W10gPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBzdG10IG9mIHNmLnN0YXRlbWVudHMpIHtcbiAgICAgICAgICBzdG10cy5wdXNoKG1heWJlUmV3cml0ZVJlcXVpcmVUc2xpYihzdG10KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRzLnVwZGF0ZVNvdXJjZUZpbGVOb2RlKHNmLCBzdG10cyk7XG4gICAgICB9XG5cbiAgICAgIC8vIENvbnZlcnQgZWFjaCB0b3AgbGV2ZWwgc3RhdGVtZW50IHRvIGdvb2cubW9kdWxlLlxuICAgICAgY29uc3Qgc3RtdHM6IHRzLlN0YXRlbWVudFtdID0gW107XG4gICAgICBmb3IgKGNvbnN0IHN0bXQgb2Ygc2Yuc3RhdGVtZW50cykge1xuICAgICAgICB2aXNpdFRvcExldmVsU3RhdGVtZW50KHN0bXRzLCBzZiwgc3RtdCk7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZGl0aW9uYWwgc3RhdGVtZW50cyB0aGF0IHdpbGwgYmUgcHJlcGVuZGVkIChnb29nLm1vZHVsZSBjYWxsIGV0YykuXG4gICAgICBjb25zdCBoZWFkZXJTdG10czogdHMuU3RhdGVtZW50W10gPSBbXTtcblxuICAgICAgLy8gRW1pdDogZ29vZy5tb2R1bGUoJ21vZHVsZU5hbWUnKTtcbiAgICAgIGNvbnN0IGdvb2dNb2R1bGUgPVxuICAgICAgICAgIHRzLmNyZWF0ZVN0YXRlbWVudChjcmVhdGVHb29nQ2FsbCgnbW9kdWxlJywgY3JlYXRlU2luZ2xlUXVvdGVTdHJpbmdMaXRlcmFsKG1vZHVsZU5hbWUpKSk7XG4gICAgICBoZWFkZXJTdG10cy5wdXNoKGdvb2dNb2R1bGUpO1xuXG4gICAgICAvLyBBbGxvdyBjb2RlIHRvIHVzZSBgbW9kdWxlLmlkYCB0byBkaXNjb3ZlciBpdHMgbW9kdWxlIFVSTCwgZS5nLiB0byByZXNvbHZlIGEgdGVtcGxhdGUgVVJMXG4gICAgICAvLyBhZ2FpbnN0LiBVc2VzICd2YXInLCBhcyB0aGlzIGNvZGUgaXMgaW5zZXJ0ZWQgaW4gRVM2IGFuZCBFUzUgbW9kZXMuIFRoZSBmb2xsb3dpbmcgcGF0dGVyblxuICAgICAgLy8gZW5zdXJlcyBjbG9zdXJlIGRvZXNuJ3QgdGhyb3cgYW4gZXJyb3IgaW4gYWR2YW5jZWQgb3B0aW1pemF0aW9ucyBtb2RlLlxuICAgICAgLy8gdmFyIG1vZHVsZSA9IG1vZHVsZSB8fCB7aWQ6ICdwYXRoL3RvL21vZHVsZS50cyd9O1xuICAgICAgY29uc3QgbW9kdWxlSWQgPSBob3N0LmZpbGVOYW1lVG9Nb2R1bGVJZChzZi5maWxlTmFtZSk7XG4gICAgICBjb25zdCBtb2R1bGVWYXJJbml0aWFsaXplciA9IHRzLmNyZWF0ZUJpbmFyeShcbiAgICAgICAgICB0cy5jcmVhdGVJZGVudGlmaWVyKCdtb2R1bGUnKSwgdHMuU3ludGF4S2luZC5CYXJCYXJUb2tlbixcbiAgICAgICAgICB0cy5jcmVhdGVPYmplY3RMaXRlcmFsKFxuICAgICAgICAgICAgICBbdHMuY3JlYXRlUHJvcGVydHlBc3NpZ25tZW50KCdpZCcsIGNyZWF0ZVNpbmdsZVF1b3RlU3RyaW5nTGl0ZXJhbChtb2R1bGVJZCkpXSkpO1xuICAgICAgY29uc3QgbW9kQXNzaWduID0gdHMuY3JlYXRlVmFyaWFibGVTdGF0ZW1lbnQoXG4gICAgICAgICAgLyogbW9kaWZpZXJzICovIHVuZGVmaW5lZCwgdHMuY3JlYXRlVmFyaWFibGVEZWNsYXJhdGlvbkxpc3QoW3RzLmNyZWF0ZVZhcmlhYmxlRGVjbGFyYXRpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdtb2R1bGUnLCAvKiB0eXBlICovIHVuZGVmaW5lZCwgbW9kdWxlVmFySW5pdGlhbGl6ZXIpXSkpO1xuICAgICAgaGVhZGVyU3RtdHMucHVzaChtb2RBc3NpZ24pO1xuXG4gICAgICBpZiAoIWhvc3QuZXM1TW9kZSkge1xuICAgICAgICAvLyBUaGUgbW9kdWxlPW1vZHVsZSBhc3NpZ25tZW50IHN1cHByZXNzZXMgYW4gdW51c2VkIHZhcmlhYmxlIHdhcm5pbmcgd2hpY2ggbWF5IHRyaWdnZXJcbiAgICAgICAgLy8gZGVwZW5kaW5nIG9uIHRoZSBwcm9qZWN0J3MgY29tcGlsYXRpb24gZmxhZ3MuXG4gICAgICAgIGhlYWRlclN0bXRzLnB1c2godHMuY3JlYXRlU3RhdGVtZW50KFxuICAgICAgICAgICAgdHMuY3JlYXRlQXNzaWdubWVudCh0cy5jcmVhdGVJZGVudGlmaWVyKCdtb2R1bGUnKSwgdHMuY3JlYXRlSWRlbnRpZmllcignbW9kdWxlJykpKSk7XG5cbiAgICAgICAgLy8gVGhlIGBleHBvcnRzID0ge31gIHNlcnZlcyBhcyBhIGRlZmF1bHQgZXhwb3J0IHRvIGRpc2FibGUgQ2xvc3VyZSBDb21waWxlcidzIGVycm9yXG4gICAgICAgIC8vIGNoZWNraW5nXG4gICAgICAgIC8vIGZvciBtdXRhYmxlIGV4cG9ydHMuIFRoYXQncyBPSyBiZWNhdXNlIFRTIGNvbXBpbGVyIG1ha2VzIHN1cmUgdGhhdCBjb25zdW1pbmcgY29kZSBhbHdheXNcbiAgICAgICAgLy8gYWNjZXNzZXMgZXhwb3J0cyB0aHJvdWdoIHRoZSBtb2R1bGUgb2JqZWN0LCBzbyBtdXRhYmxlIGV4cG9ydHMgd29yay5cbiAgICAgICAgLy8gSXQgaXMgb25seSBpbnNlcnRlZCBpbiBFUzYgYmVjYXVzZSB3ZSBzdHJpcCBgLmRlZmF1bHRgIGFjY2Vzc2VzIGluIEVTNSBtb2RlLCB3aGljaCBicmVha3NcbiAgICAgICAgLy8gd2hlbiBhc3NpZ25pbmcgYW4gYGV4cG9ydHMgPSB7fWAgb2JqZWN0IGFuZCB0aGVuIGxhdGVyIGFjY2Vzc2luZyBpdC5cbiAgICAgICAgLy8gSG93ZXZlciBDbG9zdXJlIGJhaWxzIGlmIGNvZGUgbGF0ZXIgb24gYXNzaWducyBpbnRvIGV4cG9ydHMgZGlyZWN0bHksIGFzIHdlIGRvIGlmIHdlIGhhdmVcbiAgICAgICAgLy8gYW4gXCJleHBvcnRzID0gXCIgYmxvY2ssIHNvIHNraXAgZW1pdCBpZiB0aGF0J3MgdGhlIGNhc2UuXG4gICAgICAgIGlmICghc2Yuc3RhdGVtZW50cy5maW5kKFxuICAgICAgICAgICAgICAgIHMgPT4gdHMuaXNFeHByZXNzaW9uU3RhdGVtZW50KHMpICYmXG4gICAgICAgICAgICAgICAgICAgIChpc01vZHVsZUV4cG9ydHNBc3NpZ25tZW50KHMpIHx8IGlzRXhwb3J0c0Fzc2lnbm1lbnQocykpKSkge1xuICAgICAgICAgIGhlYWRlclN0bXRzLnB1c2godHMuY3JlYXRlU3RhdGVtZW50KFxuICAgICAgICAgICAgICB0cy5jcmVhdGVBc3NpZ25tZW50KHRzLmNyZWF0ZUlkZW50aWZpZXIoJ2V4cG9ydHMnKSwgdHMuY3JlYXRlT2JqZWN0TGl0ZXJhbCgpKSkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEluc2VydCBnb29nLm1vZHVsZSgpIGV0YyBhZnRlciBhbnkgbGVhZGluZyBjb21tZW50cyBpbiB0aGUgc291cmNlIGZpbGUuIFRoZSBjb21tZW50cyBoYXZlXG4gICAgICAvLyBiZWVuIGNvbnZlcnRlZCB0byBOb3RFbWl0dGVkU3RhdGVtZW50cyBieSB0cmFuc2Zvcm1lcl91dGlsLCB3aGljaCB0aGlzIGRlcGVuZHMgb24uXG4gICAgICBjb25zdCBpbnNlcnRpb25JZHggPSBzdG10cy5maW5kSW5kZXgocyA9PiBzLmtpbmQgIT09IHRzLlN5bnRheEtpbmQuTm90RW1pdHRlZFN0YXRlbWVudCk7XG4gICAgICBpZiAoaW5zZXJ0aW9uSWR4ID09PSAtMSkge1xuICAgICAgICBzdG10cy5wdXNoKC4uLmhlYWRlclN0bXRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0bXRzLnNwbGljZShpbnNlcnRpb25JZHgsIDAsIC4uLmhlYWRlclN0bXRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRzLnVwZGF0ZVNvdXJjZUZpbGVOb2RlKHNmLCB0cy5zZXRUZXh0UmFuZ2UodHMuY3JlYXRlTm9kZUFycmF5KHN0bXRzKSwgc2Yuc3RhdGVtZW50cykpO1xuICAgIH07XG4gIH07XG59XG4iXX0=