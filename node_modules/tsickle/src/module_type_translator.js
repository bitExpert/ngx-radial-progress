/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("tsickle/src/module_type_translator", ["require", "exports", "typescript", "tsickle/src/googmodule", "tsickle/src/jsdoc", "tsickle/src/transformer_util", "tsickle/src/type_translator"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @fileoverview module_type_translator builds on top of type_translator, adding functionality to
     * translate types within the scope of a single module. The main entry point is
     * ModuleTypeTranslator.
     */
    var ts = require("typescript");
    var googmodule = require("tsickle/src/googmodule");
    var jsdoc = require("tsickle/src/jsdoc");
    var transformer_util_1 = require("tsickle/src/transformer_util");
    var typeTranslator = require("tsickle/src/type_translator");
    /**
     * MutableJSDoc encapsulates a (potential) JSDoc comment on a specific node, and allows code to
     * modify (including delete) it.
     */
    var MutableJSDoc = /** @class */ (function () {
        function MutableJSDoc(node, sourceComment, tags) {
            this.node = node;
            this.sourceComment = sourceComment;
            this.tags = tags;
        }
        MutableJSDoc.prototype.updateComment = function (escapeExtraTags) {
            var text = jsdoc.toStringWithoutStartEnd(this.tags, escapeExtraTags);
            if (this.sourceComment) {
                if (!text) {
                    // Delete the (now empty) comment.
                    var comments_1 = ts.getSyntheticLeadingComments(this.node);
                    var idx = comments_1.indexOf(this.sourceComment);
                    comments_1.splice(idx, 1);
                    this.sourceComment = null;
                    return;
                }
                this.sourceComment.text = text;
                return;
            }
            // Don't add an empty comment.
            if (!text)
                return;
            var comment = {
                kind: ts.SyntaxKind.MultiLineCommentTrivia,
                text: text,
                hasTrailingNewLine: true,
                pos: -1,
                end: -1,
            };
            var comments = ts.getSyntheticLeadingComments(this.node) || [];
            comments.push(comment);
            ts.setSyntheticLeadingComments(this.node, comments);
        };
        return MutableJSDoc;
    }());
    exports.MutableJSDoc = MutableJSDoc;
    /** Returns the Closure name of a function parameter, special-casing destructuring. */
    function getParameterName(param, index) {
        switch (param.name.kind) {
            case ts.SyntaxKind.Identifier:
                var name_1 = transformer_util_1.getIdentifierText(param.name);
                // TypeScript allows parameters named "arguments", but Closure
                // disallows this, even in externs.
                if (name_1 === 'arguments')
                    name_1 = 'tsickle_arguments';
                return name_1;
            case ts.SyntaxKind.ArrayBindingPattern:
            case ts.SyntaxKind.ObjectBindingPattern:
                // Closure crashes if you put a binding pattern in the externs.
                // Avoid this by just generating an unused name; the name is
                // ignored anyway.
                return "__" + index;
            default:
                // The above list of kinds is exhaustive.  param.name is 'never' at this point.
                var paramName = param.name;
                throw new Error("unhandled function parameter kind: " + ts.SyntaxKind[paramName.kind]);
        }
    }
    /**
     * ModuleTypeTranslator encapsulates knowledge and helper functions to translate types in the scope
     * of a specific module. This includes managing Closure forward declare statements and any symbol
     * aliases in scope for a whole file.
     */
    var ModuleTypeTranslator = /** @class */ (function () {
        function ModuleTypeTranslator(sourceFile, typeChecker, host, diagnostics, isForExterns) {
            this.sourceFile = sourceFile;
            this.typeChecker = typeChecker;
            this.host = host;
            this.diagnostics = diagnostics;
            this.isForExterns = isForExterns;
            /**
             * A mapping of aliases for symbols in the current file, used when emitting types. TypeScript
             * emits imported symbols with unpredictable prefixes. To generate correct type annotations,
             * tsickle creates its own aliases for types, and registers them in this map (see
             * `emitImportDeclaration` and `forwardDeclare()` below). The aliases are then used when emitting
             * types.
             */
            this.symbolsToAliasedNames = new Map();
            /**
             * The set of module symbols forward declared in the local namespace (with goog.forwarDeclare).
             *
             * Symbols not imported must be declared, which is done by adding forward declares to
             * `extraImports` below.
             */
            this.forwardDeclaredModules = new Set();
            /**
             * The list of generated goog.forwardDeclare statements for this module. These are inserted into
             * the module's body statements after translation.
             */
            this.forwardDeclares = [];
            /** A counter to generate unique names for goog.forwardDeclare variables. */
            this.forwardDeclareCounter = 0;
        }
        ModuleTypeTranslator.prototype.debugWarn = function (context, messageText) {
            transformer_util_1.reportDebugWarning(this.host, context, messageText);
        };
        ModuleTypeTranslator.prototype.error = function (node, messageText) {
            transformer_util_1.reportDiagnostic(this.diagnostics, node, messageText);
        };
        /**
         * Convert a TypeScript ts.Type into the equivalent Closure type.
         *
         * @param context The ts.Node containing the type reference; used for resolving symbols
         *     in context.
         * @param type The type to translate; if not provided, the Node's type will be used.
         * @param resolveAlias If true, do not emit aliases as their symbol, but rather as the resolved
         *     type underlying the alias. This should be true only when emitting the typedef itself.
         */
        ModuleTypeTranslator.prototype.typeToClosure = function (context, type) {
            if (this.host.untyped) {
                return '?';
            }
            var typeChecker = this.typeChecker;
            if (!type) {
                type = typeChecker.getTypeAtLocation(context);
            }
            return this.newTypeTranslator(context).translate(type);
        };
        ModuleTypeTranslator.prototype.newTypeTranslator = function (context) {
            var _this = this;
            // In externs, there is no local scope, so all types must be relative to the file level scope.
            var translationContext = this.isForExterns ? this.sourceFile : context;
            var translator = new typeTranslator.TypeTranslator(this.host, this.typeChecker, translationContext, this.host.typeBlackListPaths, this.symbolsToAliasedNames, function (sym) { return _this.ensureSymbolDeclared(sym); });
            translator.isForExterns = this.isForExterns;
            translator.warn = function (msg) { return _this.debugWarn(context, msg); };
            return translator;
        };
        ModuleTypeTranslator.prototype.isBlackListed = function (context) {
            var type = this.typeChecker.getTypeAtLocation(context);
            var sym = type.symbol;
            if (!sym)
                return false;
            if (sym.flags & ts.SymbolFlags.Alias) {
                sym = this.typeChecker.getAliasedSymbol(sym);
            }
            return this.newTypeTranslator(context).isBlackListed(sym);
        };
        /**
         * Get the ts.Symbol at a location or throw.
         * The TypeScript API can return undefined when fetching a symbol, but in many contexts we know it
         * won't (e.g. our input is already type-checked).
         */
        ModuleTypeTranslator.prototype.mustGetSymbolAtLocation = function (node) {
            var sym = this.typeChecker.getSymbolAtLocation(node);
            if (!sym)
                throw new Error('no symbol');
            return sym;
        };
        /** Finds an exported (i.e. not global) declaration for the given symbol. */
        ModuleTypeTranslator.prototype.findExportedDeclaration = function (sym) {
            var _this = this;
            // TODO(martinprobst): it's unclear when a symbol wouldn't have a declaration, maybe just for
            // some builtins (e.g. Symbol)?
            if (!sym.declarations || sym.declarations.length === 0)
                return undefined;
            // A symbol declared in this file does not need to be imported.
            if (sym.declarations.some(function (d) { return d.getSourceFile() === _this.sourceFile; }))
                return undefined;
            // Find an exported declaration.
            // Because tsickle runs with the --declaration flag, all types referenced from exported types
            // must be exported, too, so there must either be some declaration that is exported, or the
            // symbol is actually a global declaration (declared in a script file, not a module).
            var decl = sym.declarations.find(function (d) {
                // Check for Export | Default (default being a default export).
                if (!transformer_util_1.hasModifierFlag(d, ts.ModifierFlags.ExportDefault))
                    return false;
                // Exclude symbols declared in `declare global {...}` blocks, they are global and don't need
                // imports.
                var current = d;
                while (current) {
                    if (current.flags & ts.NodeFlags.GlobalAugmentation)
                        return false;
                    current = current.parent;
                }
                return true;
            });
            return decl;
        };
        /**
         * Returns the `const x = goog.forwardDeclare...` text for an import of the given `importPath`.
         * This also registers aliases for symbols from the module that map to this forward declare.
         */
        ModuleTypeTranslator.prototype.forwardDeclare = function (importPath, moduleSymbol, isExplicitImport, isDefaultImport) {
            var _this = this;
            if (isDefaultImport === void 0) { isDefaultImport = false; }
            var e_1, _a;
            if (this.host.untyped)
                return;
            // Already imported? Do not emit a duplicate forward declare.
            if (this.forwardDeclaredModules.has(moduleSymbol))
                return;
            if (this.host.typeBlackListPaths && this.host.typeBlackListPaths.has(importPath)) {
                return; // Do not emit goog.forwardDeclare or goog.require for blacklisted paths.
            }
            var nsImport = googmodule.extractGoogNamespaceImport(importPath);
            var forwardDeclarePrefix = "tsickle_forward_declare_" + ++this.forwardDeclareCounter;
            var moduleNamespace = nsImport !== null ?
                nsImport :
                this.host.pathToModuleName(this.sourceFile.fileName, importPath);
            // In TypeScript, importing a module for use in a type annotation does not cause a runtime load.
            // In Closure Compiler, goog.require'ing a module causes a runtime load, so emitting requires
            // here would cause a change in load order, which is observable (and can lead to errors).
            // Instead, goog.forwardDeclare types, which allows using them in type annotations without
            // causing a load. See below for the exception to the rule.
            // const forwardDeclarePrefix = goog.forwardDeclare(moduleNamespace)
            this.forwardDeclares.push(ts.createVariableStatement(undefined, ts.createVariableDeclarationList([ts.createVariableDeclaration(forwardDeclarePrefix, undefined, ts.createCall(ts.createPropertyAccess(ts.createIdentifier('goog'), 'forwardDeclare'), undefined, [ts.createLiteral(moduleNamespace)]))], ts.NodeFlags.Const)));
            this.forwardDeclaredModules.add(moduleSymbol);
            var exports = this.typeChecker.getExportsOfModule(moduleSymbol).map(function (e) {
                if (e.flags & ts.SymbolFlags.Alias) {
                    e = _this.typeChecker.getAliasedSymbol(e);
                }
                return e;
            });
            var hasValues = exports.some(function (e) {
                var isValue = (e.flags & ts.SymbolFlags.Value) !== 0;
                var isConstEnum = (e.flags & ts.SymbolFlags.ConstEnum) !== 0;
                // const enums are inlined by TypeScript (if preserveConstEnums=false), so there is never a
                // value import generated for them. That means for the purpose of force-importing modules,
                // they do not count as values. If preserveConstEnums=true, this shouldn't hurt.
                return isValue && !isConstEnum;
            });
            if (isExplicitImport && !hasValues) {
                // Closure Compiler's toolchain will drop files that are never goog.require'd *before* type
                // checking (e.g. when using --closure_entry_point or similar tools). This causes errors
                // complaining about values not matching 'NoResolvedType', or modules not having a certain
                // member.
                // To fix, explicitly goog.require() modules that only export types. This should usually not
                // cause breakages due to load order (as no symbols are accessible from the module - though
                // contrived code could observe changes in side effects).
                // This is a heuristic - if the module exports some values, but those are never imported,
                // the file will still end up not being imported. Hopefully modules that export values are
                // imported for their value in some place.
                // goog.require("${moduleNamespace}");
                var hardRequire = ts.createStatement(ts.createCall(ts.createPropertyAccess(ts.createIdentifier('goog'), 'require'), undefined, [transformer_util_1.createSingleQuoteStringLiteral(moduleNamespace)]));
                var comment = {
                    kind: ts.SyntaxKind.SingleLineCommentTrivia,
                    text: ' force type-only module to be loaded',
                    hasTrailingNewLine: true,
                    pos: -1,
                    end: -1,
                };
                ts.setSyntheticTrailingComments(hardRequire, [comment]);
                this.forwardDeclares.push(hardRequire);
            }
            try {
                for (var exports_1 = __values(exports), exports_1_1 = exports_1.next(); !exports_1_1.done; exports_1_1 = exports_1.next()) {
                    var sym = exports_1_1.value;
                    // goog: imports don't actually use the .default property that TS thinks they have.
                    var qualifiedName = nsImport && isDefaultImport ? forwardDeclarePrefix :
                        forwardDeclarePrefix + '.' + sym.name;
                    this.symbolsToAliasedNames.set(sym, qualifiedName);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (exports_1_1 && !exports_1_1.done && (_a = exports_1.return)) _a.call(exports_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        };
        ModuleTypeTranslator.prototype.ensureSymbolDeclared = function (sym) {
            var decl = this.findExportedDeclaration(sym);
            if (!decl)
                return;
            if (this.isForExterns) {
                this.error(decl, "declaration from module used in ambient type: " + sym.name);
                return;
            }
            // Actually import the symbol.
            var sourceFile = decl.getSourceFile();
            if (sourceFile === ts.getOriginalNode(this.sourceFile))
                return;
            var moduleSymbol = this.typeChecker.getSymbolAtLocation(sourceFile);
            // A source file might not have a symbol if it's not a module (no ES6 im/exports).
            if (!moduleSymbol)
                return;
            // TODO(martinprobst): this should possibly use fileNameToModuleId.
            this.forwardDeclare(sourceFile.fileName, moduleSymbol, false);
        };
        ModuleTypeTranslator.prototype.insertForwardDeclares = function (sourceFile) {
            var insertion = 0;
            // Skip over a leading file comment holder.
            if (sourceFile.statements.length &&
                sourceFile.statements[0].kind === ts.SyntaxKind.NotEmittedStatement) {
                insertion++;
            }
            return ts.updateSourceFileNode(sourceFile, __spread(sourceFile.statements.slice(0, insertion), this.forwardDeclares, sourceFile.statements.slice(insertion)));
        };
        /**
         * Parses and synthesizes comments on node, and returns the JSDoc from it, if any.
         * @param reportWarnings if true, will report warnings from parsing the JSDoc. Set to false if
         *     this is not the "main" location dealing with a node to avoid duplicated warnings.
         */
        ModuleTypeTranslator.prototype.getJSDoc = function (node, reportWarnings) {
            var _a = __read(this.parseJSDoc(node, reportWarnings), 1), tags = _a[0];
            return tags;
        };
        ModuleTypeTranslator.prototype.getMutableJSDoc = function (node) {
            var _a = __read(this.parseJSDoc(node, /* reportWarnings */ true), 2), tags = _a[0], comment = _a[1];
            return new MutableJSDoc(node, comment, tags);
        };
        ModuleTypeTranslator.prototype.parseJSDoc = function (node, reportWarnings) {
            // synthesizeLeadingComments below changes text locations for node, so extract the location here
            // in case it is needed later to report diagnostics.
            var start = node.getFullStart();
            var length = node.getLeadingTriviaWidth(this.sourceFile);
            var comments = jsdoc.synthesizeLeadingComments(node);
            if (!comments || comments.length === 0)
                return [[], null];
            for (var i = comments.length - 1; i >= 0; i--) {
                var comment = comments[i];
                var parsed = jsdoc.parse(comment);
                if (parsed) {
                    if (reportWarnings && parsed.warnings) {
                        var range = comment.originalRange || { pos: start, end: start + length };
                        transformer_util_1.reportDiagnostic(this.diagnostics, node, parsed.warnings.join('\n'), range, ts.DiagnosticCategory.Warning);
                    }
                    return [parsed.tags, comment];
                }
            }
            return [[], null];
        };
        ModuleTypeTranslator.prototype.blacklistTypeParameters = function (context, decls) {
            this.newTypeTranslator(context).blacklistTypeParameters(this.symbolsToAliasedNames, decls);
        };
        /**
         * Creates the jsdoc for methods, including overloads.
         * If overloaded, merges the signatures in the list of SignatureDeclarations into a single jsdoc.
         * - Total number of parameters will be the maximum count found across all variants.
         * - Different names at the same parameter index will be joined with "_or_"
         * - Variable args (...type[] in TypeScript) will be output as "...type",
         *    except if found at the same index as another argument.
         * @param fnDecls Pass > 1 declaration for overloads of same name
         * @return The list of parameter names that should be used to emit the actual
         *    function statement; for overloads, name will have been merged.
         */
        ModuleTypeTranslator.prototype.getFunctionTypeJSDoc = function (fnDecls, extraTags) {
            if (extraTags === void 0) { extraTags = []; }
            var e_2, _a, e_3, _b, e_4, _c, e_5, _d, e_6, _e, e_7, _f;
            var typeChecker = this.typeChecker;
            // De-duplicate tags and docs found for the fnDecls.
            var tagsByName = new Map();
            function addTag(tag) {
                var existing = tagsByName.get(tag.tagName);
                tagsByName.set(tag.tagName, existing ? jsdoc.merge([existing, tag]) : tag);
            }
            try {
                for (var extraTags_1 = __values(extraTags), extraTags_1_1 = extraTags_1.next(); !extraTags_1_1.done; extraTags_1_1 = extraTags_1.next()) {
                    var extraTag = extraTags_1_1.value;
                    addTag(extraTag);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (extraTags_1_1 && !extraTags_1_1.done && (_a = extraTags_1.return)) _a.call(extraTags_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
            var lens = fnDecls.map(function (fnDecl) { return fnDecl.parameters.length; });
            var minArgsCount = Math.min.apply(Math, __spread(lens));
            var maxArgsCount = Math.max.apply(Math, __spread(lens));
            var isConstructor = fnDecls.find(function (d) { return d.kind === ts.SyntaxKind.Constructor; }) !== undefined;
            // For each parameter index i, paramTags[i] is an array of parameters
            // that can be found at index i.  E.g.
            //    function foo(x: string)
            //    function foo(y: number, z: string)
            // then paramTags[0] = [info about x, info about y].
            var paramTags = [];
            var returnTags = [];
            var typeParameterNames = new Set();
            var thisReturnType = null;
            try {
                for (var fnDecls_1 = __values(fnDecls), fnDecls_1_1 = fnDecls_1.next(); !fnDecls_1_1.done; fnDecls_1_1 = fnDecls_1.next()) {
                    var fnDecl = fnDecls_1_1.value;
                    // Construct the JSDoc comment by reading the existing JSDoc, if
                    // any, and merging it with the known types of the function
                    // parameters and return type.
                    var tags = this.getJSDoc(fnDecl, /* reportWarnings */ false);
                    try {
                        // Copy all the tags other than @param/@return into the new
                        // JSDoc without any change; @param/@return are handled specially.
                        // TODO: there may be problems if an annotation doesn't apply to all overloads;
                        // is it worth checking for this and erroring?
                        for (var tags_1 = __values(tags), tags_1_1 = tags_1.next(); !tags_1_1.done; tags_1_1 = tags_1.next()) {
                            var tag = tags_1_1.value;
                            if (tag.tagName === 'param' || tag.tagName === 'return')
                                continue;
                            addTag(tag);
                        }
                    }
                    catch (e_4_1) { e_4 = { error: e_4_1 }; }
                    finally {
                        try {
                            if (tags_1_1 && !tags_1_1.done && (_c = tags_1.return)) _c.call(tags_1);
                        }
                        finally { if (e_4) throw e_4.error; }
                    }
                    var flags = ts.getCombinedModifierFlags(fnDecl);
                    // Add @abstract on "abstract" declarations.
                    if (flags & ts.ModifierFlags.Abstract) {
                        addTag({ tagName: 'abstract' });
                    }
                    // Add @protected/@private if present.
                    if (flags & ts.ModifierFlags.Protected) {
                        addTag({ tagName: 'protected' });
                    }
                    else if (flags & ts.ModifierFlags.Private) {
                        addTag({ tagName: 'private' });
                    }
                    // Add any @template tags.
                    // Multiple declarations with the same template variable names should work:
                    // the declarations get turned into union types, and Closure Compiler will need
                    // to find a union where all type arguments are satisfied.
                    if (fnDecl.typeParameters) {
                        try {
                            for (var _g = __values(fnDecl.typeParameters), _h = _g.next(); !_h.done; _h = _g.next()) {
                                var tp = _h.value;
                                typeParameterNames.add(transformer_util_1.getIdentifierText(tp.name));
                            }
                        }
                        catch (e_5_1) { e_5 = { error: e_5_1 }; }
                        finally {
                            try {
                                if (_h && !_h.done && (_d = _g.return)) _d.call(_g);
                            }
                            finally { if (e_5) throw e_5.error; }
                        }
                    }
                    // Merge the parameters into a single list of merged names and list of types
                    var sig = typeChecker.getSignatureFromDeclaration(fnDecl);
                    if (!sig || !sig.declaration)
                        throw new Error("invalid signature " + fnDecl.name);
                    if (sig.declaration.kind === ts.SyntaxKind.JSDocSignature) {
                        throw new Error("JSDoc signature " + fnDecl.name);
                    }
                    for (var i = 0; i < sig.declaration.parameters.length; i++) {
                        var paramNode = sig.declaration.parameters[i];
                        var name_2 = getParameterName(paramNode, i);
                        var isThisParam = name_2 === 'this';
                        var newTag = {
                            tagName: isThisParam ? 'this' : 'param',
                            optional: paramNode.initializer !== undefined || paramNode.questionToken !== undefined,
                            parameterName: isThisParam ? undefined : name_2,
                        };
                        var type = typeChecker.getTypeAtLocation(paramNode);
                        if (paramNode.dotDotDotToken !== undefined) {
                            newTag.restParam = true;
                            // In TypeScript you write "...x: number[]", but in Closure
                            // you don't write the array: "@param {...number} x".  Unwrap
                            // the Array<> wrapper.
                            var typeRef = type;
                            if (!typeRef.typeArguments)
                                throw new Error('invalid rest param');
                            type = typeRef.typeArguments[0];
                        }
                        newTag.type = this.typeToClosure(fnDecl, type);
                        try {
                            for (var tags_2 = __values(tags), tags_2_1 = tags_2.next(); !tags_2_1.done; tags_2_1 = tags_2.next()) {
                                var _j = tags_2_1.value, tagName = _j.tagName, parameterName = _j.parameterName, text = _j.text;
                                if (tagName === 'param' && parameterName === newTag.parameterName) {
                                    newTag.text = text;
                                    break;
                                }
                            }
                        }
                        catch (e_6_1) { e_6 = { error: e_6_1 }; }
                        finally {
                            try {
                                if (tags_2_1 && !tags_2_1.done && (_e = tags_2.return)) _e.call(tags_2);
                            }
                            finally { if (e_6) throw e_6.error; }
                        }
                        if (!paramTags[i])
                            paramTags.push([]);
                        paramTags[i].push(newTag);
                    }
                    // Return type.
                    if (!isConstructor) {
                        var returnTag = {
                            tagName: 'return',
                        };
                        var retType = typeChecker.getReturnTypeOfSignature(sig);
                        // tslint:disable-next-line:no-any accessing TS internal field.
                        if (retType.isThisType) {
                            // foo(): this
                            thisReturnType = retType;
                            addTag({ tagName: 'template', text: 'THIS' });
                            addTag({ tagName: 'this', type: 'THIS' });
                            returnTag.type = 'THIS';
                        }
                        else {
                            returnTag.type = this.typeToClosure(fnDecl, retType);
                            try {
                                for (var tags_3 = __values(tags), tags_3_1 = tags_3.next(); !tags_3_1.done; tags_3_1 = tags_3.next()) {
                                    var _k = tags_3_1.value, tagName = _k.tagName, text = _k.text;
                                    if (tagName === 'return') {
                                        returnTag.text = text;
                                        break;
                                    }
                                }
                            }
                            catch (e_7_1) { e_7 = { error: e_7_1 }; }
                            finally {
                                try {
                                    if (tags_3_1 && !tags_3_1.done && (_f = tags_3.return)) _f.call(tags_3);
                                }
                                finally { if (e_7) throw e_7.error; }
                            }
                        }
                        returnTags.push(returnTag);
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (fnDecls_1_1 && !fnDecls_1_1.done && (_b = fnDecls_1.return)) _b.call(fnDecls_1);
                }
                finally { if (e_3) throw e_3.error; }
            }
            if (typeParameterNames.size > 0) {
                addTag({ tagName: 'template', text: Array.from(typeParameterNames.values()).join(', ') });
            }
            var newDoc = Array.from(tagsByName.values());
            // Merge the JSDoc tags for each overloaded parameter.
            // Ensure each parameter has a unique name; the merging process can otherwise
            // accidentally generate the same parameter name twice.
            var paramNames = new Set();
            var foundOptional = false;
            for (var i = 0; i < maxArgsCount; i++) {
                var paramTag = jsdoc.merge(paramTags[i]);
                if (paramNames.has(paramTag.parameterName)) {
                    paramTag.parameterName += i.toString();
                }
                paramNames.add(paramTag.parameterName);
                // If the tag is optional, mark parameters following optional as optional,
                // even if they are not, since Closure restricts this, see
                // https://github.com/google/closure-compiler/issues/2314
                if (!paramTag.restParam && (paramTag.optional || foundOptional || i >= minArgsCount)) {
                    foundOptional = true;
                    paramTag.optional = true;
                }
                newDoc.push(paramTag);
                if (paramTag.restParam) {
                    // Cannot have any parameters after a rest param.
                    // Just dump the remaining parameters.
                    break;
                }
            }
            // Merge the JSDoc tags for each overloaded return.
            if (!isConstructor) {
                newDoc.push(jsdoc.merge(returnTags));
            }
            return {
                tags: newDoc,
                parameterNames: newDoc.filter(function (t) { return t.tagName === 'param'; }).map(function (t) { return t.parameterName; }),
                thisReturnType: thisReturnType,
            };
        };
        return ModuleTypeTranslator;
    }());
    exports.ModuleTypeTranslator = ModuleTypeTranslator;
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9kdWxlX3R5cGVfdHJhbnNsYXRvci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9tb2R1bGVfdHlwZV90cmFuc2xhdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7R0FNRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBRUg7Ozs7T0FJRztJQUVILCtCQUFpQztJQUdqQyxtREFBMkM7SUFDM0MseUNBQWlDO0lBQ2pDLGlFQUE0STtJQUM1SSw0REFBb0Q7SUFFcEQ7OztPQUdHO0lBQ0g7UUFDRSxzQkFDWSxJQUFhLEVBQVUsYUFBeUMsRUFDakUsSUFBaUI7WUFEaEIsU0FBSSxHQUFKLElBQUksQ0FBUztZQUFVLGtCQUFhLEdBQWIsYUFBYSxDQUE0QjtZQUNqRSxTQUFJLEdBQUosSUFBSSxDQUFhO1FBQUcsQ0FBQztRQUVoQyxvQ0FBYSxHQUFiLFVBQWMsZUFBNkI7WUFDekMsSUFBTSxJQUFJLEdBQUcsS0FBSyxDQUFDLHVCQUF1QixDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsZUFBZSxDQUFDLENBQUM7WUFDdkUsSUFBSSxJQUFJLENBQUMsYUFBYSxFQUFFO2dCQUN0QixJQUFJLENBQUMsSUFBSSxFQUFFO29CQUNULGtDQUFrQztvQkFDbEMsSUFBTSxVQUFRLEdBQUcsRUFBRSxDQUFDLDJCQUEyQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUUsQ0FBQztvQkFDNUQsSUFBTSxHQUFHLEdBQUcsVUFBUSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7b0JBQ2pELFVBQVEsQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDO29CQUN4QixJQUFJLENBQUMsYUFBYSxHQUFHLElBQUksQ0FBQztvQkFDMUIsT0FBTztpQkFDUjtnQkFDRCxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7Z0JBQy9CLE9BQU87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Q0FBQyxRQUFRLElBQUksYUFBYSxJQUFJLENBQUMsSUFBSSxZQUFZLENBQUMsRUFBRTtvQkFDcEYsYUFBYSxHQUFHLElBQUksQ0FBQztvQkFDckIsUUFBUSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUM7aUJBQzFCO2dCQUNELE1BQU0sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7Z0JBQ3RCLElBQUksUUFBUSxDQUFDLFNBQVMsRUFBRTtvQkFDdEIsaURBQWlEO29CQUNqRCxzQ0FBc0M7b0JBQ3RDLE1BQU07aUJBQ1A7YUFDRjtZQUVELG1EQUFtRDtZQUNuRCxJQUFJLENBQUMsYUFBYSxFQUFFO2dCQUNsQixNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQzthQUN0QztZQUVELE9BQU87Z0JBQ0wsSUFBSSxFQUFFLE1BQU07Z0JBQ1osY0FBYyxFQUFFLE1BQU0sQ0FBQyxNQUFNLENBQUMsVUFBQSxDQUFDLElBQUksT0FBQSxDQUFDLENBQUMsT0FBTyxLQUFLLE9BQU8sRUFBckIsQ0FBcUIsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxVQUFBLENBQUMsSUFBSSxPQUFBLENBQUMsQ0FBQyxhQUFjLEVBQWhCLENBQWdCLENBQUM7Z0JBQ3BGLGNBQWMsZ0JBQUE7YUFDZixDQUFDO1FBQ0osQ0FBQztRQUNILDJCQUFDO0lBQUQsQ0FBQyxBQS9jRCxJQStjQztJQS9jWSxvREFBb0IiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBtb2R1bGVfdHlwZV90cmFuc2xhdG9yIGJ1aWxkcyBvbiB0b3Agb2YgdHlwZV90cmFuc2xhdG9yLCBhZGRpbmcgZnVuY3Rpb25hbGl0eSB0b1xuICogdHJhbnNsYXRlIHR5cGVzIHdpdGhpbiB0aGUgc2NvcGUgb2YgYSBzaW5nbGUgbW9kdWxlLiBUaGUgbWFpbiBlbnRyeSBwb2ludCBpc1xuICogTW9kdWxlVHlwZVRyYW5zbGF0b3IuXG4gKi9cblxuaW1wb3J0ICogYXMgdHMgZnJvbSAndHlwZXNjcmlwdCc7XG5cbmltcG9ydCB7QW5ub3RhdG9ySG9zdH0gZnJvbSAnLi9hbm5vdGF0b3JfaG9zdCc7XG5pbXBvcnQgKiBhcyBnb29nbW9kdWxlIGZyb20gJy4vZ29vZ21vZHVsZSc7XG5pbXBvcnQgKiBhcyBqc2RvYyBmcm9tICcuL2pzZG9jJztcbmltcG9ydCB7Y3JlYXRlU2luZ2xlUXVvdGVTdHJpbmdMaXRlcmFsLCBnZXRJZGVudGlmaWVyVGV4dCwgaGFzTW9kaWZpZXJGbGFnLCByZXBvcnREZWJ1Z1dhcm5pbmcsIHJlcG9ydERpYWdub3N0aWN9IGZyb20gJy4vdHJhbnNmb3JtZXJfdXRpbCc7XG5pbXBvcnQgKiBhcyB0eXBlVHJhbnNsYXRvciBmcm9tICcuL3R5cGVfdHJhbnNsYXRvcic7XG5cbi8qKlxuICogTXV0YWJsZUpTRG9jIGVuY2Fwc3VsYXRlcyBhIChwb3RlbnRpYWwpIEpTRG9jIGNvbW1lbnQgb24gYSBzcGVjaWZpYyBub2RlLCBhbmQgYWxsb3dzIGNvZGUgdG9cbiAqIG1vZGlmeSAoaW5jbHVkaW5nIGRlbGV0ZSkgaXQuXG4gKi9cbmV4cG9ydCBjbGFzcyBNdXRhYmxlSlNEb2Mge1xuICBjb25zdHJ1Y3RvcihcbiAgICAgIHByaXZhdGUgbm9kZTogdHMuTm9kZSwgcHJpdmF0ZSBzb3VyY2VDb21tZW50OiB0cy5TeW50aGVzaXplZENvbW1lbnR8bnVsbCxcbiAgICAgIHB1YmxpYyB0YWdzOiBqc2RvYy5UYWdbXSkge31cblxuICB1cGRhdGVDb21tZW50KGVzY2FwZUV4dHJhVGFncz86IFNldDxzdHJpbmc+KSB7XG4gICAgY29uc3QgdGV4dCA9IGpzZG9jLnRvU3RyaW5nV2l0aG91dFN0YXJ0RW5kKHRoaXMudGFncywgZXNjYXBlRXh0cmFUYWdzKTtcbiAgICBpZiAodGhpcy5zb3VyY2VDb21tZW50KSB7XG4gICAgICBpZiAoIXRleHQpIHtcbiAgICAgICAgLy8gRGVsZXRlIHRoZSAobm93IGVtcHR5KSBjb21tZW50LlxuICAgICAgICBjb25zdCBjb21tZW50cyA9IHRzLmdldFN5bnRoZXRpY0xlYWRpbmdDb21tZW50cyh0aGlzLm5vZGUpITtcbiAgICAgICAgY29uc3QgaWR4ID0gY29tbWVudHMuaW5kZXhPZih0aGlzLnNvdXJjZUNvbW1lbnQpO1xuICAgICAgICBjb21tZW50cy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgdGhpcy5zb3VyY2VDb21tZW50ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5zb3VyY2VDb21tZW50LnRleHQgPSB0ZXh0O1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIERvbid0IGFkZCBhbiBlbXB0eSBjb21tZW50LlxuICAgIGlmICghdGV4dCkgcmV0dXJuO1xuXG4gICAgY29uc3QgY29tbWVudDogdHMuU3ludGhlc2l6ZWRDb21tZW50ID0ge1xuICAgICAga2luZDogdHMuU3ludGF4S2luZC5NdWx0aUxpbmVDb21tZW50VHJpdmlhLFxuICAgICAgdGV4dCxcbiAgICAgIGhhc1RyYWlsaW5nTmV3TGluZTogdHJ1ZSxcbiAgICAgIHBvczogLTEsXG4gICAgICBlbmQ6IC0xLFxuICAgIH07XG4gICAgY29uc3QgY29tbWVudHMgPSB0cy5nZXRTeW50aGV0aWNMZWFkaW5nQ29tbWVudHModGhpcy5ub2RlKSB8fCBbXTtcbiAgICBjb21tZW50cy5wdXNoKGNvbW1lbnQpO1xuICAgIHRzLnNldFN5bnRoZXRpY0xlYWRpbmdDb21tZW50cyh0aGlzLm5vZGUsIGNvbW1lbnRzKTtcbiAgfVxufVxuXG4vKiogUmV0dXJucyB0aGUgQ2xvc3VyZSBuYW1lIG9mIGEgZnVuY3Rpb24gcGFyYW1ldGVyLCBzcGVjaWFsLWNhc2luZyBkZXN0cnVjdHVyaW5nLiAqL1xuZnVuY3Rpb24gZ2V0UGFyYW1ldGVyTmFtZShwYXJhbTogdHMuUGFyYW1ldGVyRGVjbGFyYXRpb24sIGluZGV4OiBudW1iZXIpOiBzdHJpbmcge1xuICBzd2l0Y2ggKHBhcmFtLm5hbWUua2luZCkge1xuICAgIGNhc2UgdHMuU3ludGF4S2luZC5JZGVudGlmaWVyOlxuICAgICAgbGV0IG5hbWUgPSBnZXRJZGVudGlmaWVyVGV4dChwYXJhbS5uYW1lIGFzIHRzLklkZW50aWZpZXIpO1xuICAgICAgLy8gVHlwZVNjcmlwdCBhbGxvd3MgcGFyYW1ldGVycyBuYW1lZCBcImFyZ3VtZW50c1wiLCBidXQgQ2xvc3VyZVxuICAgICAgLy8gZGlzYWxsb3dzIHRoaXMsIGV2ZW4gaW4gZXh0ZXJucy5cbiAgICAgIGlmIChuYW1lID09PSAnYXJndW1lbnRzJykgbmFtZSA9ICd0c2lja2xlX2FyZ3VtZW50cyc7XG4gICAgICByZXR1cm4gbmFtZTtcbiAgICBjYXNlIHRzLlN5bnRheEtpbmQuQXJyYXlCaW5kaW5nUGF0dGVybjpcbiAgICBjYXNlIHRzLlN5bnRheEtpbmQuT2JqZWN0QmluZGluZ1BhdHRlcm46XG4gICAgICAvLyBDbG9zdXJlIGNyYXNoZXMgaWYgeW91IHB1dCBhIGJpbmRpbmcgcGF0dGVybiBpbiB0aGUgZXh0ZXJucy5cbiAgICAgIC8vIEF2b2lkIHRoaXMgYnkganVzdCBnZW5lcmF0aW5nIGFuIHVudXNlZCBuYW1lOyB0aGUgbmFtZSBpc1xuICAgICAgLy8gaWdub3JlZCBhbnl3YXkuXG4gICAgICByZXR1cm4gYF9fJHtpbmRleH1gO1xuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBUaGUgYWJvdmUgbGlzdCBvZiBraW5kcyBpcyBleGhhdXN0aXZlLiAgcGFyYW0ubmFtZSBpcyAnbmV2ZXInIGF0IHRoaXMgcG9pbnQuXG4gICAgICBjb25zdCBwYXJhbU5hbWUgPSBwYXJhbS5uYW1lIGFzIHRzLk5vZGU7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuaGFuZGxlZCBmdW5jdGlvbiBwYXJhbWV0ZXIga2luZDogJHt0cy5TeW50YXhLaW5kW3BhcmFtTmFtZS5raW5kXX1gKTtcbiAgfVxufVxuXG4vKipcbiAqIE1vZHVsZVR5cGVUcmFuc2xhdG9yIGVuY2Fwc3VsYXRlcyBrbm93bGVkZ2UgYW5kIGhlbHBlciBmdW5jdGlvbnMgdG8gdHJhbnNsYXRlIHR5cGVzIGluIHRoZSBzY29wZVxuICogb2YgYSBzcGVjaWZpYyBtb2R1bGUuIFRoaXMgaW5jbHVkZXMgbWFuYWdpbmcgQ2xvc3VyZSBmb3J3YXJkIGRlY2xhcmUgc3RhdGVtZW50cyBhbmQgYW55IHN5bWJvbFxuICogYWxpYXNlcyBpbiBzY29wZSBmb3IgYSB3aG9sZSBmaWxlLlxuICovXG5leHBvcnQgY2xhc3MgTW9kdWxlVHlwZVRyYW5zbGF0b3Ige1xuICAvKipcbiAgICogQSBtYXBwaW5nIG9mIGFsaWFzZXMgZm9yIHN5bWJvbHMgaW4gdGhlIGN1cnJlbnQgZmlsZSwgdXNlZCB3aGVuIGVtaXR0aW5nIHR5cGVzLiBUeXBlU2NyaXB0XG4gICAqIGVtaXRzIGltcG9ydGVkIHN5bWJvbHMgd2l0aCB1bnByZWRpY3RhYmxlIHByZWZpeGVzLiBUbyBnZW5lcmF0ZSBjb3JyZWN0IHR5cGUgYW5ub3RhdGlvbnMsXG4gICAqIHRzaWNrbGUgY3JlYXRlcyBpdHMgb3duIGFsaWFzZXMgZm9yIHR5cGVzLCBhbmQgcmVnaXN0ZXJzIHRoZW0gaW4gdGhpcyBtYXAgKHNlZVxuICAgKiBgZW1pdEltcG9ydERlY2xhcmF0aW9uYCBhbmQgYGZvcndhcmREZWNsYXJlKClgIGJlbG93KS4gVGhlIGFsaWFzZXMgYXJlIHRoZW4gdXNlZCB3aGVuIGVtaXR0aW5nXG4gICAqIHR5cGVzLlxuICAgKi9cbiAgc3ltYm9sc1RvQWxpYXNlZE5hbWVzID0gbmV3IE1hcDx0cy5TeW1ib2wsIHN0cmluZz4oKTtcblxuICAvKipcbiAgICogVGhlIHNldCBvZiBtb2R1bGUgc3ltYm9scyBmb3J3YXJkIGRlY2xhcmVkIGluIHRoZSBsb2NhbCBuYW1lc3BhY2UgKHdpdGggZ29vZy5mb3J3YXJEZWNsYXJlKS5cbiAgICpcbiAgICogU3ltYm9scyBub3QgaW1wb3J0ZWQgbXVzdCBiZSBkZWNsYXJlZCwgd2hpY2ggaXMgZG9uZSBieSBhZGRpbmcgZm9yd2FyZCBkZWNsYXJlcyB0b1xuICAgKiBgZXh0cmFJbXBvcnRzYCBiZWxvdy5cbiAgICovXG4gIHByaXZhdGUgZm9yd2FyZERlY2xhcmVkTW9kdWxlcyA9IG5ldyBTZXQ8dHMuU3ltYm9sPigpO1xuICAvKipcbiAgICogVGhlIGxpc3Qgb2YgZ2VuZXJhdGVkIGdvb2cuZm9yd2FyZERlY2xhcmUgc3RhdGVtZW50cyBmb3IgdGhpcyBtb2R1bGUuIFRoZXNlIGFyZSBpbnNlcnRlZCBpbnRvXG4gICAqIHRoZSBtb2R1bGUncyBib2R5IHN0YXRlbWVudHMgYWZ0ZXIgdHJhbnNsYXRpb24uXG4gICAqL1xuICBwcml2YXRlIGZvcndhcmREZWNsYXJlczogdHMuU3RhdGVtZW50W10gPSBbXTtcbiAgLyoqIEEgY291bnRlciB0byBnZW5lcmF0ZSB1bmlxdWUgbmFtZXMgZm9yIGdvb2cuZm9yd2FyZERlY2xhcmUgdmFyaWFibGVzLiAqL1xuICBwcml2YXRlIGZvcndhcmREZWNsYXJlQ291bnRlciA9IDA7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgICBwdWJsaWMgc291cmNlRmlsZTogdHMuU291cmNlRmlsZSxcbiAgICAgIHB1YmxpYyB0eXBlQ2hlY2tlcjogdHMuVHlwZUNoZWNrZXIsXG4gICAgICBwcml2YXRlIGhvc3Q6IEFubm90YXRvckhvc3QsXG4gICAgICBwcml2YXRlIGRpYWdub3N0aWNzOiB0cy5EaWFnbm9zdGljW10sXG4gICAgICBwcml2YXRlIGlzRm9yRXh0ZXJuczogYm9vbGVhbixcbiAgKSB7fVxuXG4gIGRlYnVnV2Fybihjb250ZXh0OiB0cy5Ob2RlLCBtZXNzYWdlVGV4dDogc3RyaW5nKSB7XG4gICAgcmVwb3J0RGVidWdXYXJuaW5nKHRoaXMuaG9zdCwgY29udGV4dCwgbWVzc2FnZVRleHQpO1xuICB9XG5cbiAgZXJyb3Iobm9kZTogdHMuTm9kZSwgbWVzc2FnZVRleHQ6IHN0cmluZykge1xuICAgIHJlcG9ydERpYWdub3N0aWModGhpcy5kaWFnbm9zdGljcywgbm9kZSwgbWVzc2FnZVRleHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYSBUeXBlU2NyaXB0IHRzLlR5cGUgaW50byB0aGUgZXF1aXZhbGVudCBDbG9zdXJlIHR5cGUuXG4gICAqXG4gICAqIEBwYXJhbSBjb250ZXh0IFRoZSB0cy5Ob2RlIGNvbnRhaW5pbmcgdGhlIHR5cGUgcmVmZXJlbmNlOyB1c2VkIGZvciByZXNvbHZpbmcgc3ltYm9sc1xuICAgKiAgICAgaW4gY29udGV4dC5cbiAgICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgdG8gdHJhbnNsYXRlOyBpZiBub3QgcHJvdmlkZWQsIHRoZSBOb2RlJ3MgdHlwZSB3aWxsIGJlIHVzZWQuXG4gICAqIEBwYXJhbSByZXNvbHZlQWxpYXMgSWYgdHJ1ZSwgZG8gbm90IGVtaXQgYWxpYXNlcyBhcyB0aGVpciBzeW1ib2wsIGJ1dCByYXRoZXIgYXMgdGhlIHJlc29sdmVkXG4gICAqICAgICB0eXBlIHVuZGVybHlpbmcgdGhlIGFsaWFzLiBUaGlzIHNob3VsZCBiZSB0cnVlIG9ubHkgd2hlbiBlbWl0dGluZyB0aGUgdHlwZWRlZiBpdHNlbGYuXG4gICAqL1xuICB0eXBlVG9DbG9zdXJlKGNvbnRleHQ6IHRzLk5vZGUsIHR5cGU/OiB0cy5UeXBlKTogc3RyaW5nIHtcbiAgICBpZiAodGhpcy5ob3N0LnVudHlwZWQpIHtcbiAgICAgIHJldHVybiAnPyc7XG4gICAgfVxuXG4gICAgY29uc3QgdHlwZUNoZWNrZXIgPSB0aGlzLnR5cGVDaGVja2VyO1xuICAgIGlmICghdHlwZSkge1xuICAgICAgdHlwZSA9IHR5cGVDaGVja2VyLmdldFR5cGVBdExvY2F0aW9uKGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5uZXdUeXBlVHJhbnNsYXRvcihjb250ZXh0KS50cmFuc2xhdGUodHlwZSk7XG4gIH1cblxuICBuZXdUeXBlVHJhbnNsYXRvcihjb250ZXh0OiB0cy5Ob2RlKSB7XG4gICAgLy8gSW4gZXh0ZXJucywgdGhlcmUgaXMgbm8gbG9jYWwgc2NvcGUsIHNvIGFsbCB0eXBlcyBtdXN0IGJlIHJlbGF0aXZlIHRvIHRoZSBmaWxlIGxldmVsIHNjb3BlLlxuICAgIGNvbnN0IHRyYW5zbGF0aW9uQ29udGV4dCA9IHRoaXMuaXNGb3JFeHRlcm5zID8gdGhpcy5zb3VyY2VGaWxlIDogY29udGV4dDtcblxuICAgIGNvbnN0IHRyYW5zbGF0b3IgPSBuZXcgdHlwZVRyYW5zbGF0b3IuVHlwZVRyYW5zbGF0b3IoXG4gICAgICAgIHRoaXMuaG9zdCwgdGhpcy50eXBlQ2hlY2tlciwgdHJhbnNsYXRpb25Db250ZXh0LCB0aGlzLmhvc3QudHlwZUJsYWNrTGlzdFBhdGhzLFxuICAgICAgICB0aGlzLnN5bWJvbHNUb0FsaWFzZWROYW1lcywgKHN5bTogdHMuU3ltYm9sKSA9PiB0aGlzLmVuc3VyZVN5bWJvbERlY2xhcmVkKHN5bSkpO1xuICAgIHRyYW5zbGF0b3IuaXNGb3JFeHRlcm5zID0gdGhpcy5pc0ZvckV4dGVybnM7XG4gICAgdHJhbnNsYXRvci53YXJuID0gbXNnID0+IHRoaXMuZGVidWdXYXJuKGNvbnRleHQsIG1zZyk7XG4gICAgcmV0dXJuIHRyYW5zbGF0b3I7XG4gIH1cblxuICBpc0JsYWNrTGlzdGVkKGNvbnRleHQ6IHRzLk5vZGUpIHtcbiAgICBjb25zdCB0eXBlID0gdGhpcy50eXBlQ2hlY2tlci5nZXRUeXBlQXRMb2NhdGlvbihjb250ZXh0KTtcbiAgICBsZXQgc3ltID0gdHlwZS5zeW1ib2w7XG4gICAgaWYgKCFzeW0pIHJldHVybiBmYWxzZTtcbiAgICBpZiAoc3ltLmZsYWdzICYgdHMuU3ltYm9sRmxhZ3MuQWxpYXMpIHtcbiAgICAgIHN5bSA9IHRoaXMudHlwZUNoZWNrZXIuZ2V0QWxpYXNlZFN5bWJvbChzeW0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5uZXdUeXBlVHJhbnNsYXRvcihjb250ZXh0KS5pc0JsYWNrTGlzdGVkKHN5bSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB0cy5TeW1ib2wgYXQgYSBsb2NhdGlvbiBvciB0aHJvdy5cbiAgICogVGhlIFR5cGVTY3JpcHQgQVBJIGNhbiByZXR1cm4gdW5kZWZpbmVkIHdoZW4gZmV0Y2hpbmcgYSBzeW1ib2wsIGJ1dCBpbiBtYW55IGNvbnRleHRzIHdlIGtub3cgaXRcbiAgICogd29uJ3QgKGUuZy4gb3VyIGlucHV0IGlzIGFscmVhZHkgdHlwZS1jaGVja2VkKS5cbiAgICovXG4gIG11c3RHZXRTeW1ib2xBdExvY2F0aW9uKG5vZGU6IHRzLk5vZGUpOiB0cy5TeW1ib2wge1xuICAgIGNvbnN0IHN5bSA9IHRoaXMudHlwZUNoZWNrZXIuZ2V0U3ltYm9sQXRMb2NhdGlvbihub2RlKTtcbiAgICBpZiAoIXN5bSkgdGhyb3cgbmV3IEVycm9yKCdubyBzeW1ib2wnKTtcbiAgICByZXR1cm4gc3ltO1xuICB9XG5cbiAgLyoqIEZpbmRzIGFuIGV4cG9ydGVkIChpLmUuIG5vdCBnbG9iYWwpIGRlY2xhcmF0aW9uIGZvciB0aGUgZ2l2ZW4gc3ltYm9sLiAqL1xuICBwcm90ZWN0ZWQgZmluZEV4cG9ydGVkRGVjbGFyYXRpb24oc3ltOiB0cy5TeW1ib2wpOiB0cy5EZWNsYXJhdGlvbnx1bmRlZmluZWQge1xuICAgIC8vIFRPRE8obWFydGlucHJvYnN0KTogaXQncyB1bmNsZWFyIHdoZW4gYSBzeW1ib2wgd291bGRuJ3QgaGF2ZSBhIGRlY2xhcmF0aW9uLCBtYXliZSBqdXN0IGZvclxuICAgIC8vIHNvbWUgYnVpbHRpbnMgKGUuZy4gU3ltYm9sKT9cbiAgICBpZiAoIXN5bS5kZWNsYXJhdGlvbnMgfHwgc3ltLmRlY2xhcmF0aW9ucy5sZW5ndGggPT09IDApIHJldHVybiB1bmRlZmluZWQ7XG4gICAgLy8gQSBzeW1ib2wgZGVjbGFyZWQgaW4gdGhpcyBmaWxlIGRvZXMgbm90IG5lZWQgdG8gYmUgaW1wb3J0ZWQuXG4gICAgaWYgKHN5bS5kZWNsYXJhdGlvbnMuc29tZShkID0+IGQuZ2V0U291cmNlRmlsZSgpID09PSB0aGlzLnNvdXJjZUZpbGUpKSByZXR1cm4gdW5kZWZpbmVkO1xuXG4gICAgLy8gRmluZCBhbiBleHBvcnRlZCBkZWNsYXJhdGlvbi5cbiAgICAvLyBCZWNhdXNlIHRzaWNrbGUgcnVucyB3aXRoIHRoZSAtLWRlY2xhcmF0aW9uIGZsYWcsIGFsbCB0eXBlcyByZWZlcmVuY2VkIGZyb20gZXhwb3J0ZWQgdHlwZXNcbiAgICAvLyBtdXN0IGJlIGV4cG9ydGVkLCB0b28sIHNvIHRoZXJlIG11c3QgZWl0aGVyIGJlIHNvbWUgZGVjbGFyYXRpb24gdGhhdCBpcyBleHBvcnRlZCwgb3IgdGhlXG4gICAgLy8gc3ltYm9sIGlzIGFjdHVhbGx5IGEgZ2xvYmFsIGRlY2xhcmF0aW9uIChkZWNsYXJlZCBpbiBhIHNjcmlwdCBmaWxlLCBub3QgYSBtb2R1bGUpLlxuICAgIGNvbnN0IGRlY2wgPSBzeW0uZGVjbGFyYXRpb25zLmZpbmQoZCA9PiB7XG4gICAgICAvLyBDaGVjayBmb3IgRXhwb3J0IHwgRGVmYXVsdCAoZGVmYXVsdCBiZWluZyBhIGRlZmF1bHQgZXhwb3J0KS5cbiAgICAgIGlmICghaGFzTW9kaWZpZXJGbGFnKGQsIHRzLk1vZGlmaWVyRmxhZ3MuRXhwb3J0RGVmYXVsdCkpIHJldHVybiBmYWxzZTtcbiAgICAgIC8vIEV4Y2x1ZGUgc3ltYm9scyBkZWNsYXJlZCBpbiBgZGVjbGFyZSBnbG9iYWwgey4uLn1gIGJsb2NrcywgdGhleSBhcmUgZ2xvYmFsIGFuZCBkb24ndCBuZWVkXG4gICAgICAvLyBpbXBvcnRzLlxuICAgICAgbGV0IGN1cnJlbnQ6IHRzLk5vZGV8dW5kZWZpbmVkID0gZDtcbiAgICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICAgIGlmIChjdXJyZW50LmZsYWdzICYgdHMuTm9kZUZsYWdzLkdsb2JhbEF1Z21lbnRhdGlvbikgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gZGVjbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBgY29uc3QgeCA9IGdvb2cuZm9yd2FyZERlY2xhcmUuLi5gIHRleHQgZm9yIGFuIGltcG9ydCBvZiB0aGUgZ2l2ZW4gYGltcG9ydFBhdGhgLlxuICAgKiBUaGlzIGFsc28gcmVnaXN0ZXJzIGFsaWFzZXMgZm9yIHN5bWJvbHMgZnJvbSB0aGUgbW9kdWxlIHRoYXQgbWFwIHRvIHRoaXMgZm9yd2FyZCBkZWNsYXJlLlxuICAgKi9cbiAgZm9yd2FyZERlY2xhcmUoXG4gICAgICBpbXBvcnRQYXRoOiBzdHJpbmcsIG1vZHVsZVN5bWJvbDogdHMuU3ltYm9sLCBpc0V4cGxpY2l0SW1wb3J0OiBib29sZWFuLFxuICAgICAgaXNEZWZhdWx0SW1wb3J0ID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy5ob3N0LnVudHlwZWQpIHJldHVybjtcbiAgICAvLyBBbHJlYWR5IGltcG9ydGVkPyBEbyBub3QgZW1pdCBhIGR1cGxpY2F0ZSBmb3J3YXJkIGRlY2xhcmUuXG4gICAgaWYgKHRoaXMuZm9yd2FyZERlY2xhcmVkTW9kdWxlcy5oYXMobW9kdWxlU3ltYm9sKSkgcmV0dXJuO1xuICAgIGlmICh0aGlzLmhvc3QudHlwZUJsYWNrTGlzdFBhdGhzICYmIHRoaXMuaG9zdC50eXBlQmxhY2tMaXN0UGF0aHMuaGFzKGltcG9ydFBhdGgpKSB7XG4gICAgICByZXR1cm47ICAvLyBEbyBub3QgZW1pdCBnb29nLmZvcndhcmREZWNsYXJlIG9yIGdvb2cucmVxdWlyZSBmb3IgYmxhY2tsaXN0ZWQgcGF0aHMuXG4gICAgfVxuICAgIGNvbnN0IG5zSW1wb3J0ID0gZ29vZ21vZHVsZS5leHRyYWN0R29vZ05hbWVzcGFjZUltcG9ydChpbXBvcnRQYXRoKTtcbiAgICBjb25zdCBmb3J3YXJkRGVjbGFyZVByZWZpeCA9IGB0c2lja2xlX2ZvcndhcmRfZGVjbGFyZV8keysrdGhpcy5mb3J3YXJkRGVjbGFyZUNvdW50ZXJ9YDtcbiAgICBjb25zdCBtb2R1bGVOYW1lc3BhY2UgPSBuc0ltcG9ydCAhPT0gbnVsbCA/XG4gICAgICAgIG5zSW1wb3J0IDpcbiAgICAgICAgdGhpcy5ob3N0LnBhdGhUb01vZHVsZU5hbWUodGhpcy5zb3VyY2VGaWxlLmZpbGVOYW1lLCBpbXBvcnRQYXRoKTtcblxuICAgIC8vIEluIFR5cGVTY3JpcHQsIGltcG9ydGluZyBhIG1vZHVsZSBmb3IgdXNlIGluIGEgdHlwZSBhbm5vdGF0aW9uIGRvZXMgbm90IGNhdXNlIGEgcnVudGltZSBsb2FkLlxuICAgIC8vIEluIENsb3N1cmUgQ29tcGlsZXIsIGdvb2cucmVxdWlyZSdpbmcgYSBtb2R1bGUgY2F1c2VzIGEgcnVudGltZSBsb2FkLCBzbyBlbWl0dGluZyByZXF1aXJlc1xuICAgIC8vIGhlcmUgd291bGQgY2F1c2UgYSBjaGFuZ2UgaW4gbG9hZCBvcmRlciwgd2hpY2ggaXMgb2JzZXJ2YWJsZSAoYW5kIGNhbiBsZWFkIHRvIGVycm9ycykuXG4gICAgLy8gSW5zdGVhZCwgZ29vZy5mb3J3YXJkRGVjbGFyZSB0eXBlcywgd2hpY2ggYWxsb3dzIHVzaW5nIHRoZW0gaW4gdHlwZSBhbm5vdGF0aW9ucyB3aXRob3V0XG4gICAgLy8gY2F1c2luZyBhIGxvYWQuIFNlZSBiZWxvdyBmb3IgdGhlIGV4Y2VwdGlvbiB0byB0aGUgcnVsZS5cbiAgICAvLyBjb25zdCBmb3J3YXJkRGVjbGFyZVByZWZpeCA9IGdvb2cuZm9yd2FyZERlY2xhcmUobW9kdWxlTmFtZXNwYWNlKVxuICAgIHRoaXMuZm9yd2FyZERlY2xhcmVzLnB1c2godHMuY3JlYXRlVmFyaWFibGVTdGF0ZW1lbnQoXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgdHMuY3JlYXRlVmFyaWFibGVEZWNsYXJhdGlvbkxpc3QoXG4gICAgICAgICAgICBbdHMuY3JlYXRlVmFyaWFibGVEZWNsYXJhdGlvbihcbiAgICAgICAgICAgICAgICBmb3J3YXJkRGVjbGFyZVByZWZpeCwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHRzLmNyZWF0ZUNhbGwoXG4gICAgICAgICAgICAgICAgICAgIHRzLmNyZWF0ZVByb3BlcnR5QWNjZXNzKHRzLmNyZWF0ZUlkZW50aWZpZXIoJ2dvb2cnKSwgJ2ZvcndhcmREZWNsYXJlJyksXG4gICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCwgW3RzLmNyZWF0ZUxpdGVyYWwobW9kdWxlTmFtZXNwYWNlKV0pKV0sXG4gICAgICAgICAgICB0cy5Ob2RlRmxhZ3MuQ29uc3QpKSk7XG4gICAgdGhpcy5mb3J3YXJkRGVjbGFyZWRNb2R1bGVzLmFkZChtb2R1bGVTeW1ib2wpO1xuICAgIGNvbnN0IGV4cG9ydHMgPSB0aGlzLnR5cGVDaGVja2VyLmdldEV4cG9ydHNPZk1vZHVsZShtb2R1bGVTeW1ib2wpLm1hcChlID0+IHtcbiAgICAgIGlmIChlLmZsYWdzICYgdHMuU3ltYm9sRmxhZ3MuQWxpYXMpIHtcbiAgICAgICAgZSA9IHRoaXMudHlwZUNoZWNrZXIuZ2V0QWxpYXNlZFN5bWJvbChlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlO1xuICAgIH0pO1xuICAgIGNvbnN0IGhhc1ZhbHVlcyA9IGV4cG9ydHMuc29tZShlID0+IHtcbiAgICAgIGNvbnN0IGlzVmFsdWUgPSAoZS5mbGFncyAmIHRzLlN5bWJvbEZsYWdzLlZhbHVlKSAhPT0gMDtcbiAgICAgIGNvbnN0IGlzQ29uc3RFbnVtID0gKGUuZmxhZ3MgJiB0cy5TeW1ib2xGbGFncy5Db25zdEVudW0pICE9PSAwO1xuICAgICAgLy8gY29uc3QgZW51bXMgYXJlIGlubGluZWQgYnkgVHlwZVNjcmlwdCAoaWYgcHJlc2VydmVDb25zdEVudW1zPWZhbHNlKSwgc28gdGhlcmUgaXMgbmV2ZXIgYVxuICAgICAgLy8gdmFsdWUgaW1wb3J0IGdlbmVyYXRlZCBmb3IgdGhlbS4gVGhhdCBtZWFucyBmb3IgdGhlIHB1cnBvc2Ugb2YgZm9yY2UtaW1wb3J0aW5nIG1vZHVsZXMsXG4gICAgICAvLyB0aGV5IGRvIG5vdCBjb3VudCBhcyB2YWx1ZXMuIElmIHByZXNlcnZlQ29uc3RFbnVtcz10cnVlLCB0aGlzIHNob3VsZG4ndCBodXJ0LlxuICAgICAgcmV0dXJuIGlzVmFsdWUgJiYgIWlzQ29uc3RFbnVtO1xuICAgIH0pO1xuICAgIGlmIChpc0V4cGxpY2l0SW1wb3J0ICYmICFoYXNWYWx1ZXMpIHtcbiAgICAgIC8vIENsb3N1cmUgQ29tcGlsZXIncyB0b29sY2hhaW4gd2lsbCBkcm9wIGZpbGVzIHRoYXQgYXJlIG5ldmVyIGdvb2cucmVxdWlyZSdkICpiZWZvcmUqIHR5cGVcbiAgICAgIC8vIGNoZWNraW5nIChlLmcuIHdoZW4gdXNpbmcgLS1jbG9zdXJlX2VudHJ5X3BvaW50IG9yIHNpbWlsYXIgdG9vbHMpLiBUaGlzIGNhdXNlcyBlcnJvcnNcbiAgICAgIC8vIGNvbXBsYWluaW5nIGFib3V0IHZhbHVlcyBub3QgbWF0Y2hpbmcgJ05vUmVzb2x2ZWRUeXBlJywgb3IgbW9kdWxlcyBub3QgaGF2aW5nIGEgY2VydGFpblxuICAgICAgLy8gbWVtYmVyLlxuICAgICAgLy8gVG8gZml4LCBleHBsaWNpdGx5IGdvb2cucmVxdWlyZSgpIG1vZHVsZXMgdGhhdCBvbmx5IGV4cG9ydCB0eXBlcy4gVGhpcyBzaG91bGQgdXN1YWxseSBub3RcbiAgICAgIC8vIGNhdXNlIGJyZWFrYWdlcyBkdWUgdG8gbG9hZCBvcmRlciAoYXMgbm8gc3ltYm9scyBhcmUgYWNjZXNzaWJsZSBmcm9tIHRoZSBtb2R1bGUgLSB0aG91Z2hcbiAgICAgIC8vIGNvbnRyaXZlZCBjb2RlIGNvdWxkIG9ic2VydmUgY2hhbmdlcyBpbiBzaWRlIGVmZmVjdHMpLlxuICAgICAgLy8gVGhpcyBpcyBhIGhldXJpc3RpYyAtIGlmIHRoZSBtb2R1bGUgZXhwb3J0cyBzb21lIHZhbHVlcywgYnV0IHRob3NlIGFyZSBuZXZlciBpbXBvcnRlZCxcbiAgICAgIC8vIHRoZSBmaWxlIHdpbGwgc3RpbGwgZW5kIHVwIG5vdCBiZWluZyBpbXBvcnRlZC4gSG9wZWZ1bGx5IG1vZHVsZXMgdGhhdCBleHBvcnQgdmFsdWVzIGFyZVxuICAgICAgLy8gaW1wb3J0ZWQgZm9yIHRoZWlyIHZhbHVlIGluIHNvbWUgcGxhY2UuXG4gICAgICAvLyBnb29nLnJlcXVpcmUoXCIke21vZHVsZU5hbWVzcGFjZX1cIik7XG4gICAgICBjb25zdCBoYXJkUmVxdWlyZSA9IHRzLmNyZWF0ZVN0YXRlbWVudCh0cy5jcmVhdGVDYWxsKFxuICAgICAgICAgIHRzLmNyZWF0ZVByb3BlcnR5QWNjZXNzKHRzLmNyZWF0ZUlkZW50aWZpZXIoJ2dvb2cnKSwgJ3JlcXVpcmUnKSwgdW5kZWZpbmVkLFxuICAgICAgICAgIFtjcmVhdGVTaW5nbGVRdW90ZVN0cmluZ0xpdGVyYWwobW9kdWxlTmFtZXNwYWNlKV0pKTtcbiAgICAgIGNvbnN0IGNvbW1lbnQ6IHRzLlN5bnRoZXNpemVkQ29tbWVudCA9IHtcbiAgICAgICAga2luZDogdHMuU3ludGF4S2luZC5TaW5nbGVMaW5lQ29tbWVudFRyaXZpYSxcbiAgICAgICAgdGV4dDogJyBmb3JjZSB0eXBlLW9ubHkgbW9kdWxlIHRvIGJlIGxvYWRlZCcsXG4gICAgICAgIGhhc1RyYWlsaW5nTmV3TGluZTogdHJ1ZSxcbiAgICAgICAgcG9zOiAtMSxcbiAgICAgICAgZW5kOiAtMSxcbiAgICAgIH07XG4gICAgICB0cy5zZXRTeW50aGV0aWNUcmFpbGluZ0NvbW1lbnRzKGhhcmRSZXF1aXJlLCBbY29tbWVudF0pO1xuICAgICAgdGhpcy5mb3J3YXJkRGVjbGFyZXMucHVzaChoYXJkUmVxdWlyZSk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qgc3ltIG9mIGV4cG9ydHMpIHtcbiAgICAgIC8vIGdvb2c6IGltcG9ydHMgZG9uJ3QgYWN0dWFsbHkgdXNlIHRoZSAuZGVmYXVsdCBwcm9wZXJ0eSB0aGF0IFRTIHRoaW5rcyB0aGV5IGhhdmUuXG4gICAgICBjb25zdCBxdWFsaWZpZWROYW1lID0gbnNJbXBvcnQgJiYgaXNEZWZhdWx0SW1wb3J0ID8gZm9yd2FyZERlY2xhcmVQcmVmaXggOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcndhcmREZWNsYXJlUHJlZml4ICsgJy4nICsgc3ltLm5hbWU7XG4gICAgICB0aGlzLnN5bWJvbHNUb0FsaWFzZWROYW1lcy5zZXQoc3ltLCBxdWFsaWZpZWROYW1lKTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgZW5zdXJlU3ltYm9sRGVjbGFyZWQoc3ltOiB0cy5TeW1ib2wpIHtcbiAgICBjb25zdCBkZWNsID0gdGhpcy5maW5kRXhwb3J0ZWREZWNsYXJhdGlvbihzeW0pO1xuICAgIGlmICghZGVjbCkgcmV0dXJuO1xuICAgIGlmICh0aGlzLmlzRm9yRXh0ZXJucykge1xuICAgICAgdGhpcy5lcnJvcihkZWNsLCBgZGVjbGFyYXRpb24gZnJvbSBtb2R1bGUgdXNlZCBpbiBhbWJpZW50IHR5cGU6ICR7c3ltLm5hbWV9YCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIEFjdHVhbGx5IGltcG9ydCB0aGUgc3ltYm9sLlxuICAgIGNvbnN0IHNvdXJjZUZpbGUgPSBkZWNsLmdldFNvdXJjZUZpbGUoKTtcbiAgICBpZiAoc291cmNlRmlsZSA9PT0gdHMuZ2V0T3JpZ2luYWxOb2RlKHRoaXMuc291cmNlRmlsZSkpIHJldHVybjtcbiAgICBjb25zdCBtb2R1bGVTeW1ib2wgPSB0aGlzLnR5cGVDaGVja2VyLmdldFN5bWJvbEF0TG9jYXRpb24oc291cmNlRmlsZSk7XG4gICAgLy8gQSBzb3VyY2UgZmlsZSBtaWdodCBub3QgaGF2ZSBhIHN5bWJvbCBpZiBpdCdzIG5vdCBhIG1vZHVsZSAobm8gRVM2IGltL2V4cG9ydHMpLlxuICAgIGlmICghbW9kdWxlU3ltYm9sKSByZXR1cm47XG4gICAgLy8gVE9ETyhtYXJ0aW5wcm9ic3QpOiB0aGlzIHNob3VsZCBwb3NzaWJseSB1c2UgZmlsZU5hbWVUb01vZHVsZUlkLlxuICAgIHRoaXMuZm9yd2FyZERlY2xhcmUoc291cmNlRmlsZS5maWxlTmFtZSwgbW9kdWxlU3ltYm9sLCBmYWxzZSk7XG4gIH1cblxuICBpbnNlcnRGb3J3YXJkRGVjbGFyZXMoc291cmNlRmlsZTogdHMuU291cmNlRmlsZSkge1xuICAgIGxldCBpbnNlcnRpb24gPSAwO1xuICAgIC8vIFNraXAgb3ZlciBhIGxlYWRpbmcgZmlsZSBjb21tZW50IGhvbGRlci5cbiAgICBpZiAoc291cmNlRmlsZS5zdGF0ZW1lbnRzLmxlbmd0aCAmJlxuICAgICAgICBzb3VyY2VGaWxlLnN0YXRlbWVudHNbMF0ua2luZCA9PT0gdHMuU3ludGF4S2luZC5Ob3RFbWl0dGVkU3RhdGVtZW50KSB7XG4gICAgICBpbnNlcnRpb24rKztcbiAgICB9XG4gICAgcmV0dXJuIHRzLnVwZGF0ZVNvdXJjZUZpbGVOb2RlKHNvdXJjZUZpbGUsIFtcbiAgICAgIC4uLnNvdXJjZUZpbGUuc3RhdGVtZW50cy5zbGljZSgwLCBpbnNlcnRpb24pLFxuICAgICAgLi4udGhpcy5mb3J3YXJkRGVjbGFyZXMsXG4gICAgICAuLi5zb3VyY2VGaWxlLnN0YXRlbWVudHMuc2xpY2UoaW5zZXJ0aW9uKSxcbiAgICBdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZXMgYW5kIHN5bnRoZXNpemVzIGNvbW1lbnRzIG9uIG5vZGUsIGFuZCByZXR1cm5zIHRoZSBKU0RvYyBmcm9tIGl0LCBpZiBhbnkuXG4gICAqIEBwYXJhbSByZXBvcnRXYXJuaW5ncyBpZiB0cnVlLCB3aWxsIHJlcG9ydCB3YXJuaW5ncyBmcm9tIHBhcnNpbmcgdGhlIEpTRG9jLiBTZXQgdG8gZmFsc2UgaWZcbiAgICogICAgIHRoaXMgaXMgbm90IHRoZSBcIm1haW5cIiBsb2NhdGlvbiBkZWFsaW5nIHdpdGggYSBub2RlIHRvIGF2b2lkIGR1cGxpY2F0ZWQgd2FybmluZ3MuXG4gICAqL1xuICBnZXRKU0RvYyhub2RlOiB0cy5Ob2RlLCByZXBvcnRXYXJuaW5nczogYm9vbGVhbik6IGpzZG9jLlRhZ1tdIHtcbiAgICBjb25zdCBbdGFncywgXSA9IHRoaXMucGFyc2VKU0RvYyhub2RlLCByZXBvcnRXYXJuaW5ncyk7XG4gICAgcmV0dXJuIHRhZ3M7XG4gIH1cblxuICBnZXRNdXRhYmxlSlNEb2Mobm9kZTogdHMuTm9kZSk6IE11dGFibGVKU0RvYyB7XG4gICAgY29uc3QgW3RhZ3MsIGNvbW1lbnRdID0gdGhpcy5wYXJzZUpTRG9jKG5vZGUsIC8qIHJlcG9ydFdhcm5pbmdzICovIHRydWUpO1xuICAgIHJldHVybiBuZXcgTXV0YWJsZUpTRG9jKG5vZGUsIGNvbW1lbnQsIHRhZ3MpO1xuICB9XG5cbiAgcHJpdmF0ZSBwYXJzZUpTRG9jKG5vZGU6IHRzLk5vZGUsIHJlcG9ydFdhcm5pbmdzOiBib29sZWFuKTpcbiAgICAgIFtqc2RvYy5UYWdbXSwgdHMuU3ludGhlc2l6ZWRDb21tZW50fG51bGxdIHtcbiAgICAvLyBzeW50aGVzaXplTGVhZGluZ0NvbW1lbnRzIGJlbG93IGNoYW5nZXMgdGV4dCBsb2NhdGlvbnMgZm9yIG5vZGUsIHNvIGV4dHJhY3QgdGhlIGxvY2F0aW9uIGhlcmVcbiAgICAvLyBpbiBjYXNlIGl0IGlzIG5lZWRlZCBsYXRlciB0byByZXBvcnQgZGlhZ25vc3RpY3MuXG4gICAgY29uc3Qgc3RhcnQgPSBub2RlLmdldEZ1bGxTdGFydCgpO1xuICAgIGNvbnN0IGxlbmd0aCA9IG5vZGUuZ2V0TGVhZGluZ1RyaXZpYVdpZHRoKHRoaXMuc291cmNlRmlsZSk7XG5cbiAgICBjb25zdCBjb21tZW50cyA9IGpzZG9jLnN5bnRoZXNpemVMZWFkaW5nQ29tbWVudHMobm9kZSk7XG4gICAgaWYgKCFjb21tZW50cyB8fCBjb21tZW50cy5sZW5ndGggPT09IDApIHJldHVybiBbW10sIG51bGxdO1xuXG4gICAgZm9yIChsZXQgaSA9IGNvbW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBjb25zdCBjb21tZW50ID0gY29tbWVudHNbaV07XG4gICAgICBjb25zdCBwYXJzZWQgPSBqc2RvYy5wYXJzZShjb21tZW50KTtcbiAgICAgIGlmIChwYXJzZWQpIHtcbiAgICAgICAgaWYgKHJlcG9ydFdhcm5pbmdzICYmIHBhcnNlZC53YXJuaW5ncykge1xuICAgICAgICAgIGNvbnN0IHJhbmdlID0gY29tbWVudC5vcmlnaW5hbFJhbmdlIHx8IHtwb3M6IHN0YXJ0LCBlbmQ6IHN0YXJ0ICsgbGVuZ3RofTtcbiAgICAgICAgICByZXBvcnREaWFnbm9zdGljKFxuICAgICAgICAgICAgICB0aGlzLmRpYWdub3N0aWNzLCBub2RlLCBwYXJzZWQud2FybmluZ3Muam9pbignXFxuJyksIHJhbmdlLFxuICAgICAgICAgICAgICB0cy5EaWFnbm9zdGljQ2F0ZWdvcnkuV2FybmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtwYXJzZWQudGFncywgY29tbWVudF07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbW10sIG51bGxdO1xuICB9XG5cbiAgYmxhY2tsaXN0VHlwZVBhcmFtZXRlcnMoXG4gICAgICBjb250ZXh0OiB0cy5Ob2RlLCBkZWNsczogUmVhZG9ubHlBcnJheTx0cy5UeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24+fHVuZGVmaW5lZCkge1xuICAgIHRoaXMubmV3VHlwZVRyYW5zbGF0b3IoY29udGV4dCkuYmxhY2tsaXN0VHlwZVBhcmFtZXRlcnModGhpcy5zeW1ib2xzVG9BbGlhc2VkTmFtZXMsIGRlY2xzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHRoZSBqc2RvYyBmb3IgbWV0aG9kcywgaW5jbHVkaW5nIG92ZXJsb2Fkcy5cbiAgICogSWYgb3ZlcmxvYWRlZCwgbWVyZ2VzIHRoZSBzaWduYXR1cmVzIGluIHRoZSBsaXN0IG9mIFNpZ25hdHVyZURlY2xhcmF0aW9ucyBpbnRvIGEgc2luZ2xlIGpzZG9jLlxuICAgKiAtIFRvdGFsIG51bWJlciBvZiBwYXJhbWV0ZXJzIHdpbGwgYmUgdGhlIG1heGltdW0gY291bnQgZm91bmQgYWNyb3NzIGFsbCB2YXJpYW50cy5cbiAgICogLSBEaWZmZXJlbnQgbmFtZXMgYXQgdGhlIHNhbWUgcGFyYW1ldGVyIGluZGV4IHdpbGwgYmUgam9pbmVkIHdpdGggXCJfb3JfXCJcbiAgICogLSBWYXJpYWJsZSBhcmdzICguLi50eXBlW10gaW4gVHlwZVNjcmlwdCkgd2lsbCBiZSBvdXRwdXQgYXMgXCIuLi50eXBlXCIsXG4gICAqICAgIGV4Y2VwdCBpZiBmb3VuZCBhdCB0aGUgc2FtZSBpbmRleCBhcyBhbm90aGVyIGFyZ3VtZW50LlxuICAgKiBAcGFyYW0gZm5EZWNscyBQYXNzID4gMSBkZWNsYXJhdGlvbiBmb3Igb3ZlcmxvYWRzIG9mIHNhbWUgbmFtZVxuICAgKiBAcmV0dXJuIFRoZSBsaXN0IG9mIHBhcmFtZXRlciBuYW1lcyB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIGVtaXQgdGhlIGFjdHVhbFxuICAgKiAgICBmdW5jdGlvbiBzdGF0ZW1lbnQ7IGZvciBvdmVybG9hZHMsIG5hbWUgd2lsbCBoYXZlIGJlZW4gbWVyZ2VkLlxuICAgKi9cbiAgZ2V0RnVuY3Rpb25UeXBlSlNEb2MoZm5EZWNsczogdHMuU2lnbmF0dXJlRGVjbGFyYXRpb25bXSwgZXh0cmFUYWdzOiBqc2RvYy5UYWdbXSA9IFtdKTpcbiAgICAgIHt0YWdzOiBqc2RvYy5UYWdbXSwgcGFyYW1ldGVyTmFtZXM6IHN0cmluZ1tdLCB0aGlzUmV0dXJuVHlwZTogdHMuVHlwZXxudWxsfSB7XG4gICAgY29uc3QgdHlwZUNoZWNrZXIgPSB0aGlzLnR5cGVDaGVja2VyO1xuXG4gICAgLy8gRGUtZHVwbGljYXRlIHRhZ3MgYW5kIGRvY3MgZm91bmQgZm9yIHRoZSBmbkRlY2xzLlxuICAgIGNvbnN0IHRhZ3NCeU5hbWUgPSBuZXcgTWFwPHN0cmluZywganNkb2MuVGFnPigpO1xuICAgIGZ1bmN0aW9uIGFkZFRhZyh0YWc6IGpzZG9jLlRhZykge1xuICAgICAgY29uc3QgZXhpc3RpbmcgPSB0YWdzQnlOYW1lLmdldCh0YWcudGFnTmFtZSk7XG4gICAgICB0YWdzQnlOYW1lLnNldCh0YWcudGFnTmFtZSwgZXhpc3RpbmcgPyBqc2RvYy5tZXJnZShbZXhpc3RpbmcsIHRhZ10pIDogdGFnKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBleHRyYVRhZyBvZiBleHRyYVRhZ3MpIGFkZFRhZyhleHRyYVRhZyk7XG5cbiAgICBjb25zdCBsZW5zID0gZm5EZWNscy5tYXAoZm5EZWNsID0+IGZuRGVjbC5wYXJhbWV0ZXJzLmxlbmd0aCk7XG4gICAgY29uc3QgbWluQXJnc0NvdW50ID0gTWF0aC5taW4oLi4ubGVucyk7XG4gICAgY29uc3QgbWF4QXJnc0NvdW50ID0gTWF0aC5tYXgoLi4ubGVucyk7XG4gICAgY29uc3QgaXNDb25zdHJ1Y3RvciA9IGZuRGVjbHMuZmluZChkID0+IGQua2luZCA9PT0gdHMuU3ludGF4S2luZC5Db25zdHJ1Y3RvcikgIT09IHVuZGVmaW5lZDtcbiAgICAvLyBGb3IgZWFjaCBwYXJhbWV0ZXIgaW5kZXggaSwgcGFyYW1UYWdzW2ldIGlzIGFuIGFycmF5IG9mIHBhcmFtZXRlcnNcbiAgICAvLyB0aGF0IGNhbiBiZSBmb3VuZCBhdCBpbmRleCBpLiAgRS5nLlxuICAgIC8vICAgIGZ1bmN0aW9uIGZvbyh4OiBzdHJpbmcpXG4gICAgLy8gICAgZnVuY3Rpb24gZm9vKHk6IG51bWJlciwgejogc3RyaW5nKVxuICAgIC8vIHRoZW4gcGFyYW1UYWdzWzBdID0gW2luZm8gYWJvdXQgeCwgaW5mbyBhYm91dCB5XS5cbiAgICBjb25zdCBwYXJhbVRhZ3M6IGpzZG9jLlRhZ1tdW10gPSBbXTtcbiAgICBjb25zdCByZXR1cm5UYWdzOiBqc2RvYy5UYWdbXSA9IFtdO1xuICAgIGNvbnN0IHR5cGVQYXJhbWV0ZXJOYW1lcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXG4gICAgbGV0IHRoaXNSZXR1cm5UeXBlOiB0cy5UeXBlfG51bGwgPSBudWxsO1xuICAgIGZvciAoY29uc3QgZm5EZWNsIG9mIGZuRGVjbHMpIHtcbiAgICAgIC8vIENvbnN0cnVjdCB0aGUgSlNEb2MgY29tbWVudCBieSByZWFkaW5nIHRoZSBleGlzdGluZyBKU0RvYywgaWZcbiAgICAgIC8vIGFueSwgYW5kIG1lcmdpbmcgaXQgd2l0aCB0aGUga25vd24gdHlwZXMgb2YgdGhlIGZ1bmN0aW9uXG4gICAgICAvLyBwYXJhbWV0ZXJzIGFuZCByZXR1cm4gdHlwZS5cbiAgICAgIGNvbnN0IHRhZ3MgPSB0aGlzLmdldEpTRG9jKGZuRGVjbCwgLyogcmVwb3J0V2FybmluZ3MgKi8gZmFsc2UpO1xuXG4gICAgICAvLyBDb3B5IGFsbCB0aGUgdGFncyBvdGhlciB0aGFuIEBwYXJhbS9AcmV0dXJuIGludG8gdGhlIG5ld1xuICAgICAgLy8gSlNEb2Mgd2l0aG91dCBhbnkgY2hhbmdlOyBAcGFyYW0vQHJldHVybiBhcmUgaGFuZGxlZCBzcGVjaWFsbHkuXG4gICAgICAvLyBUT0RPOiB0aGVyZSBtYXkgYmUgcHJvYmxlbXMgaWYgYW4gYW5ub3RhdGlvbiBkb2Vzbid0IGFwcGx5IHRvIGFsbCBvdmVybG9hZHM7XG4gICAgICAvLyBpcyBpdCB3b3J0aCBjaGVja2luZyBmb3IgdGhpcyBhbmQgZXJyb3Jpbmc/XG4gICAgICBmb3IgKGNvbnN0IHRhZyBvZiB0YWdzKSB7XG4gICAgICAgIGlmICh0YWcudGFnTmFtZSA9PT0gJ3BhcmFtJyB8fCB0YWcudGFnTmFtZSA9PT0gJ3JldHVybicpIGNvbnRpbnVlO1xuICAgICAgICBhZGRUYWcodGFnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZmxhZ3MgPSB0cy5nZXRDb21iaW5lZE1vZGlmaWVyRmxhZ3MoZm5EZWNsKTtcbiAgICAgIC8vIEFkZCBAYWJzdHJhY3Qgb24gXCJhYnN0cmFjdFwiIGRlY2xhcmF0aW9ucy5cbiAgICAgIGlmIChmbGFncyAmIHRzLk1vZGlmaWVyRmxhZ3MuQWJzdHJhY3QpIHtcbiAgICAgICAgYWRkVGFnKHt0YWdOYW1lOiAnYWJzdHJhY3QnfSk7XG4gICAgICB9XG4gICAgICAvLyBBZGQgQHByb3RlY3RlZC9AcHJpdmF0ZSBpZiBwcmVzZW50LlxuICAgICAgaWYgKGZsYWdzICYgdHMuTW9kaWZpZXJGbGFncy5Qcm90ZWN0ZWQpIHtcbiAgICAgICAgYWRkVGFnKHt0YWdOYW1lOiAncHJvdGVjdGVkJ30pO1xuICAgICAgfSBlbHNlIGlmIChmbGFncyAmIHRzLk1vZGlmaWVyRmxhZ3MuUHJpdmF0ZSkge1xuICAgICAgICBhZGRUYWcoe3RhZ05hbWU6ICdwcml2YXRlJ30pO1xuICAgICAgfVxuXG4gICAgICAvLyBBZGQgYW55IEB0ZW1wbGF0ZSB0YWdzLlxuICAgICAgLy8gTXVsdGlwbGUgZGVjbGFyYXRpb25zIHdpdGggdGhlIHNhbWUgdGVtcGxhdGUgdmFyaWFibGUgbmFtZXMgc2hvdWxkIHdvcms6XG4gICAgICAvLyB0aGUgZGVjbGFyYXRpb25zIGdldCB0dXJuZWQgaW50byB1bmlvbiB0eXBlcywgYW5kIENsb3N1cmUgQ29tcGlsZXIgd2lsbCBuZWVkXG4gICAgICAvLyB0byBmaW5kIGEgdW5pb24gd2hlcmUgYWxsIHR5cGUgYXJndW1lbnRzIGFyZSBzYXRpc2ZpZWQuXG4gICAgICBpZiAoZm5EZWNsLnR5cGVQYXJhbWV0ZXJzKSB7XG4gICAgICAgIGZvciAoY29uc3QgdHAgb2YgZm5EZWNsLnR5cGVQYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgdHlwZVBhcmFtZXRlck5hbWVzLmFkZChnZXRJZGVudGlmaWVyVGV4dCh0cC5uYW1lKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIE1lcmdlIHRoZSBwYXJhbWV0ZXJzIGludG8gYSBzaW5nbGUgbGlzdCBvZiBtZXJnZWQgbmFtZXMgYW5kIGxpc3Qgb2YgdHlwZXNcbiAgICAgIGNvbnN0IHNpZyA9IHR5cGVDaGVja2VyLmdldFNpZ25hdHVyZUZyb21EZWNsYXJhdGlvbihmbkRlY2wpO1xuICAgICAgaWYgKCFzaWcgfHwgIXNpZy5kZWNsYXJhdGlvbikgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHNpZ25hdHVyZSAke2ZuRGVjbC5uYW1lfWApO1xuICAgICAgaWYgKHNpZy5kZWNsYXJhdGlvbi5raW5kID09PSB0cy5TeW50YXhLaW5kLkpTRG9jU2lnbmF0dXJlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSlNEb2Mgc2lnbmF0dXJlICR7Zm5EZWNsLm5hbWV9YCk7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpZy5kZWNsYXJhdGlvbi5wYXJhbWV0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtTm9kZSA9IHNpZy5kZWNsYXJhdGlvbi5wYXJhbWV0ZXJzW2ldO1xuXG4gICAgICAgIGNvbnN0IG5hbWUgPSBnZXRQYXJhbWV0ZXJOYW1lKHBhcmFtTm9kZSwgaSk7XG4gICAgICAgIGNvbnN0IGlzVGhpc1BhcmFtID0gbmFtZSA9PT0gJ3RoaXMnO1xuXG4gICAgICAgIGNvbnN0IG5ld1RhZzoganNkb2MuVGFnID0ge1xuICAgICAgICAgIHRhZ05hbWU6IGlzVGhpc1BhcmFtID8gJ3RoaXMnIDogJ3BhcmFtJyxcbiAgICAgICAgICBvcHRpb25hbDogcGFyYW1Ob2RlLmluaXRpYWxpemVyICE9PSB1bmRlZmluZWQgfHwgcGFyYW1Ob2RlLnF1ZXN0aW9uVG9rZW4gIT09IHVuZGVmaW5lZCxcbiAgICAgICAgICBwYXJhbWV0ZXJOYW1lOiBpc1RoaXNQYXJhbSA/IHVuZGVmaW5lZCA6IG5hbWUsXG4gICAgICAgIH07XG5cbiAgICAgICAgbGV0IHR5cGUgPSB0eXBlQ2hlY2tlci5nZXRUeXBlQXRMb2NhdGlvbihwYXJhbU5vZGUpO1xuICAgICAgICBpZiAocGFyYW1Ob2RlLmRvdERvdERvdFRva2VuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBuZXdUYWcucmVzdFBhcmFtID0gdHJ1ZTtcbiAgICAgICAgICAvLyBJbiBUeXBlU2NyaXB0IHlvdSB3cml0ZSBcIi4uLng6IG51bWJlcltdXCIsIGJ1dCBpbiBDbG9zdXJlXG4gICAgICAgICAgLy8geW91IGRvbid0IHdyaXRlIHRoZSBhcnJheTogXCJAcGFyYW0gey4uLm51bWJlcn0geFwiLiAgVW53cmFwXG4gICAgICAgICAgLy8gdGhlIEFycmF5PD4gd3JhcHBlci5cbiAgICAgICAgICBjb25zdCB0eXBlUmVmID0gdHlwZSBhcyB0cy5UeXBlUmVmZXJlbmNlO1xuICAgICAgICAgIGlmICghdHlwZVJlZi50eXBlQXJndW1lbnRzKSB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcmVzdCBwYXJhbScpO1xuICAgICAgICAgIHR5cGUgPSB0eXBlUmVmLnR5cGVBcmd1bWVudHMhWzBdO1xuICAgICAgICB9XG4gICAgICAgIG5ld1RhZy50eXBlID0gdGhpcy50eXBlVG9DbG9zdXJlKGZuRGVjbCwgdHlwZSk7XG5cbiAgICAgICAgZm9yIChjb25zdCB7dGFnTmFtZSwgcGFyYW1ldGVyTmFtZSwgdGV4dH0gb2YgdGFncykge1xuICAgICAgICAgIGlmICh0YWdOYW1lID09PSAncGFyYW0nICYmIHBhcmFtZXRlck5hbWUgPT09IG5ld1RhZy5wYXJhbWV0ZXJOYW1lKSB7XG4gICAgICAgICAgICBuZXdUYWcudGV4dCA9IHRleHQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXJhbVRhZ3NbaV0pIHBhcmFtVGFncy5wdXNoKFtdKTtcbiAgICAgICAgcGFyYW1UYWdzW2ldLnB1c2gobmV3VGFnKTtcbiAgICAgIH1cblxuICAgICAgLy8gUmV0dXJuIHR5cGUuXG4gICAgICBpZiAoIWlzQ29uc3RydWN0b3IpIHtcbiAgICAgICAgY29uc3QgcmV0dXJuVGFnOiBqc2RvYy5UYWcgPSB7XG4gICAgICAgICAgdGFnTmFtZTogJ3JldHVybicsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJldFR5cGUgPSB0eXBlQ2hlY2tlci5nZXRSZXR1cm5UeXBlT2ZTaWduYXR1cmUoc2lnKTtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueSBhY2Nlc3NpbmcgVFMgaW50ZXJuYWwgZmllbGQuXG4gICAgICAgIGlmICgocmV0VHlwZSBhcyBhbnkpLmlzVGhpc1R5cGUpIHtcbiAgICAgICAgICAvLyBmb28oKTogdGhpc1xuICAgICAgICAgIHRoaXNSZXR1cm5UeXBlID0gcmV0VHlwZTtcbiAgICAgICAgICBhZGRUYWcoe3RhZ05hbWU6ICd0ZW1wbGF0ZScsIHRleHQ6ICdUSElTJ30pO1xuICAgICAgICAgIGFkZFRhZyh7dGFnTmFtZTogJ3RoaXMnLCB0eXBlOiAnVEhJUyd9KTtcbiAgICAgICAgICByZXR1cm5UYWcudHlwZSA9ICdUSElTJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm5UYWcudHlwZSA9IHRoaXMudHlwZVRvQ2xvc3VyZShmbkRlY2wsIHJldFR5cGUpO1xuICAgICAgICAgIGZvciAoY29uc3Qge3RhZ05hbWUsIHRleHR9IG9mIHRhZ3MpIHtcbiAgICAgICAgICAgIGlmICh0YWdOYW1lID09PSAncmV0dXJuJykge1xuICAgICAgICAgICAgICByZXR1cm5UYWcudGV4dCA9IHRleHQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm5UYWdzLnB1c2gocmV0dXJuVGFnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZVBhcmFtZXRlck5hbWVzLnNpemUgPiAwKSB7XG4gICAgICBhZGRUYWcoe3RhZ05hbWU6ICd0ZW1wbGF0ZScsIHRleHQ6IEFycmF5LmZyb20odHlwZVBhcmFtZXRlck5hbWVzLnZhbHVlcygpKS5qb2luKCcsICcpfSk7XG4gICAgfVxuXG4gICAgY29uc3QgbmV3RG9jID0gQXJyYXkuZnJvbSh0YWdzQnlOYW1lLnZhbHVlcygpKTtcblxuICAgIC8vIE1lcmdlIHRoZSBKU0RvYyB0YWdzIGZvciBlYWNoIG92ZXJsb2FkZWQgcGFyYW1ldGVyLlxuICAgIC8vIEVuc3VyZSBlYWNoIHBhcmFtZXRlciBoYXMgYSB1bmlxdWUgbmFtZTsgdGhlIG1lcmdpbmcgcHJvY2VzcyBjYW4gb3RoZXJ3aXNlXG4gICAgLy8gYWNjaWRlbnRhbGx5IGdlbmVyYXRlIHRoZSBzYW1lIHBhcmFtZXRlciBuYW1lIHR3aWNlLlxuICAgIGNvbnN0IHBhcmFtTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgbGV0IGZvdW5kT3B0aW9uYWwgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1heEFyZ3NDb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBwYXJhbVRhZyA9IGpzZG9jLm1lcmdlKHBhcmFtVGFnc1tpXSk7XG4gICAgICBpZiAocGFyYW1OYW1lcy5oYXMocGFyYW1UYWcucGFyYW1ldGVyTmFtZSkpIHtcbiAgICAgICAgcGFyYW1UYWcucGFyYW1ldGVyTmFtZSArPSBpLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICBwYXJhbU5hbWVzLmFkZChwYXJhbVRhZy5wYXJhbWV0ZXJOYW1lKTtcbiAgICAgIC8vIElmIHRoZSB0YWcgaXMgb3B0aW9uYWwsIG1hcmsgcGFyYW1ldGVycyBmb2xsb3dpbmcgb3B0aW9uYWwgYXMgb3B0aW9uYWwsXG4gICAgICAvLyBldmVuIGlmIHRoZXkgYXJlIG5vdCwgc2luY2UgQ2xvc3VyZSByZXN0cmljdHMgdGhpcywgc2VlXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL2Nsb3N1cmUtY29tcGlsZXIvaXNzdWVzLzIzMTRcbiAgICAgIGlmICghcGFyYW1UYWcucmVzdFBhcmFtICYmIChwYXJhbVRhZy5vcHRpb25hbCB8fCBmb3VuZE9wdGlvbmFsIHx8IGkgPj0gbWluQXJnc0NvdW50KSkge1xuICAgICAgICBmb3VuZE9wdGlvbmFsID0gdHJ1ZTtcbiAgICAgICAgcGFyYW1UYWcub3B0aW9uYWwgPSB0cnVlO1xuICAgICAgfVxuICAgICAgbmV3RG9jLnB1c2gocGFyYW1UYWcpO1xuICAgICAgaWYgKHBhcmFtVGFnLnJlc3RQYXJhbSkge1xuICAgICAgICAvLyBDYW5ub3QgaGF2ZSBhbnkgcGFyYW1ldGVycyBhZnRlciBhIHJlc3QgcGFyYW0uXG4gICAgICAgIC8vIEp1c3QgZHVtcCB0aGUgcmVtYWluaW5nIHBhcmFtZXRlcnMuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1lcmdlIHRoZSBKU0RvYyB0YWdzIGZvciBlYWNoIG92ZXJsb2FkZWQgcmV0dXJuLlxuICAgIGlmICghaXNDb25zdHJ1Y3Rvcikge1xuICAgICAgbmV3RG9jLnB1c2goanNkb2MubWVyZ2UocmV0dXJuVGFncykpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0YWdzOiBuZXdEb2MsXG4gICAgICBwYXJhbWV0ZXJOYW1lczogbmV3RG9jLmZpbHRlcih0ID0+IHQudGFnTmFtZSA9PT0gJ3BhcmFtJykubWFwKHQgPT4gdC5wYXJhbWV0ZXJOYW1lISksXG4gICAgICB0aGlzUmV0dXJuVHlwZSxcbiAgICB9O1xuICB9XG59XG4iXX0=