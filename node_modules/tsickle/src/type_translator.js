/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("tsickle/src/type_translator", ["require", "exports", "path", "typescript", "tsickle/src/annotator_host", "tsickle/src/transformer_util"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var path = require("path");
    var ts = require("typescript");
    var annotator_host_1 = require("tsickle/src/annotator_host");
    var transformer_util_1 = require("tsickle/src/transformer_util");
    /**
     * TypeScript allows you to write identifiers quoted, like:
     *   interface Foo {
     *     'bar': string;
     *     'complex name': string;
     *   }
     *   Foo.bar;  // ok
     *   Foo['bar']  // ok
     *   Foo['complex name']  // ok
     *
     * In Closure-land, we want identify that the legal name 'bar' can become an
     * ordinary field, but we need to skip strings like 'complex name'.
     */
    function isValidClosurePropertyName(name) {
        // In local experimentation, it appears that reserved words like 'var' and
        // 'if' are legal JS and still accepted by Closure.
        return /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(name);
    }
    exports.isValidClosurePropertyName = isValidClosurePropertyName;
    /**
     * Determines if fileName refers to a builtin lib.d.ts file.
     * This is a terrible hack but it mirrors a similar thing done in Clutz.
     */
    function isBuiltinLibDTS(fileName) {
        return fileName.match(/\blib\.(?:[^/]+\.)?d\.ts$/) != null;
    }
    exports.isBuiltinLibDTS = isBuiltinLibDTS;
    /**
     * @return True if the named type is considered compatible with the Closure-defined
     *     type of the same name, e.g. "Array".  Note that we don't actually enforce
     *     that the types are actually compatible, but mostly just hope that they are due
     *     to being derived from the same HTML specs.
     */
    function isClosureProvidedType(symbol) {
        return symbol.declarations != null &&
            symbol.declarations.some(function (n) { return isBuiltinLibDTS(n.getSourceFile().fileName); });
    }
    function typeToDebugString(type) {
        var e_1, _a, e_2, _b;
        var debugString = "flags:0x" + type.flags.toString(16);
        if (type.aliasSymbol) {
            debugString += " alias:" + symbolToDebugString(type.aliasSymbol);
        }
        if (type.aliasTypeArguments) {
            debugString += " aliasArgs:<" + type.aliasTypeArguments.map(typeToDebugString).join(',') + ">";
        }
        // Just the unique flags (powers of two). Declared in src/compiler/types.ts.
        var basicTypes = [
            ts.TypeFlags.Any, ts.TypeFlags.String, ts.TypeFlags.Number,
            ts.TypeFlags.Boolean, ts.TypeFlags.Enum, ts.TypeFlags.StringLiteral,
            ts.TypeFlags.NumberLiteral, ts.TypeFlags.BooleanLiteral, ts.TypeFlags.EnumLiteral,
            ts.TypeFlags.ESSymbol, ts.TypeFlags.UniqueESSymbol, ts.TypeFlags.Void,
            ts.TypeFlags.Undefined, ts.TypeFlags.Null, ts.TypeFlags.Never,
            ts.TypeFlags.TypeParameter, ts.TypeFlags.Object, ts.TypeFlags.Union,
            ts.TypeFlags.Intersection, ts.TypeFlags.Index, ts.TypeFlags.IndexedAccess,
            ts.TypeFlags.Conditional, ts.TypeFlags.Substitution,
        ];
        try {
            for (var basicTypes_1 = __values(basicTypes), basicTypes_1_1 = basicTypes_1.next(); !basicTypes_1_1.done; basicTypes_1_1 = basicTypes_1.next()) {
                var flag = basicTypes_1_1.value;
                if ((type.flags & flag) !== 0) {
                    debugString += " " + ts.TypeFlags[flag];
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (basicTypes_1_1 && !basicTypes_1_1.done && (_a = basicTypes_1.return)) _a.call(basicTypes_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        if (type.flags === ts.TypeFlags.Object) {
            var objType = type;
            debugString += " objectFlags:0x" + objType.objectFlags;
            // Just the unique flags (powers of two). Declared in src/compiler/types.ts.
            var objectFlags = [
                ts.ObjectFlags.Class,
                ts.ObjectFlags.Interface,
                ts.ObjectFlags.Reference,
                ts.ObjectFlags.Tuple,
                ts.ObjectFlags.Anonymous,
                ts.ObjectFlags.Mapped,
                ts.ObjectFlags.Instantiated,
                ts.ObjectFlags.ObjectLiteral,
                ts.ObjectFlags.EvolvingArray,
                ts.ObjectFlags.ObjectLiteralPatternWithComputedProperties,
            ];
            try {
                for (var objectFlags_1 = __values(objectFlags), objectFlags_1_1 = objectFlags_1.next(); !objectFlags_1_1.done; objectFlags_1_1 = objectFlags_1.next()) {
                    var flag = objectFlags_1_1.value;
                    if ((objType.objectFlags & flag) !== 0) {
                        debugString += " object:" + ts.ObjectFlags[flag];
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (objectFlags_1_1 && !objectFlags_1_1.done && (_b = objectFlags_1.return)) _b.call(objectFlags_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
        if (type.symbol && type.symbol.name !== '__type') {
            debugString += " symbol.name:" + JSON.stringify(type.symbol.name);
        }
        if (type.pattern) {
            debugString += " destructuring:true";
        }
        return "{type " + debugString + "}";
    }
    exports.typeToDebugString = typeToDebugString;
    function symbolToDebugString(sym) {
        var e_3, _a;
        var debugString = JSON.stringify(sym.name) + " flags:0x" + sym.flags.toString(16);
        // Just the unique flags (powers of two). Declared in src/compiler/types.ts.
        var symbolFlags = [
            ts.SymbolFlags.FunctionScopedVariable,
            ts.SymbolFlags.BlockScopedVariable,
            ts.SymbolFlags.Property,
            ts.SymbolFlags.EnumMember,
            ts.SymbolFlags.Function,
            ts.SymbolFlags.Class,
            ts.SymbolFlags.Interface,
            ts.SymbolFlags.ConstEnum,
            ts.SymbolFlags.RegularEnum,
            ts.SymbolFlags.ValueModule,
            ts.SymbolFlags.NamespaceModule,
            ts.SymbolFlags.TypeLiteral,
            ts.SymbolFlags.ObjectLiteral,
            ts.SymbolFlags.Method,
            ts.SymbolFlags.Constructor,
            ts.SymbolFlags.GetAccessor,
            ts.SymbolFlags.SetAccessor,
            ts.SymbolFlags.Signature,
            ts.SymbolFlags.TypeParameter,
            ts.SymbolFlags.TypeAlias,
            ts.SymbolFlags.ExportValue,
            ts.SymbolFlags.Alias,
            ts.SymbolFlags.Prototype,
            ts.SymbolFlags.ExportStar,
            ts.SymbolFlags.Optional,
            ts.SymbolFlags.Transient,
        ];
        try {
            for (var symbolFlags_1 = __values(symbolFlags), symbolFlags_1_1 = symbolFlags_1.next(); !symbolFlags_1_1.done; symbolFlags_1_1 = symbolFlags_1.next()) {
                var flag = symbolFlags_1_1.value;
                if ((sym.flags & flag) !== 0) {
                    debugString += " " + ts.SymbolFlags[flag];
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (symbolFlags_1_1 && !symbolFlags_1_1.done && (_a = symbolFlags_1.return)) _a.call(symbolFlags_1);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return debugString;
    }
    exports.symbolToDebugString = symbolToDebugString;
    /**
     * Searches for an ambient module declaration in the ancestors of declarations, depth first, and
     * returns the first or null if none found.
     */
    function getContainingAmbientModuleDeclaration(declarations) {
        var e_4, _a;
        try {
            for (var declarations_1 = __values(declarations), declarations_1_1 = declarations_1.next(); !declarations_1_1.done; declarations_1_1 = declarations_1.next()) {
                var declaration = declarations_1_1.value;
                var parent_1 = declaration.parent;
                while (parent_1) {
                    if (ts.isModuleDeclaration(parent_1) && ts.isStringLiteral(parent_1.name)) {
                        return parent_1;
                    }
                    parent_1 = parent_1.parent;
                }
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (declarations_1_1 && !declarations_1_1.done && (_a = declarations_1.return)) _a.call(declarations_1);
            }
            finally { if (e_4) throw e_4.error; }
        }
        return null;
    }
    /** Returns true if any of declarations is a top level declaration in an external module. */
    function isTopLevelExternal(declarations) {
        var e_5, _a;
        try {
            for (var declarations_2 = __values(declarations), declarations_2_1 = declarations_2.next(); !declarations_2_1.done; declarations_2_1 = declarations_2.next()) {
                var declaration = declarations_2_1.value;
                if (declaration.parent === undefined)
                    continue;
                if (ts.isSourceFile(declaration.parent) && ts.isExternalModule(declaration.parent))
                    return true;
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (declarations_2_1 && !declarations_2_1.done && (_a = declarations_2.return)) _a.call(declarations_2);
            }
            finally { if (e_5) throw e_5.error; }
        }
        return false;
    }
    /**
     * Returns true if a and b are (or were originally before transformation) nodes of the same source
     * file.
     */
    function isDeclaredInSameFile(a, b) {
        return ts.getOriginalNode(a).getSourceFile() === ts.getOriginalNode(b).getSourceFile();
    }
    /** TypeTranslator translates TypeScript types to Closure types. */
    var TypeTranslator = /** @class */ (function () {
        /**
         * @param node is the source AST ts.Node the type comes from.  This is used
         *     in some cases (e.g. anonymous types) for looking up field names.
         * @param pathBlackList is a set of paths that should never get typed;
         *     any reference to symbols defined in these paths should by typed
         *     as {?}.
         * @param symbolsToAliasedNames a mapping from symbols (`Foo`) to a name in scope they should be
         *     emitted as (e.g. `tsickle_forward_declare_1.Foo`). Can be augmented during type
         *     translation, e.g. to blacklist a symbol.
         */
        function TypeTranslator(host, typeChecker, node, pathBlackList, symbolsToAliasedNames, ensureSymbolDeclared) {
            if (symbolsToAliasedNames === void 0) { symbolsToAliasedNames = new Map(); }
            if (ensureSymbolDeclared === void 0) { ensureSymbolDeclared = function () { }; }
            this.host = host;
            this.typeChecker = typeChecker;
            this.node = node;
            this.pathBlackList = pathBlackList;
            this.symbolsToAliasedNames = symbolsToAliasedNames;
            this.ensureSymbolDeclared = ensureSymbolDeclared;
            /**
             * A list of type literals we've encountered while emitting; used to avoid getting stuck in
             * recursive types.
             */
            this.seenAnonymousTypes = new Set();
            /**
             * Whether to write types suitable for an \@externs file. Externs types must not refer to
             * non-externs types (i.e. non ambient types) and need to use fully qualified names.
             */
            this.isForExterns = false;
            // Normalize paths to not break checks on Windows.
            if (this.pathBlackList != null) {
                this.pathBlackList =
                    new Set(Array.from(this.pathBlackList.values()).map(function (p) { return path.normalize(p); }));
            }
        }
        /**
         * Converts a ts.Symbol to a string, applying aliases and ensuring symbols are imported.
         * @return a string representation of the symbol as a valid Closure type name, or `undefined` if
         *     the type cannot be expressed (e.g. for anonymous types).
         */
        TypeTranslator.prototype.symbolToString = function (sym) {
            var _this = this;
            // TypeScript resolves e.g. union types to their members, which can include symbols not declared
            // in the current scope. Ensure that all symbols found this way are actually declared.
            // This must happen before the alias check below, it might introduce a new alias for the symbol.
            if (!this.isForExterns && (sym.flags & ts.SymbolFlags.TypeParameter) === 0) {
                this.ensureSymbolDeclared(sym);
            }
            var name = this.typeChecker.symbolToEntityName(sym, ts.SymbolFlags.None, this.node, ts.NodeBuilderFlags.UseFullyQualifiedType);
            // name might be undefined, e.g. for anonymous classes.
            if (!name)
                return undefined;
            var str = '';
            /** Recursively visits components of entity name and writes them to `str` above. */
            var writeEntityWithSymbols = function (name) {
                var identifier;
                if (ts.isQualifiedName(name)) {
                    writeEntityWithSymbols(name.left);
                    str += '.';
                    identifier = name.right;
                }
                else {
                    identifier = name;
                }
                var symbol = identifier.symbol;
                // When writing a symbol, check if there is an alias for it in the current scope that should
                // take precedence, e.g. from a goog.forwardDeclare.
                if (symbol.flags & ts.SymbolFlags.Alias) {
                    symbol = _this.typeChecker.getAliasedSymbol(symbol);
                }
                var alias = _this.symbolsToAliasedNames.get(symbol);
                if (alias) {
                    // If so, discard the entire current text and only use the alias - otherwise if a symbol has
                    // a local alias but appears in a dotted type path (e.g. when it's imported using import *
                    // as foo), str would contain both the prefx *and* the full alias (foo.alias.name).
                    str = alias;
                    return;
                }
                var text = transformer_util_1.getIdentifierText(identifier);
                if (str.length === 0) {
                    var mangledPrefix = _this.maybeGetMangledNamePrefix(symbol);
                    text = mangledPrefix + text;
                }
                str += text;
            };
            writeEntityWithSymbols(name);
            return this.stripClutzNamespace(str);
        };
        /**
         * Returns the mangled name prefix for symbol, or an empty string if not applicable.
         *
         * Type names are emitted with a mangled prefix if they are top level symbols declared in an
         * external module (.d.ts or .ts), and are ambient declarations ("declare ..."). This is because
         * their declarations get moved to externs files (to make external names visible to Closure and
         * prevent renaming), which only use global names. This means the names must be mangled to prevent
         * collisions and allow referencing them uniquely.
         *
         * This method also handles the special case of symbols declared in an ambient external module
         * context.
         *
         * Symbols declared in a global block, e.g. "declare global { type X; }", are handled implicitly:
         * when referenced, they are written as just "X", which is not a top level declaration, so the
         * code below ignores them.
         */
        TypeTranslator.prototype.maybeGetMangledNamePrefix = function (symbol) {
            var _this = this;
            if (!symbol.declarations)
                return '';
            var declarations = symbol.declarations;
            var ambientModuleDeclaration = null;
            // If the symbol is neither a top level declaration in an external module nor in an ambient
            // block, tsickle should not emit a prefix: it's either not an external symbol, or it's an
            // external symbol nested in a module, so it will need to be qualified, and the mangling prefix
            // goes on the qualifier.
            if (!isTopLevelExternal(declarations)) {
                ambientModuleDeclaration = getContainingAmbientModuleDeclaration(declarations);
                if (!ambientModuleDeclaration)
                    return '';
            }
            // At this point, the declaration is from an external module (possibly ambient).
            // These declarations must be prefixed if either:
            // (a) tsickle is emitting an externs file, so all symbols are qualified within it
            // (b) or the declaration must be an exported ambient declaration from the local file.
            // Ambient external declarations from other files are imported, so there's a local alias for the
            // module and no mangling is needed.
            if (!this.isForExterns &&
                !declarations.every(function (d) { return isDeclaredInSameFile(_this.node, d) && transformer_util_1.isAmbient(d) &&
                    transformer_util_1.hasModifierFlag(d, ts.ModifierFlags.Export); })) {
                return '';
            }
            // If from an ambient declaration, use and resolve the name from that. Otherwise, use the file
            // name from the (arbitrary) first declaration to mangle.
            var fileName = ambientModuleDeclaration ?
                ambientModuleDeclaration.name.text :
                ts.getOriginalNode(declarations[0]).getSourceFile().fileName;
            var mangled = annotator_host_1.moduleNameAsIdentifier(this.host, fileName);
            return mangled + '.';
        };
        // Clutz (https://github.com/angular/clutz) emits global type symbols hidden in a special
        // ಠ_ಠ.clutz namespace. While most code seen by Tsickle will only ever see local aliases, Clutz
        // symbols can be written by users directly in code, and they can appear by dereferencing
        // TypeAliases. The code below simply strips the prefix, the remaining type name then matches
        // Closure's type.
        TypeTranslator.prototype.stripClutzNamespace = function (name) {
            if (name.startsWith('ಠ_ಠ.clutz.'))
                return name.substring('ಠ_ಠ.clutz.'.length);
            return name;
        };
        TypeTranslator.prototype.translate = function (type) {
            // NOTE: Though type.flags has the name "flags", it usually can only be one
            // of the enum options at a time (except for unions of literal types, e.g. unions of boolean
            // values, string values, enum values). This switch handles all the cases in the ts.TypeFlags
            // enum in the order they occur.
            var e_6, _a;
            // NOTE: Some TypeFlags are marked "internal" in the d.ts but still show up in the value of
            // type.flags. This mask limits the flag checks to the ones in the public API. "lastFlag" here
            // is the last flag handled in this switch statement, and should be kept in sync with
            // typescript.d.ts.
            // NonPrimitive occurs on its own on the lower case "object" type. Special case to "!Object".
            if (type.flags === ts.TypeFlags.NonPrimitive)
                return '!Object';
            // Avoid infinite loops on recursive type literals.
            // It would be nice to just emit the name of the recursive type here (in type.aliasSymbol
            // below), but Closure Compiler does not allow recursive type definitions.
            if (this.seenAnonymousTypes.has(type))
                return '?';
            var isAmbient = false;
            var isInNamespace = false;
            var isModule = false;
            if (type.symbol) {
                try {
                    for (var _b = __values(type.symbol.declarations || []), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var decl = _c.value;
                        if (ts.isExternalModule(decl.getSourceFile()))
                            isModule = true;
                        var current = decl;
                        while (current) {
                            if (ts.getCombinedModifierFlags(current) & ts.ModifierFlags.Ambient)
                                isAmbient = true;
                            if (current.kind === ts.SyntaxKind.ModuleDeclaration)
                                isInNamespace = true;
                            current = current.parent;
                        }
                    }
                }
                catch (e_6_1) { e_6 = { error: e_6_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_6) throw e_6.error; }
                }
            }
            // tsickle cannot generate types for non-ambient namespaces nor any symbols contained in them.
            if (isInNamespace && !isAmbient)
                return '?';
            // Types in externs cannot reference types from external modules.
            // However ambient types in modules get moved to externs, too, so type references work and we
            // can emit a precise type.
            if (this.isForExterns && isModule && !isAmbient)
                return '?';
            var lastFlag = ts.TypeFlags.Substitution;
            var mask = (lastFlag << 1) - 1;
            switch (type.flags & mask) {
                case ts.TypeFlags.Any:
                    return '?';
                case ts.TypeFlags.String:
                case ts.TypeFlags.StringLiteral:
                    return 'string';
                case ts.TypeFlags.Number:
                case ts.TypeFlags.NumberLiteral:
                    return 'number';
                case ts.TypeFlags.Boolean:
                case ts.TypeFlags.BooleanLiteral:
                    // See the note in translateUnion about booleans.
                    return 'boolean';
                case ts.TypeFlags.Enum:
                    if (!type.symbol) {
                        this.warn("EnumType without a symbol");
                        return '?';
                    }
                    return this.symbolToString(type.symbol) || '?';
                case ts.TypeFlags.ESSymbol:
                case ts.TypeFlags.UniqueESSymbol:
                    // ESSymbol indicates something typed symbol.
                    // UniqueESSymbol indicates a specific unique symbol, used e.g. to index into an object.
                    // Closure does not have this distinction, so tsickle emits both as 'symbol'.
                    return 'symbol';
                case ts.TypeFlags.Void:
                    return 'void';
                case ts.TypeFlags.Undefined:
                    return 'undefined';
                case ts.TypeFlags.Null:
                    return 'null';
                case ts.TypeFlags.Never:
                    this.warn("should not emit a 'never' type");
                    return '?';
                case ts.TypeFlags.TypeParameter:
                    // This is e.g. the T in a type like Foo<T>.
                    if (!type.symbol) {
                        this.warn("TypeParameter without a symbol"); // should not happen (tm)
                        return '?';
                    }
                    // In Closure, type parameters ("<T>") are non-nullable by default, unlike references to
                    // classes or interfaces. However this code path can be reached by bound type parameters,
                    // where the type parameter's symbol references a plain class or interface. In this case,
                    // add `!` to avoid emitting a nullable type.
                    var prefix = '';
                    if ((type.symbol.flags & ts.SymbolFlags.TypeParameter) === 0) {
                        prefix = '!';
                    }
                    var name_1 = this.symbolToString(type.symbol);
                    if (!name_1)
                        return '?';
                    return prefix + name_1;
                case ts.TypeFlags.Object:
                    return this.translateObject(type);
                case ts.TypeFlags.Union:
                    return this.translateUnion(type);
                case ts.TypeFlags.Conditional:
                case ts.TypeFlags.Substitution:
                    this.warn("emitting ? for conditional/substitution type");
                    return '?';
                case ts.TypeFlags.Intersection:
                case ts.TypeFlags.Index:
                case ts.TypeFlags.IndexedAccess:
                    // TODO(ts2.1): handle these special types.
                    this.warn("unhandled type flags: " + ts.TypeFlags[type.flags]);
                    return '?';
                default:
                    // Handle cases where multiple flags are set.
                    // Types with literal members are represented as
                    //   ts.TypeFlags.Union | [literal member]
                    // E.g. an enum typed value is a union type with the enum's members as its members. A
                    // boolean type is a union type with 'true' and 'false' as its members.
                    // Note also that in a more complex union, e.g. boolean|number, then it's a union of three
                    // things (true|false|number) and ts.TypeFlags.Boolean doesn't show up at all.
                    if (type.flags & ts.TypeFlags.Union) {
                        return this.translateUnion(type);
                    }
                    if (type.flags & ts.TypeFlags.EnumLiteral) {
                        return this.translateEnumLiteral(type);
                    }
                    // The switch statement should have been exhaustive.
                    throw new Error("unknown type flags " + type.flags + " on " + typeToDebugString(type));
            }
        };
        TypeTranslator.prototype.translateUnion = function (type) {
            var _this = this;
            var parts = type.types.map(function (t) { return _this.translate(t); });
            // Union types that include literals (e.g. boolean, enum) can end up repeating the same Closure
            // type. For example: true | boolean will be translated to boolean | boolean.
            // Remove duplicates to produce types that read better.
            parts = parts.filter(function (el, idx) { return parts.indexOf(el) === idx; });
            return parts.length === 1 ? parts[0] : "(" + parts.join('|') + ")";
        };
        TypeTranslator.prototype.translateEnumLiteral = function (type) {
            // Suppose you had:
            //   enum EnumType { MEMBER }
            // then the type of "EnumType.MEMBER" is an enum literal (the thing passed to this function)
            // and it has type flags that include
            //   ts.TypeFlags.NumberLiteral | ts.TypeFlags.EnumLiteral
            //
            // Closure Compiler doesn't support literals in types, so this code must not emit
            // "EnumType.MEMBER", but rather "EnumType".
            var enumLiteralBaseType = this.typeChecker.getBaseTypeOfLiteralType(type);
            if (!enumLiteralBaseType.symbol) {
                this.warn("EnumLiteralType without a symbol");
                return '?';
            }
            return this.symbolToString(enumLiteralBaseType.symbol) || '?';
        };
        // translateObject translates a ts.ObjectType, which is the type of all
        // object-like things in TS, such as classes and interfaces.
        TypeTranslator.prototype.translateObject = function (type) {
            var _this = this;
            if (type.symbol && this.isBlackListed(type.symbol))
                return '?';
            // NOTE: objectFlags is an enum, but a given type can have multiple flags.
            // Array<string> is both ts.ObjectFlags.Reference and ts.ObjectFlags.Interface.
            if (type.objectFlags & ts.ObjectFlags.Class) {
                if (!type.symbol) {
                    this.warn('class has no symbol');
                    return '?';
                }
                var name_2 = this.symbolToString(type.symbol);
                if (!name_2) {
                    // An anonymous type. Make sure not to emit '!?', as that is a syntax error in Closure
                    // Compiler.
                    return '?';
                }
                return '!' + name_2;
            }
            else if (type.objectFlags & ts.ObjectFlags.Interface) {
                // Note: ts.InterfaceType has a typeParameters field, but that
                // specifies the parameters that the interface type *expects*
                // when it's used, and should not be transformed to the output.
                // E.g. a type like Array<number> is a TypeReference to the
                // InterfaceType "Array", but the "number" type parameter is
                // part of the outer TypeReference, not a typeParameter on
                // the InterfaceType.
                if (!type.symbol) {
                    this.warn('interface has no symbol');
                    return '?';
                }
                if (type.symbol.flags & ts.SymbolFlags.Value) {
                    // The symbol is both a type and a value.
                    // For user-defined types in this state, we don't have a Closure name
                    // for the type.  See the type_and_value test.
                    if (!isClosureProvidedType(type.symbol)) {
                        this.warn("type/symbol conflict for " + type.symbol.name + ", using {?} for now");
                        return '?';
                    }
                }
                return '!' + this.symbolToString(type.symbol);
            }
            else if (type.objectFlags & ts.ObjectFlags.Reference) {
                // A reference to another type, e.g. Array<number> refers to Array.
                // Emit the referenced type and any type arguments.
                var referenceType = type;
                // A tuple is a ReferenceType where the target is flagged Tuple and the
                // typeArguments are the tuple arguments.  Just treat it as a mystery
                // array, because Closure doesn't understand tuples.
                if (referenceType.target.objectFlags & ts.ObjectFlags.Tuple) {
                    return '!Array<?>';
                }
                var typeStr = '';
                if (referenceType.target === referenceType) {
                    // We get into an infinite loop here if the inner reference is
                    // the same as the outer; this can occur when this function
                    // fails to translate a more specific type before getting to
                    // this point.
                    throw new Error("reference loop in " + typeToDebugString(referenceType) + " " + referenceType.flags);
                }
                typeStr += this.translate(referenceType.target);
                // Translate can return '?' for a number of situations, e.g. type/value conflicts.
                // `?<?>` is illegal syntax in Closure Compiler, so just return `?` here.
                if (typeStr === '?')
                    return '?';
                if (referenceType.typeArguments) {
                    var params = referenceType.typeArguments.map(function (t) { return _this.translate(t); });
                    typeStr += "<" + params.join(', ') + ">";
                }
                return typeStr;
            }
            else if (type.objectFlags & ts.ObjectFlags.Anonymous) {
                if (!type.symbol) {
                    // This comes up when generating code for an arrow function as passed
                    // to a generic function.  The passed-in type is tagged as anonymous
                    // and has no properties so it's hard to figure out what to generate.
                    // Just avoid it for now so we don't crash.
                    this.warn('anonymous type has no symbol');
                    return '?';
                }
                if (type.symbol.flags & ts.SymbolFlags.Function ||
                    type.symbol.flags & ts.SymbolFlags.Method) {
                    var sigs = this.typeChecker.getSignaturesOfType(type, ts.SignatureKind.Call);
                    if (sigs.length === 1) {
                        return this.signatureToClosure(sigs[0]);
                    }
                    this.warn('unhandled anonymous type with multiple call signatures');
                    return '?';
                }
                else {
                    return this.translateAnonymousType(type);
                }
            }
            /*
            TODO(ts2.1): more unhandled object type flags:
              Tuple
              Mapped
              Instantiated
              ObjectLiteral
              EvolvingArray
              ObjectLiteralPatternWithComputedProperties
            */
            this.warn("unhandled type " + typeToDebugString(type));
            return '?';
        };
        /**
         * translateAnonymousType translates a ts.TypeFlags.ObjectType that is also
         * ts.ObjectFlags.Anonymous. That is, this type's symbol does not have a name. This is the
         * anonymous type encountered in e.g.
         *     let x: {a: number};
         * But also the inferred type in:
         *     let x = {a: 1};  // type of x is {a: number}, as above
         */
        TypeTranslator.prototype.translateAnonymousType = function (type) {
            var e_7, _a;
            this.seenAnonymousTypes.add(type);
            // Gather up all the named fields and whether the object is also callable.
            var callable = false;
            var indexable = false;
            var fields = [];
            if (!type.symbol || !type.symbol.members) {
                this.warn('anonymous type has no symbol');
                return '?';
            }
            // special-case construct signatures.
            var ctors = type.getConstructSignatures();
            if (ctors.length) {
                // TODO(martinprobst): this does not support additional properties defined on constructors
                // (not expressible in Closure), nor multiple constructors (same).
                var decl = ctors[0].declaration;
                if (!decl) {
                    this.warn('unhandled anonymous type with constructor signature but no declaration');
                    return '?';
                }
                if (decl.kind === ts.SyntaxKind.JSDocSignature) {
                    this.warn('unhandled JSDoc based constructor signature');
                    return '?';
                }
                // new <T>(tee: T) is not supported by Closure, blacklist as ?.
                this.blacklistTypeParameters(this.symbolsToAliasedNames, decl.typeParameters);
                var params = this.convertParams(ctors[0], decl.parameters);
                var paramsStr = params.length ? (', ' + params.join(', ')) : '';
                var constructedType = this.translate(ctors[0].getReturnType());
                // In the specific case of the "new" in a function, it appears that
                //   function(new: !Bar)
                // fails to parse, while
                //   function(new: (!Bar))
                // parses in the way you'd expect.
                // It appears from testing that Closure ignores the ! anyway and just
                // assumes the result will be non-null in either case.  (To be pedantic,
                // it's possible to return null from a ctor it seems like a bad idea.)
                return "function(new: (" + constructedType + ")" + paramsStr + "): ?";
            }
            try {
                // members is an ES6 map, but the .d.ts defining it defined their own map
                // type, so typescript doesn't believe that .keys() is iterable
                // tslint:disable-next-line:no-any
                for (var _b = __values(type.symbol.members.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var field = _c.value;
                    switch (field) {
                        case '__call':
                            callable = true;
                            break;
                        case '__index':
                            indexable = true;
                            break;
                        default:
                            if (!isValidClosurePropertyName(field)) {
                                this.warn("omitting inexpressible property name: " + field);
                                continue;
                            }
                            var member = type.symbol.members.get(field);
                            // optional members are handled by the type including |undefined in a union type.
                            var memberType = this.translate(this.typeChecker.getTypeOfSymbolAtLocation(member, this.node));
                            fields.push(field + ": " + memberType);
                            break;
                    }
                }
            }
            catch (e_7_1) { e_7 = { error: e_7_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_7) throw e_7.error; }
            }
            // Try to special-case plain key-value objects and functions.
            if (fields.length === 0) {
                if (callable && !indexable) {
                    // A function type.
                    var sigs = this.typeChecker.getSignaturesOfType(type, ts.SignatureKind.Call);
                    if (sigs.length === 1) {
                        return this.signatureToClosure(sigs[0]);
                    }
                }
                else if (indexable && !callable) {
                    // A plain key-value map type.
                    var keyType = 'string';
                    var valType = this.typeChecker.getIndexTypeOfType(type, ts.IndexKind.String);
                    if (!valType) {
                        keyType = 'number';
                        valType = this.typeChecker.getIndexTypeOfType(type, ts.IndexKind.Number);
                    }
                    if (!valType) {
                        this.warn('unknown index key type');
                        return "!Object<?,?>";
                    }
                    return "!Object<" + keyType + "," + this.translate(valType) + ">";
                }
                else if (!callable && !indexable) {
                    // The object has no members.  This is the TS type '{}',
                    // which means "any value other than null or undefined".
                    // What is this in Closure's type system?
                    //
                    // First, {!Object} is wrong because it is not a supertype of
                    // {string} or {number}.  This would mean you cannot assign a
                    // number to a variable of TS type {}.
                    //
                    // We get closer with {*}, aka the ALL type.  This one better
                    // captures the typical use of the TS {}, which users use for
                    // "I don't care".
                    //
                    // {*} unfortunately does include null/undefined, so it's a closer
                    // match for TS 3.0's 'unknown'.
                    return '*';
                }
            }
            if (!callable && !indexable) {
                // Not callable, not indexable; implies a plain object with fields in it.
                return "{" + fields.join(', ') + "}";
            }
            this.warn('unhandled anonymous type');
            return '?';
        };
        /** Converts a ts.Signature (function signature) to a Closure function type. */
        TypeTranslator.prototype.signatureToClosure = function (sig) {
            // TODO(martinprobst): Consider harmonizing some overlap with emitFunctionType in tsickle.ts.
            if (!sig.declaration) {
                this.warn('signature without declaration');
                return 'Function';
            }
            if (sig.declaration.kind === ts.SyntaxKind.JSDocSignature) {
                this.warn('signature with JSDoc declaration');
                return 'Function';
            }
            this.blacklistTypeParameters(this.symbolsToAliasedNames, sig.declaration.typeParameters);
            var typeStr = "function(";
            var paramDecls = sig.declaration.parameters || [];
            var maybeThisParam = paramDecls[0];
            // Oddly, the this type shows up in paramDecls, but not in the type's parameters.
            // Handle it here and then pass paramDecls down without its first element.
            if (maybeThisParam && maybeThisParam.name.getText() === 'this') {
                if (maybeThisParam.type) {
                    var thisType = this.typeChecker.getTypeAtLocation(maybeThisParam.type);
                    typeStr += "this: (" + this.translate(thisType) + ")";
                    if (paramDecls.length > 1)
                        typeStr += ', ';
                }
                else {
                    this.warn('this type without type');
                }
                paramDecls = paramDecls.slice(1);
            }
            var params = this.convertParams(sig, paramDecls);
            typeStr += params.join(', ') + ")";
            var retType = this.translate(this.typeChecker.getReturnTypeOfSignature(sig));
            if (retType) {
                typeStr += ": " + retType;
            }
            return typeStr;
        };
        /**
         * Converts parameters for the given signature. Takes parameter declarations as those might not
         * match the signature parameters (e.g. there might be an additional this parameter). This
         * difference is handled by the caller, as is converting the "this" parameter.
         */
        TypeTranslator.prototype.convertParams = function (sig, paramDecls) {
            var paramTypes = [];
            for (var i = 0; i < sig.parameters.length; i++) {
                var param = sig.parameters[i];
                var paramDecl = paramDecls[i];
                var optional = !!paramDecl.questionToken;
                var varArgs = !!paramDecl.dotDotDotToken;
                var paramType = this.typeChecker.getTypeOfSymbolAtLocation(param, this.node);
                if (varArgs) {
                    var typeRef = paramType;
                    paramType = typeRef.typeArguments[0];
                }
                var typeStr = this.translate(paramType);
                if (varArgs)
                    typeStr = '...' + typeStr;
                if (optional)
                    typeStr = typeStr + '=';
                paramTypes.push(typeStr);
            }
            return paramTypes;
        };
        TypeTranslator.prototype.warn = function (msg) {
            // By default, warn() does nothing.  The caller will overwrite this
            // if it wants different behavior.
        };
        /** @return true if sym should always have type {?}. */
        TypeTranslator.prototype.isBlackListed = function (symbol) {
            if (this.pathBlackList === undefined)
                return false;
            var pathBlackList = this.pathBlackList;
            // Some builtin types, such as {}, get represented by a symbol that has no declarations.
            if (symbol.declarations === undefined)
                return false;
            return symbol.declarations.every(function (n) {
                var fileName = path.normalize(n.getSourceFile().fileName);
                return pathBlackList.has(fileName);
            });
        };
        /**
         * Closure doesn not support type parameters for function types, i.e. generic function types.
         * Blacklist the symbols declared by them and emit a ? for the types.
         *
         * This mutates the given blacklist map. The map's scope is one file, and symbols are
         * unique objects, so this should neither lead to excessive memory consumption nor introduce
         * errors.
         *
         * @param blacklist a map to store the blacklisted symbols in, with a value of '?'. In practice,
         *     this is always === this.symbolsToAliasedNames, but we're passing it explicitly to make it
         *    clear that the map is mutated (in particular when used from outside the class).
         * @param decls the declarations whose symbols should be blacklisted.
         */
        TypeTranslator.prototype.blacklistTypeParameters = function (blacklist, decls) {
            var e_8, _a;
            if (!decls || !decls.length)
                return;
            try {
                for (var decls_1 = __values(decls), decls_1_1 = decls_1.next(); !decls_1_1.done; decls_1_1 = decls_1.next()) {
                    var tpd = decls_1_1.value;
                    var sym = this.typeChecker.getSymbolAtLocation(tpd.name);
                    if (!sym) {
                        this.warn("type parameter with no symbol");
                        continue;
                    }
                    this.symbolsToAliasedNames.set(sym, '?');
                }
            }
            catch (e_8_1) { e_8 = { error: e_8_1 }; }
            finally {
                try {
                    if (decls_1_1 && !decls_1_1.done && (_a = decls_1.return)) _a.call(decls_1);
                }
                finally { if (e_8) throw e_8.error; }
            }
        };
        return TypeTranslator;
    }());
    exports.TypeTranslator = TypeTranslator;
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwZV90cmFuc2xhdG9yLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL3R5cGVfdHJhbnNsYXRvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0dBTUc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFFSCwyQkFBNkI7SUFDN0IsK0JBQWlDO0lBRWpDLDZEQUF1RTtJQUN2RSxpRUFBaUY7SUFFakY7Ozs7Ozs7Ozs7OztPQVlHO0lBQ0gsU0FBZ0IsMEJBQTBCLENBQUMsSUFBWTtRQUNyRCwwRUFBMEU7UUFDMUUsbURBQW1EO1FBQ25ELE9BQU8sMEJBQTBCLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQy9DLENBQUM7SUFKRCxnRUFJQztJQUVEOzs7T0FHRztJQUNILFNBQWdCLGVBQWUsQ0FBQyxRQUFnQjtRQUM5QyxPQUFPLFFBQVEsQ0FBQyxLQUFLLENBQUMsMkJBQTJCLENBQUMsSUFBSSxJQUFJLENBQUM7SUFDN0QsQ0FBQztJQUZELDBDQUVDO0lBRUQ7Ozs7O09BS0c7SUFDSCxTQUFTLHFCQUFxQixDQUFDLE1BQWlCO1FBQzlDLE9BQU8sTUFBTSxDQUFDLFlBQVksSUFBSSxJQUFJO1lBQzlCLE1BQU0sQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLFVBQUEsQ0FBQyxJQUFJLE9BQUEsZUFBZSxDQUFDLENBQUMsQ0FBQyxhQUFhLEVBQUUsQ0FBQyxRQUFRLENBQUMsRUFBM0MsQ0FBMkMsQ0FBQyxDQUFDO0lBQ2pGLENBQUM7SUFFRCxTQUFnQixpQkFBaUIsQ0FBQyxJQUFhOztRQUM3QyxJQUFJLFdBQVcsR0FBRyxhQUFXLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBRyxDQUFDO1FBRXZELElBQUksSUFBSSxDQUFDLFdBQVcsRUFBRTtZQUNwQixXQUFXLElBQUksWUFBVSxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFHLENBQUM7U0FDbEU7UUFDRCxJQUFJLElB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QyxhQUFhLENBQUM7WUFDekMsd0ZBQXdGO1lBQ3hGLElBQUksTUFBTSxDQUFDLFlBQVksS0FBSyxTQUFTO2dCQUFFLE9BQU8sS0FBSyxDQUFDO1lBQ3BELE9BQU8sTUFBTSxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUMsVUFBQSxDQUFDO2dCQUNoQyxJQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxhQUFhLEVBQUUsQ0FBQyxRQUFRLENBQUMsQ0FBQztnQkFDNUQsT0FBTyxhQUFhLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQ3JDLENBQUMsQ0FBQyxDQUFDO1FBQ0wsQ0FBQztRQUVEOzs7Ozs7Ozs7Ozs7V0FZRztRQUNILGdEQUF1QixHQUF2QixVQUNJLFNBQWlDLEVBQ2pDLEtBQTJEOztZQUM3RCxJQUFJLENBQUMsS0FBSyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU07Z0JBQUUsT0FBTzs7Z0JBQ3BDLEtBQWtCLElBQUEsVUFBQSxTQUFBLEtBQUssQ0FBQSw0QkFBQSwrQ0FBRTtvQkFBcEIsSUFBTSxHQUFHLGtCQUFBO29CQUNaLElBQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsbUJBQW1CLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO29CQUMzRCxJQUFJLENBQUMsR0FBRyxFQUFFO3dCQUNSLElBQUksQ0FBQyxJQUFJLENBQUMsK0JBQStCLENBQUMsQ0FBQzt3QkFDM0MsU0FBUztxQkFDVjtvQkFDRCxJQUFJLENBQUMscUJBQXFCLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQztpQkFDMUM7Ozs7Ozs7OztRQUNILENBQUM7UUFDSCxxQkFBQztJQUFELENBQUMsQUE5b0JELElBOG9CQztJQTlvQlksd0NBQWMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgKiBhcyB0cyBmcm9tICd0eXBlc2NyaXB0JztcblxuaW1wb3J0IHtBbm5vdGF0b3JIb3N0LCBtb2R1bGVOYW1lQXNJZGVudGlmaWVyfSBmcm9tICcuL2Fubm90YXRvcl9ob3N0JztcbmltcG9ydCB7Z2V0SWRlbnRpZmllclRleHQsIGhhc01vZGlmaWVyRmxhZywgaXNBbWJpZW50fSBmcm9tICcuL3RyYW5zZm9ybWVyX3V0aWwnO1xuXG4vKipcbiAqIFR5cGVTY3JpcHQgYWxsb3dzIHlvdSB0byB3cml0ZSBpZGVudGlmaWVycyBxdW90ZWQsIGxpa2U6XG4gKiAgIGludGVyZmFjZSBGb28ge1xuICogICAgICdiYXInOiBzdHJpbmc7XG4gKiAgICAgJ2NvbXBsZXggbmFtZSc6IHN0cmluZztcbiAqICAgfVxuICogICBGb28uYmFyOyAgLy8gb2tcbiAqICAgRm9vWydiYXInXSAgLy8gb2tcbiAqICAgRm9vWydjb21wbGV4IG5hbWUnXSAgLy8gb2tcbiAqXG4gKiBJbiBDbG9zdXJlLWxhbmQsIHdlIHdhbnQgaWRlbnRpZnkgdGhhdCB0aGUgbGVnYWwgbmFtZSAnYmFyJyBjYW4gYmVjb21lIGFuXG4gKiBvcmRpbmFyeSBmaWVsZCwgYnV0IHdlIG5lZWQgdG8gc2tpcCBzdHJpbmdzIGxpa2UgJ2NvbXBsZXggbmFtZScuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkQ2xvc3VyZVByb3BlcnR5TmFtZShuYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgLy8gSW4gbG9jYWwgZXhwZXJpbWVudGF0aW9uLCBpdCBhcHBlYXJzIHRoYXQgcmVzZXJ2ZWQgd29yZHMgbGlrZSAndmFyJyBhbmRcbiAgLy8gJ2lmJyBhcmUgbGVnYWwgSlMgYW5kIHN0aWxsIGFjY2VwdGVkIGJ5IENsb3N1cmUuXG4gIHJldHVybiAvXlthLXpBLVpfXVthLXpBLVowLTlfXSokLy50ZXN0KG5hbWUpO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgaWYgZmlsZU5hbWUgcmVmZXJzIHRvIGEgYnVpbHRpbiBsaWIuZC50cyBmaWxlLlxuICogVGhpcyBpcyBhIHRlcnJpYmxlIGhhY2sgYnV0IGl0IG1pcnJvcnMgYSBzaW1pbGFyIHRoaW5nIGRvbmUgaW4gQ2x1dHouXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0J1aWx0aW5MaWJEVFMoZmlsZU5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gZmlsZU5hbWUubWF0Y2goL1xcYmxpYlxcLig/OlteL10rXFwuKT9kXFwudHMkLykgIT0gbnVsbDtcbn1cblxuLyoqXG4gKiBAcmV0dXJuIFRydWUgaWYgdGhlIG5hbWVkIHR5cGUgaXMgY29uc2lkZXJlZCBjb21wYXRpYmxlIHdpdGggdGhlIENsb3N1cmUtZGVmaW5lZFxuICogICAgIHR5cGUgb2YgdGhlIHNhbWUgbmFtZSwgZS5nLiBcIkFycmF5XCIuICBOb3RlIHRoYXQgd2UgZG9uJ3QgYWN0dWFsbHkgZW5mb3JjZVxuICogICAgIHRoYXQgdGhlIHR5cGVzIGFyZSBhY3R1YWxseSBjb21wYXRpYmxlLCBidXQgbW9zdGx5IGp1c3QgaG9wZSB0aGF0IHRoZXkgYXJlIGR1ZVxuICogICAgIHRvIGJlaW5nIGRlcml2ZWQgZnJvbSB0aGUgc2FtZSBIVE1MIHNwZWNzLlxuICovXG5mdW5jdGlvbiBpc0Nsb3N1cmVQcm92aWRlZFR5cGUoc3ltYm9sOiB0cy5TeW1ib2wpOiBib29sZWFuIHtcbiAgcmV0dXJuIHN5bWJvbC5kZWNsYXJhdGlvbnMgIT0gbnVsbCAmJlxuICAgICAgc3ltYm9sLmRlY2xhcmF0aW9ucy5zb21lKG4gPT4gaXNCdWlsdGluTGliRFRTKG4uZ2V0U291cmNlRmlsZSgpLmZpbGVOYW1lKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0eXBlVG9EZWJ1Z1N0cmluZyh0eXBlOiB0cy5UeXBlKTogc3RyaW5nIHtcbiAgbGV0IGRlYnVnU3RyaW5nID0gYGZsYWdzOjB4JHt0eXBlLmZsYWdzLnRvU3RyaW5nKDE2KX1gO1xuXG4gIGlmICh0eXBlLmFsaWFzU3ltYm9sKSB7XG4gICAgZGVidWdTdHJpbmcgKz0gYCBhbGlhczoke3N5bWJvbFRvRGVidWdTdHJpbmcodHlwZS5hbGlhc1N5bWJvbCl9YDtcbiAgfVxuICBpZiAodHlwZS5hbGlhc1R5cGVBcmd1bWVudHMpIHtcbiAgICBkZWJ1Z1N0cmluZyArPSBgIGFsaWFzQXJnczo8JHt0eXBlLmFsaWFzVHlwZUFyZ3VtZW50cy5tYXAodHlwZVRvRGVidWdTdHJpbmcpLmpvaW4oJywnKX0+YDtcbiAgfVxuXG4gIC8vIEp1c3QgdGhlIHVuaXF1ZSBmbGFncyAocG93ZXJzIG9mIHR3bykuIERlY2xhcmVkIGluIHNyYy9jb21waWxlci90eXBlcy50cy5cbiAgY29uc3QgYmFzaWNUeXBlczogdHMuVHlwZUZsYWdzW10gPSBbXG4gICAgdHMuVHlwZUZsYWdzLkFueSwgICAgICAgICAgIHRzLlR5cGVGbGFncy5TdHJpbmcsICAgICAgICAgdHMuVHlwZUZsYWdzLk51bWJlcixcbiAgICB0cy5UeXBlRmxhZ3MuQm9vbGVhbiwgICAgICAgdHMuVHlwZUZsYWdzLkVudW0sICAgICAgICAgICB0cy5UeXBlRmxhZ3MuU3RyaW5nTGl0ZXJhbCxcbiAgICB0cy5UeXBlRmxhZ3MuTnVtYmVyTGl0ZXJhbCwgdHMuVHlwZUZsYWdzLkJvb2xlYW5MaXRlcmFsLCB0cy5UeXBlRmxhZ3MuRW51bUxpdGVyYWwsXG4gICAgdHMuVHlwZUZsYWdzLkVTU3ltYm9sLCAgICAgIHRzLlR5cGVGbGFncy5VbmlxdWVFU1N5bWJvbCwgdHMuVHlwZUZsYWdzLlZvaWQsXG4gICAgdHMuVHlwZUZsYWdzLlVuZGVmaW5lZCwgICAgIHRzLlR5cGVGbGFncy5OdWxsLCAgICAgICAgICAgdHMuVHlwZUZsYWdzLk5ldmVyLFxuICAgIHRzLlR5cGVGbGFncy5UeXBlUGFyYW1ldGVyLCB0cy5UeXBlRmxhZ3MuT2JqZWN0LCAgICAgICAgIHRzLlR5cGVGbGFncy5VbmlvbixcbiAgICB0cy5UeXBlRmxhZ3MuSW50ZXJzZWN0aW9uLCAgdHMuVHlwZUZsYWdzLkluZGV4LCAgICAgICAgICB0cy5UeXBlRmxhZ3MuSW5kZXhlZEFjY2VzcyxcbiAgICB0cy5UeXBlRmxhZ3MuQ29uZGl0aW9uYWwsICAgdHMuVHlwZUZsYWdzLlN1YnN0aXR1dGlvbixcbiAgXTtcbiAgZm9yIChjb25zdCBmbGFnIG9mIGJhc2ljVHlwZXMpIHtcbiAgICBpZiAoKHR5cGUuZmxhZ3MgJiBmbGFnKSAhPT0gMCkge1xuICAgICAgZGVidWdTdHJpbmcgKz0gYCAke3RzLlR5cGVGbGFnc1tmbGFnXX1gO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlLmZsYWdzID09PSB0cy5UeXBlRmxhZ3MuT2JqZWN0KSB7XG4gICAgY29uc3Qgb2JqVHlwZSA9IHR5cGUgYXMgdHMuT2JqZWN0VHlwZTtcbiAgICBkZWJ1Z1N0cmluZyArPSBgIG9iamVjdEZsYWdzOjB4JHtvYmpUeXBlLm9iamVjdEZsYWdzfWA7XG4gICAgLy8gSnVzdCB0aGUgdW5pcXVlIGZsYWdzIChwb3dlcnMgb2YgdHdvKS4gRGVjbGFyZWQgaW4gc3JjL2NvbXBpbGVyL3R5cGVzLnRzLlxuICAgIGNvbnN0IG9iamVjdEZsYWdzOiB0cy5PYmplY3RGbGFnc1tdID0gW1xuICAgICAgdHMuT2JqZWN0RmxhZ3MuQ2xhc3MsXG4gICAgICB0cy5PYmplY3RGbGFncy5JbnRlcmZhY2UsXG4gICAgICB0cy5PYmplY3RGbGFncy5SZWZlcmVuY2UsXG4gICAgICB0cy5PYmplY3RGbGFncy5UdXBsZSxcbiAgICAgIHRzLk9iamVjdEZsYWdzLkFub255bW91cyxcbiAgICAgIHRzLk9iamVjdEZsYWdzLk1hcHBlZCxcbiAgICAgIHRzLk9iamVjdEZsYWdzLkluc3RhbnRpYXRlZCxcbiAgICAgIHRzLk9iamVjdEZsYWdzLk9iamVjdExpdGVyYWwsXG4gICAgICB0cy5PYmplY3RGbGFncy5Fdm9sdmluZ0FycmF5LFxuICAgICAgdHMuT2JqZWN0RmxhZ3MuT2JqZWN0TGl0ZXJhbFBhdHRlcm5XaXRoQ29tcHV0ZWRQcm9wZXJ0aWVzLFxuICAgIF07XG4gICAgZm9yIChjb25zdCBmbGFnIG9mIG9iamVjdEZsYWdzKSB7XG4gICAgICBpZiAoKG9ialR5cGUub2JqZWN0RmxhZ3MgJiBmbGFnKSAhPT0gMCkge1xuICAgICAgICBkZWJ1Z1N0cmluZyArPSBgIG9iamVjdDoke3RzLk9iamVjdEZsYWdzW2ZsYWddfWA7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGUuc3ltYm9sICYmIHR5cGUuc3ltYm9sLm5hbWUgIT09ICdfX3R5cGUnKSB7XG4gICAgZGVidWdTdHJpbmcgKz0gYCBzeW1ib2wubmFtZToke0pTT04uc3RyaW5naWZ5KHR5cGUuc3ltYm9sLm5hbWUpfWA7XG4gIH1cblxuICBpZiAodHlwZS5wYXR0ZXJuKSB7XG4gICAgZGVidWdTdHJpbmcgKz0gYCBkZXN0cnVjdHVyaW5nOnRydWVgO1xuICB9XG5cbiAgcmV0dXJuIGB7dHlwZSAke2RlYnVnU3RyaW5nfX1gO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3ltYm9sVG9EZWJ1Z1N0cmluZyhzeW06IHRzLlN5bWJvbCk6IHN0cmluZyB7XG4gIGxldCBkZWJ1Z1N0cmluZyA9IGAke0pTT04uc3RyaW5naWZ5KHN5bS5uYW1lKX0gZmxhZ3M6MHgke3N5bS5mbGFncy50b1N0cmluZygxNil9YDtcblxuICAvLyBKdXN0IHRoZSB1bmlxdWUgZmxhZ3MgKHBvd2VycyBvZiB0d28pLiBEZWNsYXJlZCBpbiBzcmMvY29tcGlsZXIvdHlwZXMudHMuXG4gIGNvbnN0IHN5bWJvbEZsYWdzID0gW1xuICAgIHRzLlN5bWJvbEZsYWdzLkZ1bmN0aW9uU2NvcGVkVmFyaWFibGUsXG4gICAgdHMuU3ltYm9sRmxhZ3MuQmxvY2tTY29wZWRWYXJpYWJsZSxcbiAgICB0cy5TeW1ib2xGbGFncy5Qcm9wZXJ0eSxcbiAgICB0cy5TeW1ib2xGbGFncy5FbnVtTWVtYmVyLFxuICAgIHRzLlN5bWJvbEZsYWdzLkZ1bmN0aW9uLFxuICAgIHRzLlN5bWJvbEZsYWdzLkNsYXNzLFxuICAgIHRzLlN5bWJvbEZsYWdzLkludGVyZmFjZSxcbiAgICB0cy5TeW1ib2xGbGFncy5Db25zdEVudW0sXG4gICAgdHMuU3ltYm9sRmxhZ3MuUmVndWxhckVudW0sXG4gICAgdHMuU3ltYm9sRmxhZ3MuVmFsdWVNb2R1bGUsXG4gICAgdHMuU3ltYm9sRmxhZ3MuTmFtZXNwYWNlTW9kdWxlLFxuICAgIHRzLlN5bWJvbEZsYWdzLlR5cGVMaXRlcmFsLFxuICAgIHRzLlN5bWJvbEZsYWdzLk9iamVjdExpdGVyYWwsXG4gICAgdHMuU3ltYm9sRmxhZ3MuTWV0aG9kLFxuICAgIHRzLlN5bWJvbEZsYWdzLkNvbnN0cnVjdG9yLFxuICAgIHRzLlN5bWJvbEZsYWdzLkdldEFjY2Vzc29yLFxuICAgIHRzLlN5bWJvbEZsYWdzLlNldEFjY2Vzc29yLFxuICAgIHRzLlN5bWJvbEZsYWdzLlNpZ25hdHVyZSxcbiAgICB0cy5TeW1ib2xGbGFncy5UeXBlUGFyYW1ldGVyLFxuICAgIHRzLlN5bWJvbEZsYWdzLlR5cGVBbGlhcyxcbiAgICB0cy5TeW1ib2xGbGFncy5FeHBvcnRWYWx1ZSxcbiAgICB0cy5TeW1ib2xGbGFncy5BbGlhcyxcbiAgICB0cy5TeW1ib2xGbGFncy5Qcm90b3R5cGUsXG4gICAgdHMuU3ltYm9sRmxhZ3MuRXhwb3J0U3RhcixcbiAgICB0cy5TeW1ib2xGbGFncy5PcHRpb25hbCxcbiAgICB0cy5TeW1ib2xGbGFncy5UcmFuc2llbnQsXG4gIF07XG4gIGZvciAoY29uc3QgZmxhZyBvZiBzeW1ib2xGbGFncykge1xuICAgIGlmICgoc3ltLmZsYWdzICYgZmxhZykgIT09IDApIHtcbiAgICAgIGRlYnVnU3RyaW5nICs9IGAgJHt0cy5TeW1ib2xGbGFnc1tmbGFnXX1gO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkZWJ1Z1N0cmluZztcbn1cblxuLyoqIEEgbW9kdWxlIGRlY2xhcmVkIGFzIFwiZGVjbGFyZSBtb2R1bGUgJ2V4dGVybmFsX25hbWUnIHsuLi59XCIgKG5vdGUgdGhlIHF1b3RlcykuICovXG50eXBlIEFtYmllbnRNb2R1bGVEZWNsYXJhdGlvbiA9IHRzLk1vZHVsZURlY2xhcmF0aW9uJntuYW1lOiB0cy5TdHJpbmdMaXRlcmFsfTtcblxuLyoqXG4gKiBTZWFyY2hlcyBmb3IgYW4gYW1iaWVudCBtb2R1bGUgZGVjbGFyYXRpb24gaW4gdGhlIGFuY2VzdG9ycyBvZiBkZWNsYXJhdGlvbnMsIGRlcHRoIGZpcnN0LCBhbmRcbiAqIHJldHVybnMgdGhlIGZpcnN0IG9yIG51bGwgaWYgbm9uZSBmb3VuZC5cbiAqL1xuZnVuY3Rpb24gZ2V0Q29udGFpbmluZ0FtYmllbnRNb2R1bGVEZWNsYXJhdGlvbihkZWNsYXJhdGlvbnM6IHRzLkRlY2xhcmF0aW9uW10pOlxuICAgIEFtYmllbnRNb2R1bGVEZWNsYXJhdGlvbnxudWxsIHtcbiAgZm9yIChjb25zdCBkZWNsYXJhdGlvbiBvZiBkZWNsYXJhdGlvbnMpIHtcbiAgICBsZXQgcGFyZW50ID0gZGVjbGFyYXRpb24ucGFyZW50O1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgIGlmICh0cy5pc01vZHVsZURlY2xhcmF0aW9uKHBhcmVudCkgJiYgdHMuaXNTdHJpbmdMaXRlcmFsKHBhcmVudC5uYW1lKSkge1xuICAgICAgICByZXR1cm4gcGFyZW50IGFzIEFtYmllbnRNb2R1bGVEZWNsYXJhdGlvbjtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKiogUmV0dXJucyB0cnVlIGlmIGFueSBvZiBkZWNsYXJhdGlvbnMgaXMgYSB0b3AgbGV2ZWwgZGVjbGFyYXRpb24gaW4gYW4gZXh0ZXJuYWwgbW9kdWxlLiAqL1xuZnVuY3Rpb24gaXNUb3BMZXZlbEV4dGVybmFsKGRlY2xhcmF0aW9uczogdHMuRGVjbGFyYXRpb25bXSkge1xuICBmb3IgKGNvbnN0IGRlY2xhcmF0aW9uIG9mIGRlY2xhcmF0aW9ucykge1xuICAgIGlmIChkZWNsYXJhdGlvbi5wYXJlbnQgPT09IHVuZGVmaW5lZCkgY29udGludWU7XG4gICAgaWYgKHRzLmlzU291cmNlRmlsZShkZWNsYXJhdGlvbi5wYXJlbnQpICYmIHRzLmlzRXh0ZXJuYWxNb2R1bGUoZGVjbGFyYXRpb24ucGFyZW50KSkgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBhIGFuZCBiIGFyZSAob3Igd2VyZSBvcmlnaW5hbGx5IGJlZm9yZSB0cmFuc2Zvcm1hdGlvbikgbm9kZXMgb2YgdGhlIHNhbWUgc291cmNlXG4gKiBmaWxlLlxuICovXG5mdW5jdGlvbiBpc0RlY2xhcmVkSW5TYW1lRmlsZShhOiB0cy5Ob2RlLCBiOiB0cy5Ob2RlKSB7XG4gIHJldHVybiB0cy5nZXRPcmlnaW5hbE5vZGUoYSkuZ2V0U291cmNlRmlsZSgpID09PSB0cy5nZXRPcmlnaW5hbE5vZGUoYikuZ2V0U291cmNlRmlsZSgpO1xufVxuXG4vKiogVHlwZVRyYW5zbGF0b3IgdHJhbnNsYXRlcyBUeXBlU2NyaXB0IHR5cGVzIHRvIENsb3N1cmUgdHlwZXMuICovXG5leHBvcnQgY2xhc3MgVHlwZVRyYW5zbGF0b3Ige1xuICAvKipcbiAgICogQSBsaXN0IG9mIHR5cGUgbGl0ZXJhbHMgd2UndmUgZW5jb3VudGVyZWQgd2hpbGUgZW1pdHRpbmc7IHVzZWQgdG8gYXZvaWQgZ2V0dGluZyBzdHVjayBpblxuICAgKiByZWN1cnNpdmUgdHlwZXMuXG4gICAqL1xuICBwcml2YXRlIHJlYWRvbmx5IHNlZW5Bbm9ueW1vdXNUeXBlcyA9IG5ldyBTZXQ8dHMuVHlwZT4oKTtcblxuICAvKipcbiAgICogV2hldGhlciB0byB3cml0ZSB0eXBlcyBzdWl0YWJsZSBmb3IgYW4gXFxAZXh0ZXJucyBmaWxlLiBFeHRlcm5zIHR5cGVzIG11c3Qgbm90IHJlZmVyIHRvXG4gICAqIG5vbi1leHRlcm5zIHR5cGVzIChpLmUuIG5vbiBhbWJpZW50IHR5cGVzKSBhbmQgbmVlZCB0byB1c2UgZnVsbHkgcXVhbGlmaWVkIG5hbWVzLlxuICAgKi9cbiAgaXNGb3JFeHRlcm5zID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBub2RlIGlzIHRoZSBzb3VyY2UgQVNUIHRzLk5vZGUgdGhlIHR5cGUgY29tZXMgZnJvbS4gIFRoaXMgaXMgdXNlZFxuICAgKiAgICAgaW4gc29tZSBjYXNlcyAoZS5nLiBhbm9ueW1vdXMgdHlwZXMpIGZvciBsb29raW5nIHVwIGZpZWxkIG5hbWVzLlxuICAgKiBAcGFyYW0gcGF0aEJsYWNrTGlzdCBpcyBhIHNldCBvZiBwYXRocyB0aGF0IHNob3VsZCBuZXZlciBnZXQgdHlwZWQ7XG4gICAqICAgICBhbnkgcmVmZXJlbmNlIHRvIHN5bWJvbHMgZGVmaW5lZCBpbiB0aGVzZSBwYXRocyBzaG91bGQgYnkgdHlwZWRcbiAgICogICAgIGFzIHs/fS5cbiAgICogQHBhcmFtIHN5bWJvbHNUb0FsaWFzZWROYW1lcyBhIG1hcHBpbmcgZnJvbSBzeW1ib2xzIChgRm9vYCkgdG8gYSBuYW1lIGluIHNjb3BlIHRoZXkgc2hvdWxkIGJlXG4gICAqICAgICBlbWl0dGVkIGFzIChlLmcuIGB0c2lja2xlX2ZvcndhcmRfZGVjbGFyZV8xLkZvb2ApLiBDYW4gYmUgYXVnbWVudGVkIGR1cmluZyB0eXBlXG4gICAqICAgICB0cmFuc2xhdGlvbiwgZS5nLiB0byBibGFja2xpc3QgYSBzeW1ib2wuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICAgIHByaXZhdGUgcmVhZG9ubHkgaG9zdDogQW5ub3RhdG9ySG9zdCwgcHJpdmF0ZSByZWFkb25seSB0eXBlQ2hlY2tlcjogdHMuVHlwZUNoZWNrZXIsXG4gICAgICBwcml2YXRlIHJlYWRvbmx5IG5vZGU6IHRzLk5vZGUsIHByaXZhdGUgcmVhZG9ubHkgcGF0aEJsYWNrTGlzdD86IFNldDxzdHJpbmc+LFxuICAgICAgcHJpdmF0ZSByZWFkb25seSBzeW1ib2xzVG9BbGlhc2VkTmFtZXMgPSBuZXcgTWFwPHRzLlN5bWJvbCwgc3RyaW5nPigpLFxuICAgICAgcHJpdmF0ZSByZWFkb25seSBlbnN1cmVTeW1ib2xEZWNsYXJlZDogKHN5bTogdHMuU3ltYm9sKSA9PiB2b2lkID0gKCkgPT4ge30pIHtcbiAgICAvLyBOb3JtYWxpemUgcGF0aHMgdG8gbm90IGJyZWFrIGNoZWNrcyBvbiBXaW5kb3dzLlxuICAgIGlmICh0aGlzLnBhdGhCbGFja0xpc3QgIT0gbnVsbCkge1xuICAgICAgdGhpcy5wYXRoQmxhY2tMaXN0ID1cbiAgICAgICAgICBuZXcgU2V0PHN0cmluZz4oQXJyYXkuZnJvbSh0aGlzLnBhdGhCbGFja0xpc3QudmFsdWVzKCkpLm1hcChwID0+IHBhdGgubm9ybWFsaXplKHApKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgdHMuU3ltYm9sIHRvIGEgc3RyaW5nLCBhcHBseWluZyBhbGlhc2VzIGFuZCBlbnN1cmluZyBzeW1ib2xzIGFyZSBpbXBvcnRlZC5cbiAgICogQHJldHVybiBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgc3ltYm9sIGFzIGEgdmFsaWQgQ2xvc3VyZSB0eXBlIG5hbWUsIG9yIGB1bmRlZmluZWRgIGlmXG4gICAqICAgICB0aGUgdHlwZSBjYW5ub3QgYmUgZXhwcmVzc2VkIChlLmcuIGZvciBhbm9ueW1vdXMgdHlwZXMpLlxuICAgKi9cbiAgc3ltYm9sVG9TdHJpbmcoc3ltOiB0cy5TeW1ib2wpOiBzdHJpbmd8dW5kZWZpbmVkIHtcbiAgICAvLyBUeXBlU2NyaXB0IHJlc29sdmVzIGUuZy4gdW5pb24gdHlwZXMgdG8gdGhlaXIgbWVtYmVycywgd2hpY2ggY2FuIGluY2x1ZGUgc3ltYm9scyBub3QgZGVjbGFyZWRcbiAgICAvLyBpbiB0aGUgY3VycmVudCBzY29wZS4gRW5zdXJlIHRoYXQgYWxsIHN5bWJvbHMgZm91bmQgdGhpcyB3YXkgYXJlIGFjdHVhbGx5IGRlY2xhcmVkLlxuICAgIC8vIFRoaXMgbXVzdCBoYXBwZW4gYmVmb3JlIHRoZSBhbGlhcyBjaGVjayBiZWxvdywgaXQgbWlnaHQgaW50cm9kdWNlIGEgbmV3IGFsaWFzIGZvciB0aGUgc3ltYm9sLlxuICAgIGlmICghdGhpcy5pc0ZvckV4dGVybnMgJiYgKHN5bS5mbGFncyAmIHRzLlN5bWJvbEZsYWdzLlR5cGVQYXJhbWV0ZXIpID09PSAwKSB7XG4gICAgICB0aGlzLmVuc3VyZVN5bWJvbERlY2xhcmVkKHN5bSk7XG4gICAgfVxuXG4gICAgY29uc3QgbmFtZSA9IHRoaXMudHlwZUNoZWNrZXIuc3ltYm9sVG9FbnRpdHlOYW1lKFxuICAgICAgICBzeW0sIHRzLlN5bWJvbEZsYWdzLk5vbmUsIHRoaXMubm9kZSwgdHMuTm9kZUJ1aWxkZXJGbGFncy5Vc2VGdWxseVF1YWxpZmllZFR5cGUpO1xuICAgIC8vIG5hbWUgbWlnaHQgYmUgdW5kZWZpbmVkLCBlLmcuIGZvciBhbm9ueW1vdXMgY2xhc3Nlcy5cbiAgICBpZiAoIW5hbWUpIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgICAvLyBUeXBlU2NyaXB0J3Mgc3ltYm9sVG9FbnRpdHlOYW1lIHJldHVybnMgYSB0cmVlIG9mIElkZW50aWZpZXIgb2JqZWN0cy4gdHNpY2tsZSBuZWVkcyB0b1xuICAgIC8vIGlkZW50aWZ5IGFuZCBhbGlhcyBzcGVjaWZpeSBzeW1ib2xzIG9uIGl0LiBUaGUgY29kZSBiZWxvdyBhY2Nlc3NlcyB0aGUgVHlwZVNjcmlwdCBAaW50ZXJuYWxcbiAgICAvLyBzeW1ib2wgZmllbGQgb24gSWRlbnRpZmllciB0byBkbyBzby5cbiAgICB0eXBlIElkZW50aWZpZXJXaXRoU3ltYm9sID0gdHMuSWRlbnRpZmllciZ7c3ltYm9sOiB0cy5TeW1ib2x9O1xuICAgIGxldCBzdHIgPSAnJztcbiAgICAvKiogUmVjdXJzaXZlbHkgdmlzaXRzIGNvbXBvbmVudHMgb2YgZW50aXR5IG5hbWUgYW5kIHdyaXRlcyB0aGVtIHRvIGBzdHJgIGFib3ZlLiAqL1xuICAgIGNvbnN0IHdyaXRlRW50aXR5V2l0aFN5bWJvbHMgPSAobmFtZTogdHMuRW50aXR5TmFtZSkgPT4ge1xuICAgICAgbGV0IGlkZW50aWZpZXI6IElkZW50aWZpZXJXaXRoU3ltYm9sO1xuICAgICAgaWYgKHRzLmlzUXVhbGlmaWVkTmFtZShuYW1lKSkge1xuICAgICAgICB3cml0ZUVudGl0eVdpdGhTeW1ib2xzKG5hbWUubGVmdCk7XG4gICAgICAgIHN0ciArPSAnLic7XG4gICAgICAgIGlkZW50aWZpZXIgPSBuYW1lLnJpZ2h0IGFzIElkZW50aWZpZXJXaXRoU3ltYm9sO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWRlbnRpZmllciA9IG5hbWUgYXMgSWRlbnRpZmllcldpdGhTeW1ib2w7XG4gICAgICB9XG4gICAgICBsZXQgc3ltYm9sID0gaWRlbnRpZmllci5zeW1ib2w7XG4gICAgICAvLyBXaGVuIHdyaXRpbmcgYSBzeW1ib2wsIGNoZWNrIGlmIHRoZXJlIGlzIGFuIGFsaWFzIGZvciBpdCBpbiB0aGUgY3VycmVudCBzY29wZSB0aGF0IHNob3VsZFxuICAgICAgLy8gdGFrZSBwcmVjZWRlbmNlLCBlLmcuIGZyb20gYSBnb29nLmZvcndhcmREZWNsYXJlLlxuICAgICAgaWYgKHN5bWJvbC5mbGFncyAmIHRzLlN5bWJvbEZsYWdzLkFsaWFzKSB7XG4gICAgICAgIHN5bWJvbCA9IHRoaXMudHlwZUNoZWNrZXIuZ2V0QWxpYXNlZFN5bWJvbChzeW1ib2wpO1xuICAgICAgfVxuICAgICAgY29uc3QgYWxpYXMgPSB0aGlzLnN5bWJvbHNUb0FsaWFzZWROYW1lcy5nZXQoc3ltYm9sKTtcbiAgICAgIGlmIChhbGlhcykge1xuICAgICAgICAvLyBJZiBzbywgZGlzY2FyZCB0aGUgZW50aXJlIGN1cnJlbnQgdGV4dCBhbmQgb25seSB1c2UgdGhlIGFsaWFzIC0gb3RoZXJ3aXNlIGlmIGEgc3ltYm9sIGhhc1xuICAgICAgICAvLyBhIGxvY2FsIGFsaWFzIGJ1dCBhcHBlYXJzIGluIGEgZG90dGVkIHR5cGUgcGF0aCAoZS5nLiB3aGVuIGl0J3MgaW1wb3J0ZWQgdXNpbmcgaW1wb3J0ICpcbiAgICAgICAgLy8gYXMgZm9vKSwgc3RyIHdvdWxkIGNvbnRhaW4gYm90aCB0aGUgcHJlZnggKmFuZCogdGhlIGZ1bGwgYWxpYXMgKGZvby5hbGlhcy5uYW1lKS5cbiAgICAgICAgc3RyID0gYWxpYXM7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbGV0IHRleHQgPSBnZXRJZGVudGlmaWVyVGV4dChpZGVudGlmaWVyKTtcbiAgICAgIGlmIChzdHIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnN0IG1hbmdsZWRQcmVmaXggPSB0aGlzLm1heWJlR2V0TWFuZ2xlZE5hbWVQcmVmaXgoc3ltYm9sKTtcbiAgICAgICAgdGV4dCA9IG1hbmdsZWRQcmVmaXggKyB0ZXh0O1xuICAgICAgfVxuICAgICAgc3RyICs9IHRleHQ7XG4gICAgfTtcbiAgICB3cml0ZUVudGl0eVdpdGhTeW1ib2xzKG5hbWUpO1xuICAgIHJldHVybiB0aGlzLnN0cmlwQ2x1dHpOYW1lc3BhY2Uoc3RyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBtYW5nbGVkIG5hbWUgcHJlZml4IGZvciBzeW1ib2wsIG9yIGFuIGVtcHR5IHN0cmluZyBpZiBub3QgYXBwbGljYWJsZS5cbiAgICpcbiAgICogVHlwZSBuYW1lcyBhcmUgZW1pdHRlZCB3aXRoIGEgbWFuZ2xlZCBwcmVmaXggaWYgdGhleSBhcmUgdG9wIGxldmVsIHN5bWJvbHMgZGVjbGFyZWQgaW4gYW5cbiAgICogZXh0ZXJuYWwgbW9kdWxlICguZC50cyBvciAudHMpLCBhbmQgYXJlIGFtYmllbnQgZGVjbGFyYXRpb25zIChcImRlY2xhcmUgLi4uXCIpLiBUaGlzIGlzIGJlY2F1c2VcbiAgICogdGhlaXIgZGVjbGFyYXRpb25zIGdldCBtb3ZlZCB0byBleHRlcm5zIGZpbGVzICh0byBtYWtlIGV4dGVybmFsIG5hbWVzIHZpc2libGUgdG8gQ2xvc3VyZSBhbmRcbiAgICogcHJldmVudCByZW5hbWluZyksIHdoaWNoIG9ubHkgdXNlIGdsb2JhbCBuYW1lcy4gVGhpcyBtZWFucyB0aGUgbmFtZXMgbXVzdCBiZSBtYW5nbGVkIHRvIHByZXZlbnRcbiAgICogY29sbGlzaW9ucyBhbmQgYWxsb3cgcmVmZXJlbmNpbmcgdGhlbSB1bmlxdWVseS5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgYWxzbyBoYW5kbGVzIHRoZSBzcGVjaWFsIGNhc2Ugb2Ygc3ltYm9scyBkZWNsYXJlZCBpbiBhbiBhbWJpZW50IGV4dGVybmFsIG1vZHVsZVxuICAgKiBjb250ZXh0LlxuICAgKlxuICAgKiBTeW1ib2xzIGRlY2xhcmVkIGluIGEgZ2xvYmFsIGJsb2NrLCBlLmcuIFwiZGVjbGFyZSBnbG9iYWwgeyB0eXBlIFg7IH1cIiwgYXJlIGhhbmRsZWQgaW1wbGljaXRseTpcbiAgICogd2hlbiByZWZlcmVuY2VkLCB0aGV5IGFyZSB3cml0dGVuIGFzIGp1c3QgXCJYXCIsIHdoaWNoIGlzIG5vdCBhIHRvcCBsZXZlbCBkZWNsYXJhdGlvbiwgc28gdGhlXG4gICAqIGNvZGUgYmVsb3cgaWdub3JlcyB0aGVtLlxuICAgKi9cbiAgbWF5YmVHZXRNYW5nbGVkTmFtZVByZWZpeChzeW1ib2w6IHRzLlN5bWJvbCk6IHN0cmluZ3wnJyB7XG4gICAgaWYgKCFzeW1ib2wuZGVjbGFyYXRpb25zKSByZXR1cm4gJyc7XG4gICAgY29uc3QgZGVjbGFyYXRpb25zID0gc3ltYm9sLmRlY2xhcmF0aW9ucztcbiAgICBsZXQgYW1iaWVudE1vZHVsZURlY2xhcmF0aW9uOiBBbWJpZW50TW9kdWxlRGVjbGFyYXRpb258bnVsbCA9IG51bGw7XG4gICAgLy8gSWYgdGhlIHN5bWJvbCBpcyBuZWl0aGVyIGEgdG9wIGxldmVsIGRlY2xhcmF0aW9uIGluIGFuIGV4dGVybmFsIG1vZHVsZSBub3IgaW4gYW4gYW1iaWVudFxuICAgIC8vIGJsb2NrLCB0c2lja2xlIHNob3VsZCBub3QgZW1pdCBhIHByZWZpeDogaXQncyBlaXRoZXIgbm90IGFuIGV4dGVybmFsIHN5bWJvbCwgb3IgaXQncyBhblxuICAgIC8vIGV4dGVybmFsIHN5bWJvbCBuZXN0ZWQgaW4gYSBtb2R1bGUsIHNvIGl0IHdpbGwgbmVlZCB0byBiZSBxdWFsaWZpZWQsIGFuZCB0aGUgbWFuZ2xpbmcgcHJlZml4XG4gICAgLy8gZ29lcyBvbiB0aGUgcXVhbGlmaWVyLlxuICAgIGlmICghaXNUb3BMZXZlbEV4dGVybmFsKGRlY2xhcmF0aW9ucykpIHtcbiAgICAgIGFtYmllbnRNb2R1bGVEZWNsYXJhdGlvbiA9IGdldENvbnRhaW5pbmdBbWJpZW50TW9kdWxlRGVjbGFyYXRpb24oZGVjbGFyYXRpb25zKTtcbiAgICAgIGlmICghYW1iaWVudE1vZHVsZURlY2xhcmF0aW9uKSByZXR1cm4gJyc7XG4gICAgfVxuICAgIC8vIEF0IHRoaXMgcG9pbnQsIHRoZSBkZWNsYXJhdGlvbiBpcyBmcm9tIGFuIGV4dGVybmFsIG1vZHVsZSAocG9zc2libHkgYW1iaWVudCkuXG4gICAgLy8gVGhlc2UgZGVjbGFyYXRpb25zIG11c3QgYmUgcHJlZml4ZWQgaWYgZWl0aGVyOlxuICAgIC8vIChhKSB0c2lja2xlIGlzIGVtaXR0aW5nIGFuIGV4dGVybnMgZmlsZSwgc28gYWxsIHN5bWJvbHMgYXJlIHF1YWxpZmllZCB3aXRoaW4gaXRcbiAgICAvLyAoYikgb3IgdGhlIGRlY2xhcmF0aW9uIG11c3QgYmUgYW4gZXhwb3J0ZWQgYW1iaWVudCBkZWNsYXJhdGlvbiBmcm9tIHRoZSBsb2NhbCBmaWxlLlxuICAgIC8vIEFtYmllbnQgZXh0ZXJuYWwgZGVjbGFyYXRpb25zIGZyb20gb3RoZXIgZmlsZXMgYXJlIGltcG9ydGVkLCBzbyB0aGVyZSdzIGEgbG9jYWwgYWxpYXMgZm9yIHRoZVxuICAgIC8vIG1vZHVsZSBhbmQgbm8gbWFuZ2xpbmcgaXMgbmVlZGVkLlxuICAgIGlmICghdGhpcy5pc0ZvckV4dGVybnMgJiZcbiAgICAgICAgIWRlY2xhcmF0aW9ucy5ldmVyeShcbiAgICAgICAgICAgIGQgPT4gaXNEZWNsYXJlZEluU2FtZUZpbGUodGhpcy5ub2RlLCBkKSAmJiBpc0FtYmllbnQoZCkgJiZcbiAgICAgICAgICAgICAgICBoYXNNb2RpZmllckZsYWcoZCwgdHMuTW9kaWZpZXJGbGFncy5FeHBvcnQpKSkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICAvLyBJZiBmcm9tIGFuIGFtYmllbnQgZGVjbGFyYXRpb24sIHVzZSBhbmQgcmVzb2x2ZSB0aGUgbmFtZSBmcm9tIHRoYXQuIE90aGVyd2lzZSwgdXNlIHRoZSBmaWxlXG4gICAgLy8gbmFtZSBmcm9tIHRoZSAoYXJiaXRyYXJ5KSBmaXJzdCBkZWNsYXJhdGlvbiB0byBtYW5nbGUuXG4gICAgY29uc3QgZmlsZU5hbWUgPSBhbWJpZW50TW9kdWxlRGVjbGFyYXRpb24gP1xuICAgICAgICBhbWJpZW50TW9kdWxlRGVjbGFyYXRpb24ubmFtZS50ZXh0IDpcbiAgICAgICAgdHMuZ2V0T3JpZ2luYWxOb2RlKGRlY2xhcmF0aW9uc1swXSkuZ2V0U291cmNlRmlsZSgpLmZpbGVOYW1lO1xuICAgIGNvbnN0IG1hbmdsZWQgPSBtb2R1bGVOYW1lQXNJZGVudGlmaWVyKHRoaXMuaG9zdCwgZmlsZU5hbWUpO1xuICAgIHJldHVybiBtYW5nbGVkICsgJy4nO1xuICB9XG5cbiAgLy8gQ2x1dHogKGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2NsdXR6KSBlbWl0cyBnbG9iYWwgdHlwZSBzeW1ib2xzIGhpZGRlbiBpbiBhIHNwZWNpYWxcbiAgLy8g4LKgX+CyoC5jbHV0eiBuYW1lc3BhY2UuIFdoaWxlIG1vc3QgY29kZSBzZWVuIGJ5IFRzaWNrbGUgd2lsbCBvbmx5IGV2ZXIgc2VlIGxvY2FsIGFsaWFzZXMsIENsdXR6XG4gIC8vIHN5bWJvbHMgY2FuIGJlIHdyaXR0ZW4gYnkgdXNlcnMgZGlyZWN0bHkgaW4gY29kZSwgYW5kIHRoZXkgY2FuIGFwcGVhciBieSBkZXJlZmVyZW5jaW5nXG4gIC8vIFR5cGVBbGlhc2VzLiBUaGUgY29kZSBiZWxvdyBzaW1wbHkgc3RyaXBzIHRoZSBwcmVmaXgsIHRoZSByZW1haW5pbmcgdHlwZSBuYW1lIHRoZW4gbWF0Y2hlc1xuICAvLyBDbG9zdXJlJ3MgdHlwZS5cbiAgcHJpdmF0ZSBzdHJpcENsdXR6TmFtZXNwYWNlKG5hbWU6IHN0cmluZykge1xuICAgIGlmIChuYW1lLnN0YXJ0c1dpdGgoJ+CyoF/gsqAuY2x1dHouJykpIHJldHVybiBuYW1lLnN1YnN0cmluZygn4LKgX+CyoC5jbHV0ei4nLmxlbmd0aCk7XG4gICAgcmV0dXJuIG5hbWU7XG4gIH1cblxuICB0cmFuc2xhdGUodHlwZTogdHMuVHlwZSk6IHN0cmluZyB7XG4gICAgLy8gTk9URTogVGhvdWdoIHR5cGUuZmxhZ3MgaGFzIHRoZSBuYW1lIFwiZmxhZ3NcIiwgaXQgdXN1YWxseSBjYW4gb25seSBiZSBvbmVcbiAgICAvLyBvZiB0aGUgZW51bSBvcHRpb25zIGF0IGEgdGltZSAoZXhjZXB0IGZvciB1bmlvbnMgb2YgbGl0ZXJhbCB0eXBlcywgZS5nLiB1bmlvbnMgb2YgYm9vbGVhblxuICAgIC8vIHZhbHVlcywgc3RyaW5nIHZhbHVlcywgZW51bSB2YWx1ZXMpLiBUaGlzIHN3aXRjaCBoYW5kbGVzIGFsbCB0aGUgY2FzZXMgaW4gdGhlIHRzLlR5cGVGbGFnc1xuICAgIC8vIGVudW0gaW4gdGhlIG9yZGVyIHRoZXkgb2NjdXIuXG5cbiAgICAvLyBOT1RFOiBTb21lIFR5cGVGbGFncyBhcmUgbWFya2VkIFwiaW50ZXJuYWxcIiBpbiB0aGUgZC50cyBidXQgc3RpbGwgc2hvdyB1cCBpbiB0aGUgdmFsdWUgb2ZcbiAgICAvLyB0eXBlLmZsYWdzLiBUaGlzIG1hc2sgbGltaXRzIHRoZSBmbGFnIGNoZWNrcyB0byB0aGUgb25lcyBpbiB0aGUgcHVibGljIEFQSS4gXCJsYXN0RmxhZ1wiIGhlcmVcbiAgICAvLyBpcyB0aGUgbGFzdCBmbGFnIGhhbmRsZWQgaW4gdGhpcyBzd2l0Y2ggc3RhdGVtZW50LCBhbmQgc2hvdWxkIGJlIGtlcHQgaW4gc3luYyB3aXRoXG4gICAgLy8gdHlwZXNjcmlwdC5kLnRzLlxuXG4gICAgLy8gTm9uUHJpbWl0aXZlIG9jY3VycyBvbiBpdHMgb3duIG9uIHRoZSBsb3dlciBjYXNlIFwib2JqZWN0XCIgdHlwZS4gU3BlY2lhbCBjYXNlIHRvIFwiIU9iamVjdFwiLlxuICAgIGlmICh0eXBlLmZsYWdzID09PSB0cy5UeXBlRmxhZ3MuTm9uUHJpbWl0aXZlKSByZXR1cm4gJyFPYmplY3QnO1xuXG4gICAgLy8gQXZvaWQgaW5maW5pdGUgbG9vcHMgb24gcmVjdXJzaXZlIHR5cGUgbGl0ZXJhbHMuXG4gICAgLy8gSXQgd291bGQgYmUgbmljZSB0byBqdXN0IGVtaXQgdGhlIG5hbWUgb2YgdGhlIHJlY3Vyc2l2ZSB0eXBlIGhlcmUgKGluIHR5cGUuYWxpYXNTeW1ib2xcbiAgICAvLyBiZWxvdyksIGJ1dCBDbG9zdXJlIENvbXBpbGVyIGRvZXMgbm90IGFsbG93IHJlY3Vyc2l2ZSB0eXBlIGRlZmluaXRpb25zLlxuICAgIGlmICh0aGlzLnNlZW5Bbm9ueW1vdXNUeXBlcy5oYXModHlwZSkpIHJldHVybiAnPyc7XG5cbiAgICBsZXQgaXNBbWJpZW50ID0gZmFsc2U7XG4gICAgbGV0IGlzSW5OYW1lc3BhY2UgPSBmYWxzZTtcbiAgICBsZXQgaXNNb2R1bGUgPSBmYWxzZTtcbiAgICBpZiAodHlwZS5zeW1ib2wpIHtcbiAgICAgIGZvciAoY29uc3QgZGVjbCBvZiB0eXBlLnN5bWJvbC5kZWNsYXJhdGlvbnMgfHwgW10pIHtcbiAgICAgICAgaWYgKHRzLmlzRXh0ZXJuYWxNb2R1bGUoZGVjbC5nZXRTb3VyY2VGaWxlKCkpKSBpc01vZHVsZSA9IHRydWU7XG4gICAgICAgIGxldCBjdXJyZW50OiB0cy5EZWNsYXJhdGlvbnx1bmRlZmluZWQgPSBkZWNsO1xuICAgICAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgICAgIGlmICh0cy5nZXRDb21iaW5lZE1vZGlmaWVyRmxhZ3MoY3VycmVudCkgJiB0cy5Nb2RpZmllckZsYWdzLkFtYmllbnQpIGlzQW1iaWVudCA9IHRydWU7XG4gICAgICAgICAgaWYgKGN1cnJlbnQua2luZCA9PT0gdHMuU3ludGF4S2luZC5Nb2R1bGVEZWNsYXJhdGlvbikgaXNJbk5hbWVzcGFjZSA9IHRydWU7XG4gICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50IGFzIHRzLkRlY2xhcmF0aW9uIHwgdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gdHNpY2tsZSBjYW5ub3QgZ2VuZXJhdGUgdHlwZXMgZm9yIG5vbi1hbWJpZW50IG5hbWVzcGFjZXMgbm9yIGFueSBzeW1ib2xzIGNvbnRhaW5lZCBpbiB0aGVtLlxuICAgIGlmIChpc0luTmFtZXNwYWNlICYmICFpc0FtYmllbnQpIHJldHVybiAnPyc7XG5cbiAgICAvLyBUeXBlcyBpbiBleHRlcm5zIGNhbm5vdCByZWZlcmVuY2UgdHlwZXMgZnJvbSBleHRlcm5hbCBtb2R1bGVzLlxuICAgIC8vIEhvd2V2ZXIgYW1iaWVudCB0eXBlcyBpbiBtb2R1bGVzIGdldCBtb3ZlZCB0byBleHRlcm5zLCB0b28sIHNvIHR5cGUgcmVmZXJlbmNlcyB3b3JrIGFuZCB3ZVxuICAgIC8vIGNhbiBlbWl0IGEgcHJlY2lzZSB0eXBlLlxuICAgIGlmICh0aGlzLmlzRm9yRXh0ZXJucyAmJiBpc01vZHVsZSAmJiAhaXNBbWJpZW50KSByZXR1cm4gJz8nO1xuXG4gICAgY29uc3QgbGFzdEZsYWcgPSB0cy5UeXBlRmxhZ3MuU3Vic3RpdHV0aW9uO1xuICAgIGNvbnN0IG1hc2sgPSAobGFzdEZsYWcgPDwgMSkgLSAxO1xuICAgIHN3aXRjaCAodHlwZS5mbGFncyAmIG1hc2spIHtcbiAgICAgIGNhc2UgdHMuVHlwZUZsYWdzLkFueTpcbiAgICAgICAgcmV0dXJuICc/JztcbiAgICAgIGNhc2UgdHMuVHlwZUZsYWdzLlN0cmluZzpcbiAgICAgIGNhc2UgdHMuVHlwZUZsYWdzLlN0cmluZ0xpdGVyYWw6XG4gICAgICAgIHJldHVybiAnc3RyaW5nJztcbiAgICAgIGNhc2UgdHMuVHlwZUZsYWdzLk51bWJlcjpcbiAgICAgIGNhc2UgdHMuVHlwZUZsYWdzLk51bWJlckxpdGVyYWw6XG4gICAgICAgIHJldHVybiAnbnVtYmVyJztcbiAgICAgIGNhc2UgdHMuVHlwZUZsYWdzLkJvb2xlYW46XG4gICAgICBjYXNlIHRzLlR5cGVGbGFncy5Cb29sZWFuTGl0ZXJhbDpcbiAgICAgICAgLy8gU2VlIHRoZSBub3RlIGluIHRyYW5zbGF0ZVVuaW9uIGFib3V0IGJvb2xlYW5zLlxuICAgICAgICByZXR1cm4gJ2Jvb2xlYW4nO1xuICAgICAgY2FzZSB0cy5UeXBlRmxhZ3MuRW51bTpcbiAgICAgICAgaWYgKCF0eXBlLnN5bWJvbCkge1xuICAgICAgICAgIHRoaXMud2FybihgRW51bVR5cGUgd2l0aG91dCBhIHN5bWJvbGApO1xuICAgICAgICAgIHJldHVybiAnPyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc3ltYm9sVG9TdHJpbmcodHlwZS5zeW1ib2wpIHx8ICc/JztcbiAgICAgIGNhc2UgdHMuVHlwZUZsYWdzLkVTU3ltYm9sOlxuICAgICAgY2FzZSB0cy5UeXBlRmxhZ3MuVW5pcXVlRVNTeW1ib2w6XG4gICAgICAgIC8vIEVTU3ltYm9sIGluZGljYXRlcyBzb21ldGhpbmcgdHlwZWQgc3ltYm9sLlxuICAgICAgICAvLyBVbmlxdWVFU1N5bWJvbCBpbmRpY2F0ZXMgYSBzcGVjaWZpYyB1bmlxdWUgc3ltYm9sLCB1c2VkIGUuZy4gdG8gaW5kZXggaW50byBhbiBvYmplY3QuXG4gICAgICAgIC8vIENsb3N1cmUgZG9lcyBub3QgaGF2ZSB0aGlzIGRpc3RpbmN0aW9uLCBzbyB0c2lja2xlIGVtaXRzIGJvdGggYXMgJ3N5bWJvbCcuXG4gICAgICAgIHJldHVybiAnc3ltYm9sJztcbiAgICAgIGNhc2UgdHMuVHlwZUZsYWdzLlZvaWQ6XG4gICAgICAgIHJldHVybiAndm9pZCc7XG4gICAgICBjYXNlIHRzLlR5cGVGbGFncy5VbmRlZmluZWQ6XG4gICAgICAgIHJldHVybiAndW5kZWZpbmVkJztcbiAgICAgIGNhc2UgdHMuVHlwZUZsYWdzLk51bGw6XG4gICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgICBjYXNlIHRzLlR5cGVGbGFncy5OZXZlcjpcbiAgICAgICAgdGhpcy53YXJuKGBzaG91bGQgbm90IGVtaXQgYSAnbmV2ZXInIHR5cGVgKTtcbiAgICAgICAgcmV0dXJuICc/JztcbiAgICAgIGNhc2UgdHMuVHlwZUZsYWdzLlR5cGVQYXJhbWV0ZXI6XG4gICAgICAgIC8vIFRoaXMgaXMgZS5nLiB0aGUgVCBpbiBhIHR5cGUgbGlrZSBGb288VD4uXG4gICAgICAgIGlmICghdHlwZS5zeW1ib2wpIHtcbiAgICAgICAgICB0aGlzLndhcm4oYFR5cGVQYXJhbWV0ZXIgd2l0aG91dCBhIHN5bWJvbGApOyAgLy8gc2hvdWxkIG5vdCBoYXBwZW4gKHRtKVxuICAgICAgICAgIHJldHVybiAnPyc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW4gQ2xvc3VyZSwgdHlwZSBwYXJhbWV0ZXJzIChcIjxUPlwiKSBhcmUgbm9uLW51bGxhYmxlIGJ5IGRlZmF1bHQsIHVubGlrZSByZWZlcmVuY2VzIHRvXG4gICAgICAgIC8vIGNsYXNzZXMgb3IgaW50ZXJmYWNlcy4gSG93ZXZlciB0aGlzIGNvZGUgcGF0aCBjYW4gYmUgcmVhY2hlZCBieSBib3VuZCB0eXBlIHBhcmFtZXRlcnMsXG4gICAgICAgIC8vIHdoZXJlIHRoZSB0eXBlIHBhcmFtZXRlcidzIHN5bWJvbCByZWZlcmVuY2VzIGEgcGxhaW4gY2xhc3Mgb3IgaW50ZXJmYWNlLiBJbiB0aGlzIGNhc2UsXG4gICAgICAgIC8vIGFkZCBgIWAgdG8gYXZvaWQgZW1pdHRpbmcgYSBudWxsYWJsZSB0eXBlLlxuICAgICAgICBsZXQgcHJlZml4ID0gJyc7XG4gICAgICAgIGlmICgodHlwZS5zeW1ib2wuZmxhZ3MgJiB0cy5TeW1ib2xGbGFncy5UeXBlUGFyYW1ldGVyKSA9PT0gMCkge1xuICAgICAgICAgIHByZWZpeCA9ICchJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5zeW1ib2xUb1N0cmluZyh0eXBlLnN5bWJvbCk7XG4gICAgICAgIGlmICghbmFtZSkgcmV0dXJuICc/JztcbiAgICAgICAgcmV0dXJuIHByZWZpeCArIG5hbWU7XG4gICAgICBjYXNlIHRzLlR5cGVGbGFncy5PYmplY3Q6XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZU9iamVjdCh0eXBlIGFzIHRzLk9iamVjdFR5cGUpO1xuICAgICAgY2FzZSB0cy5UeXBlRmxhZ3MuVW5pb246XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZVVuaW9uKHR5cGUgYXMgdHMuVW5pb25UeXBlKTtcbiAgICAgIGNhc2UgdHMuVHlwZUZsYWdzLkNvbmRpdGlvbmFsOlxuICAgICAgY2FzZSB0cy5UeXBlRmxhZ3MuU3Vic3RpdHV0aW9uOlxuICAgICAgICB0aGlzLndhcm4oYGVtaXR0aW5nID8gZm9yIGNvbmRpdGlvbmFsL3N1YnN0aXR1dGlvbiB0eXBlYCk7XG4gICAgICAgIHJldHVybiAnPyc7XG4gICAgICBjYXNlIHRzLlR5cGVGbGFncy5JbnRlcnNlY3Rpb246XG4gICAgICBjYXNlIHRzLlR5cGVGbGFncy5JbmRleDpcbiAgICAgIGNhc2UgdHMuVHlwZUZsYWdzLkluZGV4ZWRBY2Nlc3M6XG4gICAgICAgIC8vIFRPRE8odHMyLjEpOiBoYW5kbGUgdGhlc2Ugc3BlY2lhbCB0eXBlcy5cbiAgICAgICAgdGhpcy53YXJuKGB1bmhhbmRsZWQgdHlwZSBmbGFnczogJHt0cy5UeXBlRmxhZ3NbdHlwZS5mbGFnc119YCk7XG4gICAgICAgIHJldHVybiAnPyc7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBIYW5kbGUgY2FzZXMgd2hlcmUgbXVsdGlwbGUgZmxhZ3MgYXJlIHNldC5cblxuICAgICAgICAvLyBUeXBlcyB3aXRoIGxpdGVyYWwgbWVtYmVycyBhcmUgcmVwcmVzZW50ZWQgYXNcbiAgICAgICAgLy8gICB0cy5UeXBlRmxhZ3MuVW5pb24gfCBbbGl0ZXJhbCBtZW1iZXJdXG4gICAgICAgIC8vIEUuZy4gYW4gZW51bSB0eXBlZCB2YWx1ZSBpcyBhIHVuaW9uIHR5cGUgd2l0aCB0aGUgZW51bSdzIG1lbWJlcnMgYXMgaXRzIG1lbWJlcnMuIEFcbiAgICAgICAgLy8gYm9vbGVhbiB0eXBlIGlzIGEgdW5pb24gdHlwZSB3aXRoICd0cnVlJyBhbmQgJ2ZhbHNlJyBhcyBpdHMgbWVtYmVycy5cbiAgICAgICAgLy8gTm90ZSBhbHNvIHRoYXQgaW4gYSBtb3JlIGNvbXBsZXggdW5pb24sIGUuZy4gYm9vbGVhbnxudW1iZXIsIHRoZW4gaXQncyBhIHVuaW9uIG9mIHRocmVlXG4gICAgICAgIC8vIHRoaW5ncyAodHJ1ZXxmYWxzZXxudW1iZXIpIGFuZCB0cy5UeXBlRmxhZ3MuQm9vbGVhbiBkb2Vzbid0IHNob3cgdXAgYXQgYWxsLlxuICAgICAgICBpZiAodHlwZS5mbGFncyAmIHRzLlR5cGVGbGFncy5Vbmlvbikge1xuICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZVVuaW9uKHR5cGUgYXMgdHMuVW5pb25UeXBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlLmZsYWdzICYgdHMuVHlwZUZsYWdzLkVudW1MaXRlcmFsKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlRW51bUxpdGVyYWwodHlwZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgc3dpdGNoIHN0YXRlbWVudCBzaG91bGQgaGF2ZSBiZWVuIGV4aGF1c3RpdmUuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5rbm93biB0eXBlIGZsYWdzICR7dHlwZS5mbGFnc30gb24gJHt0eXBlVG9EZWJ1Z1N0cmluZyh0eXBlKX1gKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHRyYW5zbGF0ZVVuaW9uKHR5cGU6IHRzLlVuaW9uVHlwZSk6IHN0cmluZyB7XG4gICAgbGV0IHBhcnRzID0gdHlwZS50eXBlcy5tYXAodCA9PiB0aGlzLnRyYW5zbGF0ZSh0KSk7XG4gICAgLy8gVW5pb24gdHlwZXMgdGhhdCBpbmNsdWRlIGxpdGVyYWxzIChlLmcuIGJvb2xlYW4sIGVudW0pIGNhbiBlbmQgdXAgcmVwZWF0aW5nIHRoZSBzYW1lIENsb3N1cmVcbiAgICAvLyB0eXBlLiBGb3IgZXhhbXBsZTogdHJ1ZSB8IGJvb2xlYW4gd2lsbCBiZSB0cmFuc2xhdGVkIHRvIGJvb2xlYW4gfCBib29sZWFuLlxuICAgIC8vIFJlbW92ZSBkdXBsaWNhdGVzIHRvIHByb2R1Y2UgdHlwZXMgdGhhdCByZWFkIGJldHRlci5cbiAgICBwYXJ0cyA9IHBhcnRzLmZpbHRlcigoZWwsIGlkeCkgPT4gcGFydHMuaW5kZXhPZihlbCkgPT09IGlkeCk7XG4gICAgcmV0dXJuIHBhcnRzLmxlbmd0aCA9PT0gMSA/IHBhcnRzWzBdIDogYCgke3BhcnRzLmpvaW4oJ3wnKX0pYDtcbiAgfVxuXG4gIHByaXZhdGUgdHJhbnNsYXRlRW51bUxpdGVyYWwodHlwZTogdHMuVHlwZSk6IHN0cmluZyB7XG4gICAgLy8gU3VwcG9zZSB5b3UgaGFkOlxuICAgIC8vICAgZW51bSBFbnVtVHlwZSB7IE1FTUJFUiB9XG4gICAgLy8gdGhlbiB0aGUgdHlwZSBvZiBcIkVudW1UeXBlLk1FTUJFUlwiIGlzIGFuIGVudW0gbGl0ZXJhbCAodGhlIHRoaW5nIHBhc3NlZCB0byB0aGlzIGZ1bmN0aW9uKVxuICAgIC8vIGFuZCBpdCBoYXMgdHlwZSBmbGFncyB0aGF0IGluY2x1ZGVcbiAgICAvLyAgIHRzLlR5cGVGbGFncy5OdW1iZXJMaXRlcmFsIHwgdHMuVHlwZUZsYWdzLkVudW1MaXRlcmFsXG4gICAgLy9cbiAgICAvLyBDbG9zdXJlIENvbXBpbGVyIGRvZXNuJ3Qgc3VwcG9ydCBsaXRlcmFscyBpbiB0eXBlcywgc28gdGhpcyBjb2RlIG11c3Qgbm90IGVtaXRcbiAgICAvLyBcIkVudW1UeXBlLk1FTUJFUlwiLCBidXQgcmF0aGVyIFwiRW51bVR5cGVcIi5cblxuICAgIGNvbnN0IGVudW1MaXRlcmFsQmFzZVR5cGUgPSB0aGlzLnR5cGVDaGVja2VyLmdldEJhc2VUeXBlT2ZMaXRlcmFsVHlwZSh0eXBlKTtcbiAgICBpZiAoIWVudW1MaXRlcmFsQmFzZVR5cGUuc3ltYm9sKSB7XG4gICAgICB0aGlzLndhcm4oYEVudW1MaXRlcmFsVHlwZSB3aXRob3V0IGEgc3ltYm9sYCk7XG4gICAgICByZXR1cm4gJz8nO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zeW1ib2xUb1N0cmluZyhlbnVtTGl0ZXJhbEJhc2VUeXBlLnN5bWJvbCkgfHwgJz8nO1xuICB9XG5cbiAgLy8gdHJhbnNsYXRlT2JqZWN0IHRyYW5zbGF0ZXMgYSB0cy5PYmplY3RUeXBlLCB3aGljaCBpcyB0aGUgdHlwZSBvZiBhbGxcbiAgLy8gb2JqZWN0LWxpa2UgdGhpbmdzIGluIFRTLCBzdWNoIGFzIGNsYXNzZXMgYW5kIGludGVyZmFjZXMuXG4gIHByaXZhdGUgdHJhbnNsYXRlT2JqZWN0KHR5cGU6IHRzLk9iamVjdFR5cGUpOiBzdHJpbmcge1xuICAgIGlmICh0eXBlLnN5bWJvbCAmJiB0aGlzLmlzQmxhY2tMaXN0ZWQodHlwZS5zeW1ib2wpKSByZXR1cm4gJz8nO1xuXG4gICAgLy8gTk9URTogb2JqZWN0RmxhZ3MgaXMgYW4gZW51bSwgYnV0IGEgZ2l2ZW4gdHlwZSBjYW4gaGF2ZSBtdWx0aXBsZSBmbGFncy5cbiAgICAvLyBBcnJheTxzdHJpbmc+IGlzIGJvdGggdHMuT2JqZWN0RmxhZ3MuUmVmZXJlbmNlIGFuZCB0cy5PYmplY3RGbGFncy5JbnRlcmZhY2UuXG5cbiAgICBpZiAodHlwZS5vYmplY3RGbGFncyAmIHRzLk9iamVjdEZsYWdzLkNsYXNzKSB7XG4gICAgICBpZiAoIXR5cGUuc3ltYm9sKSB7XG4gICAgICAgIHRoaXMud2FybignY2xhc3MgaGFzIG5vIHN5bWJvbCcpO1xuICAgICAgICByZXR1cm4gJz8nO1xuICAgICAgfVxuICAgICAgY29uc3QgbmFtZSA9IHRoaXMuc3ltYm9sVG9TdHJpbmcodHlwZS5zeW1ib2wpO1xuICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgIC8vIEFuIGFub255bW91cyB0eXBlLiBNYWtlIHN1cmUgbm90IHRvIGVtaXQgJyE/JywgYXMgdGhhdCBpcyBhIHN5bnRheCBlcnJvciBpbiBDbG9zdXJlXG4gICAgICAgIC8vIENvbXBpbGVyLlxuICAgICAgICByZXR1cm4gJz8nO1xuICAgICAgfVxuICAgICAgcmV0dXJuICchJyArIG5hbWU7XG4gICAgfSBlbHNlIGlmICh0eXBlLm9iamVjdEZsYWdzICYgdHMuT2JqZWN0RmxhZ3MuSW50ZXJmYWNlKSB7XG4gICAgICAvLyBOb3RlOiB0cy5JbnRlcmZhY2VUeXBlIGhhcyBhIHR5cGVQYXJhbWV0ZXJzIGZpZWxkLCBidXQgdGhhdFxuICAgICAgLy8gc3BlY2lmaWVzIHRoZSBwYXJhbWV0ZXJzIHRoYXQgdGhlIGludGVyZmFjZSB0eXBlICpleHBlY3RzKlxuICAgICAgLy8gd2hlbiBpdCdzIHVzZWQsIGFuZCBzaG91bGQgbm90IGJlIHRyYW5zZm9ybWVkIHRvIHRoZSBvdXRwdXQuXG4gICAgICAvLyBFLmcuIGEgdHlwZSBsaWtlIEFycmF5PG51bWJlcj4gaXMgYSBUeXBlUmVmZXJlbmNlIHRvIHRoZVxuICAgICAgLy8gSW50ZXJmYWNlVHlwZSBcIkFycmF5XCIsIGJ1dCB0aGUgXCJudW1iZXJcIiB0eXBlIHBhcmFtZXRlciBpc1xuICAgICAgLy8gcGFydCBvZiB0aGUgb3V0ZXIgVHlwZVJlZmVyZW5jZSwgbm90IGEgdHlwZVBhcmFtZXRlciBvblxuICAgICAgLy8gdGhlIEludGVyZmFjZVR5cGUuXG4gICAgICBpZiAoIXR5cGUuc3ltYm9sKSB7XG4gICAgICAgIHRoaXMud2FybignaW50ZXJmYWNlIGhhcyBubyBzeW1ib2wnKTtcbiAgICAgICAgcmV0dXJuICc/JztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlLnN5bWJvbC5mbGFncyAmIHRzLlN5bWJvbEZsYWdzLlZhbHVlKSB7XG4gICAgICAgIC8vIFRoZSBzeW1ib2wgaXMgYm90aCBhIHR5cGUgYW5kIGEgdmFsdWUuXG4gICAgICAgIC8vIEZvciB1c2VyLWRlZmluZWQgdHlwZXMgaW4gdGhpcyBzdGF0ZSwgd2UgZG9uJ3QgaGF2ZSBhIENsb3N1cmUgbmFtZVxuICAgICAgICAvLyBmb3IgdGhlIHR5cGUuICBTZWUgdGhlIHR5cGVfYW5kX3ZhbHVlIHRlc3QuXG4gICAgICAgIGlmICghaXNDbG9zdXJlUHJvdmlkZWRUeXBlKHR5cGUuc3ltYm9sKSkge1xuICAgICAgICAgIHRoaXMud2FybihgdHlwZS9zeW1ib2wgY29uZmxpY3QgZm9yICR7dHlwZS5zeW1ib2wubmFtZX0sIHVzaW5nIHs/fSBmb3Igbm93YCk7XG4gICAgICAgICAgcmV0dXJuICc/JztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuICchJyArIHRoaXMuc3ltYm9sVG9TdHJpbmcodHlwZS5zeW1ib2wpO1xuICAgIH0gZWxzZSBpZiAodHlwZS5vYmplY3RGbGFncyAmIHRzLk9iamVjdEZsYWdzLlJlZmVyZW5jZSkge1xuICAgICAgLy8gQSByZWZlcmVuY2UgdG8gYW5vdGhlciB0eXBlLCBlLmcuIEFycmF5PG51bWJlcj4gcmVmZXJzIHRvIEFycmF5LlxuICAgICAgLy8gRW1pdCB0aGUgcmVmZXJlbmNlZCB0eXBlIGFuZCBhbnkgdHlwZSBhcmd1bWVudHMuXG4gICAgICBjb25zdCByZWZlcmVuY2VUeXBlID0gdHlwZSBhcyB0cy5UeXBlUmVmZXJlbmNlO1xuXG4gICAgICAvLyBBIHR1cGxlIGlzIGEgUmVmZXJlbmNlVHlwZSB3aGVyZSB0aGUgdGFyZ2V0IGlzIGZsYWdnZWQgVHVwbGUgYW5kIHRoZVxuICAgICAgLy8gdHlwZUFyZ3VtZW50cyBhcmUgdGhlIHR1cGxlIGFyZ3VtZW50cy4gIEp1c3QgdHJlYXQgaXQgYXMgYSBteXN0ZXJ5XG4gICAgICAvLyBhcnJheSwgYmVjYXVzZSBDbG9zdXJlIGRvZXNuJ3QgdW5kZXJzdGFuZCB0dXBsZXMuXG4gICAgICBpZiAocmVmZXJlbmNlVHlwZS50YXJnZXQub2JqZWN0RmxhZ3MgJiB0cy5PYmplY3RGbGFncy5UdXBsZSkge1xuICAgICAgICByZXR1cm4gJyFBcnJheTw/Pic7XG4gICAgICB9XG5cbiAgICAgIGxldCB0eXBlU3RyID0gJyc7XG4gICAgICBpZiAocmVmZXJlbmNlVHlwZS50YXJnZXQgPT09IHJlZmVyZW5jZVR5cGUpIHtcbiAgICAgICAgLy8gV2UgZ2V0IGludG8gYW4gaW5maW5pdGUgbG9vcCBoZXJlIGlmIHRoZSBpbm5lciByZWZlcmVuY2UgaXNcbiAgICAgICAgLy8gdGhlIHNhbWUgYXMgdGhlIG91dGVyOyB0aGlzIGNhbiBvY2N1ciB3aGVuIHRoaXMgZnVuY3Rpb25cbiAgICAgICAgLy8gZmFpbHMgdG8gdHJhbnNsYXRlIGEgbW9yZSBzcGVjaWZpYyB0eXBlIGJlZm9yZSBnZXR0aW5nIHRvXG4gICAgICAgIC8vIHRoaXMgcG9pbnQuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGByZWZlcmVuY2UgbG9vcCBpbiAke3R5cGVUb0RlYnVnU3RyaW5nKHJlZmVyZW5jZVR5cGUpfSAke3JlZmVyZW5jZVR5cGUuZmxhZ3N9YCk7XG4gICAgICB9XG4gICAgICB0eXBlU3RyICs9IHRoaXMudHJhbnNsYXRlKHJlZmVyZW5jZVR5cGUudGFyZ2V0KTtcbiAgICAgIC8vIFRyYW5zbGF0ZSBjYW4gcmV0dXJuICc/JyBmb3IgYSBudW1iZXIgb2Ygc2l0dWF0aW9ucywgZS5nLiB0eXBlL3ZhbHVlIGNvbmZsaWN0cy5cbiAgICAgIC8vIGA/PD8+YCBpcyBpbGxlZ2FsIHN5bnRheCBpbiBDbG9zdXJlIENvbXBpbGVyLCBzbyBqdXN0IHJldHVybiBgP2AgaGVyZS5cbiAgICAgIGlmICh0eXBlU3RyID09PSAnPycpIHJldHVybiAnPyc7XG4gICAgICBpZiAocmVmZXJlbmNlVHlwZS50eXBlQXJndW1lbnRzKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHJlZmVyZW5jZVR5cGUudHlwZUFyZ3VtZW50cy5tYXAodCA9PiB0aGlzLnRyYW5zbGF0ZSh0KSk7XG4gICAgICAgIHR5cGVTdHIgKz0gYDwke3BhcmFtcy5qb2luKCcsICcpfT5gO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHR5cGVTdHI7XG4gICAgfSBlbHNlIGlmICh0eXBlLm9iamVjdEZsYWdzICYgdHMuT2JqZWN0RmxhZ3MuQW5vbnltb3VzKSB7XG4gICAgICBpZiAoIXR5cGUuc3ltYm9sKSB7XG4gICAgICAgIC8vIFRoaXMgY29tZXMgdXAgd2hlbiBnZW5lcmF0aW5nIGNvZGUgZm9yIGFuIGFycm93IGZ1bmN0aW9uIGFzIHBhc3NlZFxuICAgICAgICAvLyB0byBhIGdlbmVyaWMgZnVuY3Rpb24uICBUaGUgcGFzc2VkLWluIHR5cGUgaXMgdGFnZ2VkIGFzIGFub255bW91c1xuICAgICAgICAvLyBhbmQgaGFzIG5vIHByb3BlcnRpZXMgc28gaXQncyBoYXJkIHRvIGZpZ3VyZSBvdXQgd2hhdCB0byBnZW5lcmF0ZS5cbiAgICAgICAgLy8gSnVzdCBhdm9pZCBpdCBmb3Igbm93IHNvIHdlIGRvbid0IGNyYXNoLlxuICAgICAgICB0aGlzLndhcm4oJ2Fub255bW91cyB0eXBlIGhhcyBubyBzeW1ib2wnKTtcbiAgICAgICAgcmV0dXJuICc/JztcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUuc3ltYm9sLmZsYWdzICYgdHMuU3ltYm9sRmxhZ3MuRnVuY3Rpb24gfHxcbiAgICAgICAgICB0eXBlLnN5bWJvbC5mbGFncyAmIHRzLlN5bWJvbEZsYWdzLk1ldGhvZCkge1xuICAgICAgICBjb25zdCBzaWdzID0gdGhpcy50eXBlQ2hlY2tlci5nZXRTaWduYXR1cmVzT2ZUeXBlKHR5cGUsIHRzLlNpZ25hdHVyZUtpbmQuQ2FsbCk7XG4gICAgICAgIGlmIChzaWdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNpZ25hdHVyZVRvQ2xvc3VyZShzaWdzWzBdKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndhcm4oJ3VuaGFuZGxlZCBhbm9ueW1vdXMgdHlwZSB3aXRoIG11bHRpcGxlIGNhbGwgc2lnbmF0dXJlcycpO1xuICAgICAgICByZXR1cm4gJz8nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlQW5vbnltb3VzVHlwZSh0eXBlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgIFRPRE8odHMyLjEpOiBtb3JlIHVuaGFuZGxlZCBvYmplY3QgdHlwZSBmbGFnczpcbiAgICAgIFR1cGxlXG4gICAgICBNYXBwZWRcbiAgICAgIEluc3RhbnRpYXRlZFxuICAgICAgT2JqZWN0TGl0ZXJhbFxuICAgICAgRXZvbHZpbmdBcnJheVxuICAgICAgT2JqZWN0TGl0ZXJhbFBhdHRlcm5XaXRoQ29tcHV0ZWRQcm9wZXJ0aWVzXG4gICAgKi9cbiAgICB0aGlzLndhcm4oYHVuaGFuZGxlZCB0eXBlICR7dHlwZVRvRGVidWdTdHJpbmcodHlwZSl9YCk7XG4gICAgcmV0dXJuICc/JztcbiAgfVxuXG4gIC8qKlxuICAgKiB0cmFuc2xhdGVBbm9ueW1vdXNUeXBlIHRyYW5zbGF0ZXMgYSB0cy5UeXBlRmxhZ3MuT2JqZWN0VHlwZSB0aGF0IGlzIGFsc29cbiAgICogdHMuT2JqZWN0RmxhZ3MuQW5vbnltb3VzLiBUaGF0IGlzLCB0aGlzIHR5cGUncyBzeW1ib2wgZG9lcyBub3QgaGF2ZSBhIG5hbWUuIFRoaXMgaXMgdGhlXG4gICAqIGFub255bW91cyB0eXBlIGVuY291bnRlcmVkIGluIGUuZy5cbiAgICogICAgIGxldCB4OiB7YTogbnVtYmVyfTtcbiAgICogQnV0IGFsc28gdGhlIGluZmVycmVkIHR5cGUgaW46XG4gICAqICAgICBsZXQgeCA9IHthOiAxfTsgIC8vIHR5cGUgb2YgeCBpcyB7YTogbnVtYmVyfSwgYXMgYWJvdmVcbiAgICovXG4gIHByaXZhdGUgdHJhbnNsYXRlQW5vbnltb3VzVHlwZSh0eXBlOiB0cy5UeXBlKTogc3RyaW5nIHtcbiAgICB0aGlzLnNlZW5Bbm9ueW1vdXNUeXBlcy5hZGQodHlwZSk7XG4gICAgLy8gR2F0aGVyIHVwIGFsbCB0aGUgbmFtZWQgZmllbGRzIGFuZCB3aGV0aGVyIHRoZSBvYmplY3QgaXMgYWxzbyBjYWxsYWJsZS5cbiAgICBsZXQgY2FsbGFibGUgPSBmYWxzZTtcbiAgICBsZXQgaW5kZXhhYmxlID0gZmFsc2U7XG4gICAgY29uc3QgZmllbGRzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGlmICghdHlwZS5zeW1ib2wgfHwgIXR5cGUuc3ltYm9sLm1lbWJlcnMpIHtcbiAgICAgIHRoaXMud2FybignYW5vbnltb3VzIHR5cGUgaGFzIG5vIHN5bWJvbCcpO1xuICAgICAgcmV0dXJuICc/JztcbiAgICB9XG5cbiAgICAvLyBzcGVjaWFsLWNhc2UgY29uc3RydWN0IHNpZ25hdHVyZXMuXG4gICAgY29uc3QgY3RvcnMgPSB0eXBlLmdldENvbnN0cnVjdFNpZ25hdHVyZXMoKTtcbiAgICBpZiAoY3RvcnMubGVuZ3RoKSB7XG4gICAgICAvLyBUT0RPKG1hcnRpbnByb2JzdCk6IHRoaXMgZG9lcyBub3Qgc3VwcG9ydCBhZGRpdGlvbmFsIHByb3BlcnRpZXMgZGVmaW5lZCBvbiBjb25zdHJ1Y3RvcnNcbiAgICAgIC8vIChub3QgZXhwcmVzc2libGUgaW4gQ2xvc3VyZSksIG5vciBtdWx0aXBsZSBjb25zdHJ1Y3RvcnMgKHNhbWUpLlxuICAgICAgY29uc3QgZGVjbCA9IGN0b3JzWzBdLmRlY2xhcmF0aW9uO1xuICAgICAgaWYgKCFkZWNsKSB7XG4gICAgICAgIHRoaXMud2FybigndW5oYW5kbGVkIGFub255bW91cyB0eXBlIHdpdGggY29uc3RydWN0b3Igc2lnbmF0dXJlIGJ1dCBubyBkZWNsYXJhdGlvbicpO1xuICAgICAgICByZXR1cm4gJz8nO1xuICAgICAgfVxuICAgICAgaWYgKGRlY2wua2luZCA9PT0gdHMuU3ludGF4S2luZC5KU0RvY1NpZ25hdHVyZSkge1xuICAgICAgICB0aGlzLndhcm4oJ3VuaGFuZGxlZCBKU0RvYyBiYXNlZCBjb25zdHJ1Y3RvciBzaWduYXR1cmUnKTtcbiAgICAgICAgcmV0dXJuICc/JztcbiAgICAgIH1cblxuICAgICAgLy8gbmV3IDxUPih0ZWU6IFQpIGlzIG5vdCBzdXBwb3J0ZWQgYnkgQ2xvc3VyZSwgYmxhY2tsaXN0IGFzID8uXG4gICAgICB0aGlzLmJsYWNrbGlzdFR5cGVQYXJhbWV0ZXJzKHRoaXMuc3ltYm9sc1RvQWxpYXNlZE5hbWVzLCBkZWNsLnR5cGVQYXJhbWV0ZXJzKTtcblxuICAgICAgY29uc3QgcGFyYW1zID0gdGhpcy5jb252ZXJ0UGFyYW1zKGN0b3JzWzBdLCBkZWNsLnBhcmFtZXRlcnMpO1xuICAgICAgY29uc3QgcGFyYW1zU3RyID0gcGFyYW1zLmxlbmd0aCA/ICgnLCAnICsgcGFyYW1zLmpvaW4oJywgJykpIDogJyc7XG4gICAgICBjb25zdCBjb25zdHJ1Y3RlZFR5cGUgPSB0aGlzLnRyYW5zbGF0ZShjdG9yc1swXS5nZXRSZXR1cm5UeXBlKCkpO1xuICAgICAgLy8gSW4gdGhlIHNwZWNpZmljIGNhc2Ugb2YgdGhlIFwibmV3XCIgaW4gYSBmdW5jdGlvbiwgaXQgYXBwZWFycyB0aGF0XG4gICAgICAvLyAgIGZ1bmN0aW9uKG5ldzogIUJhcilcbiAgICAgIC8vIGZhaWxzIHRvIHBhcnNlLCB3aGlsZVxuICAgICAgLy8gICBmdW5jdGlvbihuZXc6ICghQmFyKSlcbiAgICAgIC8vIHBhcnNlcyBpbiB0aGUgd2F5IHlvdSdkIGV4cGVjdC5cbiAgICAgIC8vIEl0IGFwcGVhcnMgZnJvbSB0ZXN0aW5nIHRoYXQgQ2xvc3VyZSBpZ25vcmVzIHRoZSAhIGFueXdheSBhbmQganVzdFxuICAgICAgLy8gYXNzdW1lcyB0aGUgcmVzdWx0IHdpbGwgYmUgbm9uLW51bGwgaW4gZWl0aGVyIGNhc2UuICAoVG8gYmUgcGVkYW50aWMsXG4gICAgICAvLyBpdCdzIHBvc3NpYmxlIHRvIHJldHVybiBudWxsIGZyb20gYSBjdG9yIGl0IHNlZW1zIGxpa2UgYSBiYWQgaWRlYS4pXG4gICAgICByZXR1cm4gYGZ1bmN0aW9uKG5ldzogKCR7Y29uc3RydWN0ZWRUeXBlfSkke3BhcmFtc1N0cn0pOiA/YDtcbiAgICB9XG5cbiAgICAvLyBtZW1iZXJzIGlzIGFuIEVTNiBtYXAsIGJ1dCB0aGUgLmQudHMgZGVmaW5pbmcgaXQgZGVmaW5lZCB0aGVpciBvd24gbWFwXG4gICAgLy8gdHlwZSwgc28gdHlwZXNjcmlwdCBkb2Vzbid0IGJlbGlldmUgdGhhdCAua2V5cygpIGlzIGl0ZXJhYmxlXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICAgIGZvciAoY29uc3QgZmllbGQgb2YgKHR5cGUuc3ltYm9sLm1lbWJlcnMua2V5cygpIGFzIGFueSkpIHtcbiAgICAgIHN3aXRjaCAoZmllbGQpIHtcbiAgICAgICAgY2FzZSAnX19jYWxsJzpcbiAgICAgICAgICBjYWxsYWJsZSA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ19faW5kZXgnOlxuICAgICAgICAgIGluZGV4YWJsZSA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKCFpc1ZhbGlkQ2xvc3VyZVByb3BlcnR5TmFtZShmaWVsZCkpIHtcbiAgICAgICAgICAgIHRoaXMud2Fybihgb21pdHRpbmcgaW5leHByZXNzaWJsZSBwcm9wZXJ0eSBuYW1lOiAke2ZpZWxkfWApO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IG1lbWJlciA9IHR5cGUuc3ltYm9sLm1lbWJlcnMuZ2V0KGZpZWxkKSE7XG4gICAgICAgICAgLy8gb3B0aW9uYWwgbWVtYmVycyBhcmUgaGFuZGxlZCBieSB0aGUgdHlwZSBpbmNsdWRpbmcgfHVuZGVmaW5lZCBpbiBhIHVuaW9uIHR5cGUuXG4gICAgICAgICAgY29uc3QgbWVtYmVyVHlwZSA9XG4gICAgICAgICAgICAgIHRoaXMudHJhbnNsYXRlKHRoaXMudHlwZUNoZWNrZXIuZ2V0VHlwZU9mU3ltYm9sQXRMb2NhdGlvbihtZW1iZXIsIHRoaXMubm9kZSkpO1xuICAgICAgICAgIGZpZWxkcy5wdXNoKGAke2ZpZWxkfTogJHttZW1iZXJUeXBlfWApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRyeSB0byBzcGVjaWFsLWNhc2UgcGxhaW4ga2V5LXZhbHVlIG9iamVjdHMgYW5kIGZ1bmN0aW9ucy5cbiAgICBpZiAoZmllbGRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKGNhbGxhYmxlICYmICFpbmRleGFibGUpIHtcbiAgICAgICAgLy8gQSBmdW5jdGlvbiB0eXBlLlxuICAgICAgICBjb25zdCBzaWdzID0gdGhpcy50eXBlQ2hlY2tlci5nZXRTaWduYXR1cmVzT2ZUeXBlKHR5cGUsIHRzLlNpZ25hdHVyZUtpbmQuQ2FsbCk7XG4gICAgICAgIGlmIChzaWdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNpZ25hdHVyZVRvQ2xvc3VyZShzaWdzWzBdKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpbmRleGFibGUgJiYgIWNhbGxhYmxlKSB7XG4gICAgICAgIC8vIEEgcGxhaW4ga2V5LXZhbHVlIG1hcCB0eXBlLlxuICAgICAgICBsZXQga2V5VHlwZSA9ICdzdHJpbmcnO1xuICAgICAgICBsZXQgdmFsVHlwZSA9IHRoaXMudHlwZUNoZWNrZXIuZ2V0SW5kZXhUeXBlT2ZUeXBlKHR5cGUsIHRzLkluZGV4S2luZC5TdHJpbmcpO1xuICAgICAgICBpZiAoIXZhbFR5cGUpIHtcbiAgICAgICAgICBrZXlUeXBlID0gJ251bWJlcic7XG4gICAgICAgICAgdmFsVHlwZSA9IHRoaXMudHlwZUNoZWNrZXIuZ2V0SW5kZXhUeXBlT2ZUeXBlKHR5cGUsIHRzLkluZGV4S2luZC5OdW1iZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdmFsVHlwZSkge1xuICAgICAgICAgIHRoaXMud2FybigndW5rbm93biBpbmRleCBrZXkgdHlwZScpO1xuICAgICAgICAgIHJldHVybiBgIU9iamVjdDw/LD8+YDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCFPYmplY3Q8JHtrZXlUeXBlfSwke3RoaXMudHJhbnNsYXRlKHZhbFR5cGUpfT5gO1xuICAgICAgfSBlbHNlIGlmICghY2FsbGFibGUgJiYgIWluZGV4YWJsZSkge1xuICAgICAgICAvLyBUaGUgb2JqZWN0IGhhcyBubyBtZW1iZXJzLiAgVGhpcyBpcyB0aGUgVFMgdHlwZSAne30nLFxuICAgICAgICAvLyB3aGljaCBtZWFucyBcImFueSB2YWx1ZSBvdGhlciB0aGFuIG51bGwgb3IgdW5kZWZpbmVkXCIuXG4gICAgICAgIC8vIFdoYXQgaXMgdGhpcyBpbiBDbG9zdXJlJ3MgdHlwZSBzeXN0ZW0/XG4gICAgICAgIC8vXG4gICAgICAgIC8vIEZpcnN0LCB7IU9iamVjdH0gaXMgd3JvbmcgYmVjYXVzZSBpdCBpcyBub3QgYSBzdXBlcnR5cGUgb2ZcbiAgICAgICAgLy8ge3N0cmluZ30gb3Ige251bWJlcn0uICBUaGlzIHdvdWxkIG1lYW4geW91IGNhbm5vdCBhc3NpZ24gYVxuICAgICAgICAvLyBudW1iZXIgdG8gYSB2YXJpYWJsZSBvZiBUUyB0eXBlIHt9LlxuICAgICAgICAvL1xuICAgICAgICAvLyBXZSBnZXQgY2xvc2VyIHdpdGggeyp9LCBha2EgdGhlIEFMTCB0eXBlLiAgVGhpcyBvbmUgYmV0dGVyXG4gICAgICAgIC8vIGNhcHR1cmVzIHRoZSB0eXBpY2FsIHVzZSBvZiB0aGUgVFMge30sIHdoaWNoIHVzZXJzIHVzZSBmb3JcbiAgICAgICAgLy8gXCJJIGRvbid0IGNhcmVcIi5cbiAgICAgICAgLy9cbiAgICAgICAgLy8geyp9IHVuZm9ydHVuYXRlbHkgZG9lcyBpbmNsdWRlIG51bGwvdW5kZWZpbmVkLCBzbyBpdCdzIGEgY2xvc2VyXG4gICAgICAgIC8vIG1hdGNoIGZvciBUUyAzLjAncyAndW5rbm93bicuXG4gICAgICAgIHJldHVybiAnKic7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFjYWxsYWJsZSAmJiAhaW5kZXhhYmxlKSB7XG4gICAgICAvLyBOb3QgY2FsbGFibGUsIG5vdCBpbmRleGFibGU7IGltcGxpZXMgYSBwbGFpbiBvYmplY3Qgd2l0aCBmaWVsZHMgaW4gaXQuXG4gICAgICByZXR1cm4gYHske2ZpZWxkcy5qb2luKCcsICcpfX1gO1xuICAgIH1cblxuICAgIHRoaXMud2FybigndW5oYW5kbGVkIGFub255bW91cyB0eXBlJyk7XG4gICAgcmV0dXJuICc/JztcbiAgfVxuXG4gIC8qKiBDb252ZXJ0cyBhIHRzLlNpZ25hdHVyZSAoZnVuY3Rpb24gc2lnbmF0dXJlKSB0byBhIENsb3N1cmUgZnVuY3Rpb24gdHlwZS4gKi9cbiAgcHJpdmF0ZSBzaWduYXR1cmVUb0Nsb3N1cmUoc2lnOiB0cy5TaWduYXR1cmUpOiBzdHJpbmcge1xuICAgIC8vIFRPRE8obWFydGlucHJvYnN0KTogQ29uc2lkZXIgaGFybW9uaXppbmcgc29tZSBvdmVybGFwIHdpdGggZW1pdEZ1bmN0aW9uVHlwZSBpbiB0c2lja2xlLnRzLlxuICAgIGlmICghc2lnLmRlY2xhcmF0aW9uKSB7XG4gICAgICB0aGlzLndhcm4oJ3NpZ25hdHVyZSB3aXRob3V0IGRlY2xhcmF0aW9uJyk7XG4gICAgICByZXR1cm4gJ0Z1bmN0aW9uJztcbiAgICB9XG4gICAgaWYgKHNpZy5kZWNsYXJhdGlvbi5raW5kID09PSB0cy5TeW50YXhLaW5kLkpTRG9jU2lnbmF0dXJlKSB7XG4gICAgICB0aGlzLndhcm4oJ3NpZ25hdHVyZSB3aXRoIEpTRG9jIGRlY2xhcmF0aW9uJyk7XG4gICAgICByZXR1cm4gJ0Z1bmN0aW9uJztcbiAgICB9XG4gICAgdGhpcy5ibGFja2xpc3RUeXBlUGFyYW1ldGVycyh0aGlzLnN5bWJvbHNUb0FsaWFzZWROYW1lcywgc2lnLmRlY2xhcmF0aW9uLnR5cGVQYXJhbWV0ZXJzKTtcblxuICAgIGxldCB0eXBlU3RyID0gYGZ1bmN0aW9uKGA7XG4gICAgbGV0IHBhcmFtRGVjbHM6IFJlYWRvbmx5QXJyYXk8dHMuUGFyYW1ldGVyRGVjbGFyYXRpb24+ID0gc2lnLmRlY2xhcmF0aW9uLnBhcmFtZXRlcnMgfHwgW107XG4gICAgY29uc3QgbWF5YmVUaGlzUGFyYW0gPSBwYXJhbURlY2xzWzBdO1xuICAgIC8vIE9kZGx5LCB0aGUgdGhpcyB0eXBlIHNob3dzIHVwIGluIHBhcmFtRGVjbHMsIGJ1dCBub3QgaW4gdGhlIHR5cGUncyBwYXJhbWV0ZXJzLlxuICAgIC8vIEhhbmRsZSBpdCBoZXJlIGFuZCB0aGVuIHBhc3MgcGFyYW1EZWNscyBkb3duIHdpdGhvdXQgaXRzIGZpcnN0IGVsZW1lbnQuXG4gICAgaWYgKG1heWJlVGhpc1BhcmFtICYmIG1heWJlVGhpc1BhcmFtLm5hbWUuZ2V0VGV4dCgpID09PSAndGhpcycpIHtcbiAgICAgIGlmIChtYXliZVRoaXNQYXJhbS50eXBlKSB7XG4gICAgICAgIGNvbnN0IHRoaXNUeXBlID0gdGhpcy50eXBlQ2hlY2tlci5nZXRUeXBlQXRMb2NhdGlvbihtYXliZVRoaXNQYXJhbS50eXBlKTtcbiAgICAgICAgdHlwZVN0ciArPSBgdGhpczogKCR7dGhpcy50cmFuc2xhdGUodGhpc1R5cGUpfSlgO1xuICAgICAgICBpZiAocGFyYW1EZWNscy5sZW5ndGggPiAxKSB0eXBlU3RyICs9ICcsICc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLndhcm4oJ3RoaXMgdHlwZSB3aXRob3V0IHR5cGUnKTtcbiAgICAgIH1cbiAgICAgIHBhcmFtRGVjbHMgPSBwYXJhbURlY2xzLnNsaWNlKDEpO1xuICAgIH1cblxuICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMuY29udmVydFBhcmFtcyhzaWcsIHBhcmFtRGVjbHMpO1xuICAgIHR5cGVTdHIgKz0gYCR7cGFyYW1zLmpvaW4oJywgJyl9KWA7XG5cbiAgICBjb25zdCByZXRUeXBlID0gdGhpcy50cmFuc2xhdGUodGhpcy50eXBlQ2hlY2tlci5nZXRSZXR1cm5UeXBlT2ZTaWduYXR1cmUoc2lnKSk7XG4gICAgaWYgKHJldFR5cGUpIHtcbiAgICAgIHR5cGVTdHIgKz0gYDogJHtyZXRUeXBlfWA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHR5cGVTdHI7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgcGFyYW1ldGVycyBmb3IgdGhlIGdpdmVuIHNpZ25hdHVyZS4gVGFrZXMgcGFyYW1ldGVyIGRlY2xhcmF0aW9ucyBhcyB0aG9zZSBtaWdodCBub3RcbiAgICogbWF0Y2ggdGhlIHNpZ25hdHVyZSBwYXJhbWV0ZXJzIChlLmcuIHRoZXJlIG1pZ2h0IGJlIGFuIGFkZGl0aW9uYWwgdGhpcyBwYXJhbWV0ZXIpLiBUaGlzXG4gICAqIGRpZmZlcmVuY2UgaXMgaGFuZGxlZCBieSB0aGUgY2FsbGVyLCBhcyBpcyBjb252ZXJ0aW5nIHRoZSBcInRoaXNcIiBwYXJhbWV0ZXIuXG4gICAqL1xuICBwcml2YXRlIGNvbnZlcnRQYXJhbXMoc2lnOiB0cy5TaWduYXR1cmUsIHBhcmFtRGVjbHM6IFJlYWRvbmx5QXJyYXk8dHMuUGFyYW1ldGVyRGVjbGFyYXRpb24+KTpcbiAgICAgIHN0cmluZ1tdIHtcbiAgICBjb25zdCBwYXJhbVR5cGVzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2lnLnBhcmFtZXRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHBhcmFtID0gc2lnLnBhcmFtZXRlcnNbaV07XG5cbiAgICAgIGNvbnN0IHBhcmFtRGVjbCA9IHBhcmFtRGVjbHNbaV07XG4gICAgICBjb25zdCBvcHRpb25hbCA9ICEhcGFyYW1EZWNsLnF1ZXN0aW9uVG9rZW47XG4gICAgICBjb25zdCB2YXJBcmdzID0gISFwYXJhbURlY2wuZG90RG90RG90VG9rZW47XG4gICAgICBsZXQgcGFyYW1UeXBlID0gdGhpcy50eXBlQ2hlY2tlci5nZXRUeXBlT2ZTeW1ib2xBdExvY2F0aW9uKHBhcmFtLCB0aGlzLm5vZGUpO1xuICAgICAgaWYgKHZhckFyZ3MpIHtcbiAgICAgICAgY29uc3QgdHlwZVJlZiA9IHBhcmFtVHlwZSBhcyB0cy5UeXBlUmVmZXJlbmNlO1xuICAgICAgICBwYXJhbVR5cGUgPSB0eXBlUmVmLnR5cGVBcmd1bWVudHMhWzBdO1xuICAgICAgfVxuICAgICAgbGV0IHR5cGVTdHIgPSB0aGlzLnRyYW5zbGF0ZShwYXJhbVR5cGUpO1xuICAgICAgaWYgKHZhckFyZ3MpIHR5cGVTdHIgPSAnLi4uJyArIHR5cGVTdHI7XG4gICAgICBpZiAob3B0aW9uYWwpIHR5cGVTdHIgPSB0eXBlU3RyICsgJz0nO1xuICAgICAgcGFyYW1UeXBlcy5wdXNoKHR5cGVTdHIpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyYW1UeXBlcztcbiAgfVxuXG4gIHdhcm4obXNnOiBzdHJpbmcpIHtcbiAgICAvLyBCeSBkZWZhdWx0LCB3YXJuKCkgZG9lcyBub3RoaW5nLiAgVGhlIGNhbGxlciB3aWxsIG92ZXJ3cml0ZSB0aGlzXG4gICAgLy8gaWYgaXQgd2FudHMgZGlmZmVyZW50IGJlaGF2aW9yLlxuICB9XG5cbiAgLyoqIEByZXR1cm4gdHJ1ZSBpZiBzeW0gc2hvdWxkIGFsd2F5cyBoYXZlIHR5cGUgez99LiAqL1xuICBpc0JsYWNrTGlzdGVkKHN5bWJvbDogdHMuU3ltYm9sKTogYm9vbGVhbiB7XG4gICAgaWYgKHRoaXMucGF0aEJsYWNrTGlzdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgcGF0aEJsYWNrTGlzdCA9IHRoaXMucGF0aEJsYWNrTGlzdDtcbiAgICAvLyBTb21lIGJ1aWx0aW4gdHlwZXMsIHN1Y2ggYXMge30sIGdldCByZXByZXNlbnRlZCBieSBhIHN5bWJvbCB0aGF0IGhhcyBubyBkZWNsYXJhdGlvbnMuXG4gICAgaWYgKHN5bWJvbC5kZWNsYXJhdGlvbnMgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBzeW1ib2wuZGVjbGFyYXRpb25zLmV2ZXJ5KG4gPT4ge1xuICAgICAgY29uc3QgZmlsZU5hbWUgPSBwYXRoLm5vcm1hbGl6ZShuLmdldFNvdXJjZUZpbGUoKS5maWxlTmFtZSk7XG4gICAgICByZXR1cm4gcGF0aEJsYWNrTGlzdC5oYXMoZmlsZU5hbWUpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENsb3N1cmUgZG9lc24gbm90IHN1cHBvcnQgdHlwZSBwYXJhbWV0ZXJzIGZvciBmdW5jdGlvbiB0eXBlcywgaS5lLiBnZW5lcmljIGZ1bmN0aW9uIHR5cGVzLlxuICAgKiBCbGFja2xpc3QgdGhlIHN5bWJvbHMgZGVjbGFyZWQgYnkgdGhlbSBhbmQgZW1pdCBhID8gZm9yIHRoZSB0eXBlcy5cbiAgICpcbiAgICogVGhpcyBtdXRhdGVzIHRoZSBnaXZlbiBibGFja2xpc3QgbWFwLiBUaGUgbWFwJ3Mgc2NvcGUgaXMgb25lIGZpbGUsIGFuZCBzeW1ib2xzIGFyZVxuICAgKiB1bmlxdWUgb2JqZWN0cywgc28gdGhpcyBzaG91bGQgbmVpdGhlciBsZWFkIHRvIGV4Y2Vzc2l2ZSBtZW1vcnkgY29uc3VtcHRpb24gbm9yIGludHJvZHVjZVxuICAgKiBlcnJvcnMuXG4gICAqXG4gICAqIEBwYXJhbSBibGFja2xpc3QgYSBtYXAgdG8gc3RvcmUgdGhlIGJsYWNrbGlzdGVkIHN5bWJvbHMgaW4sIHdpdGggYSB2YWx1ZSBvZiAnPycuIEluIHByYWN0aWNlLFxuICAgKiAgICAgdGhpcyBpcyBhbHdheXMgPT09IHRoaXMuc3ltYm9sc1RvQWxpYXNlZE5hbWVzLCBidXQgd2UncmUgcGFzc2luZyBpdCBleHBsaWNpdGx5IHRvIG1ha2UgaXRcbiAgICogICAgY2xlYXIgdGhhdCB0aGUgbWFwIGlzIG11dGF0ZWQgKGluIHBhcnRpY3VsYXIgd2hlbiB1c2VkIGZyb20gb3V0c2lkZSB0aGUgY2xhc3MpLlxuICAgKiBAcGFyYW0gZGVjbHMgdGhlIGRlY2xhcmF0aW9ucyB3aG9zZSBzeW1ib2xzIHNob3VsZCBiZSBibGFja2xpc3RlZC5cbiAgICovXG4gIGJsYWNrbGlzdFR5cGVQYXJhbWV0ZXJzKFxuICAgICAgYmxhY2tsaXN0OiBNYXA8dHMuU3ltYm9sLCBzdHJpbmc+LFxuICAgICAgZGVjbHM6IFJlYWRvbmx5QXJyYXk8dHMuVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uPnx1bmRlZmluZWQpIHtcbiAgICBpZiAoIWRlY2xzIHx8ICFkZWNscy5sZW5ndGgpIHJldHVybjtcbiAgICBmb3IgKGNvbnN0IHRwZCBvZiBkZWNscykge1xuICAgICAgY29uc3Qgc3ltID0gdGhpcy50eXBlQ2hlY2tlci5nZXRTeW1ib2xBdExvY2F0aW9uKHRwZC5uYW1lKTtcbiAgICAgIGlmICghc3ltKSB7XG4gICAgICAgIHRoaXMud2FybihgdHlwZSBwYXJhbWV0ZXIgd2l0aCBubyBzeW1ib2xgKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0aGlzLnN5bWJvbHNUb0FsaWFzZWROYW1lcy5zZXQoc3ltLCAnPycpO1xuICAgIH1cbiAgfVxufVxuIl19